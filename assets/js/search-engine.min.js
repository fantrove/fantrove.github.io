// Ultra fast, high-accuracy search engine with improved single-character detection logic and incremental sentinel rendering
// + URL state & history integration (q, type, category) + sessionStorage search history
// + Disabled auto-search during typing; show query suggestions (from DB only)
// + Overlay "full-screen search" when input clicked; suggestions rendered inside overlay popup
// + Avoid storing repeated identical consecutive searches in history
// + On overlay open: automatically run search only when input not empty; keep overlay open if auto-run
// + Overlay now pushes a transient history entry so Back can close overlay. Back/overlay close will revert to pre-overlay query and will NOT record a search.
// + Clicking backdrop: if keyboard open (input focused) => treat as "search and close"; if keyboard closed => revert and close (no search).

let apiData = null;
let currentResults = [];
let filterCategories = [];
let selectedType = 'all';
let selectedCategory = 'all';
let debounceTimeout = null;
let allKeywordsCache = [];
let emojiSuggestionsCache = [];
let symbolSuggestionsCache = [];

// --- Incremental render / sentinel state ---
let renderObserver = null;
let renderBatchSize = 12; // number of items per "wave"
let currentRenderIndex = 0;
let currentFilteredResults = [];
let sentinelId = 'search-render-sentinel';

// --- History / URL state ---
const SEARCH_HISTORY_KEY = 'searchHistory_v1';
let suppressHistoryPush = false;
let lastCommittedState = null;

// --- Suggestions / Overlay UI state ---
let suggestionContainerId = 'searchSuggestions';
let suggestionMax = 8;
let overlayBackdropId = 'searchOverlayBackdrop';
let overlayContainerId = 'searchOverlayContainer';
let originalInputParent = null;
let originalInputNextSibling = null;
let overlayOpen = false;
// store state before overlay opened to allow revert
let preOverlayState = null;
// whether we've pushed a transient history entry for the overlay (so Back can close it)
let overlayHistoryPushed = false;
// when we programmatically call history.back() to remove overlay entry, suppress handling once
let suppressNextPopstate = false;

// --- Localization ---
const LANG_TEXTS = {
    th: {
        all_types: "ทุกประเภท",
        all_categories: "ทุกหมวดหมู่",
        not_found: "ไม่พบข้อมูลที่ตรงหรือใกล้เคียงกับคีย์เวิร์ดของคุณ",
        copy: "คัดลอก",
        suggestions_for_you: "คำแนะนำสำหรับคุณ",
        emoji_suggestions: "คำแนะนำอิโมจิ",
        symbol_suggestions: "คำแนะนำสัญลักษณ์",
        type: "ประเภท",
        category: "หมวดหมู่",
        emoji: "อิโมจิ",
        predicted: "คาดเดา",
        search_placeholder: "ค้นหา... (ตัวอย่าง: smile, heart)",
        search_result_here: "ผลการค้นหาจะแสดงที่นี่",
        suggestion_label: "คำค้นที่แนะนำ"
    },
    en: {
        all_types: "All Types",
        all_categories: "All Categories",
        not_found: "No data found related to your keyword.",
        copy: "Copy",
        suggestions_for_you: "Suggestions For You",
        emoji_suggestions: "Emoji Suggestions",
        symbol_suggestions: "Symbol Suggestions",
        type: "Type",
        category: "Category",
        emoji: "Emoji",
        predicted: "Predicted",
        search_placeholder: "Search... (e.g. smile, heart)",
        search_result_here: "Search results will appear here",
        suggestion_label: "Suggested queries"
    }
};
const t = (k) => { const l = getLang(); return (LANG_TEXTS[l] && LANG_TEXTS[l][k]) || LANG_TEXTS.en[k] || k; };
const getLang = () => localStorage.getItem('selectedLang') || (navigator.language && navigator.language.startsWith('th') ? 'th' : 'en');
const pickLang = (obj, langs) => {
    if (!obj || typeof obj !== 'object') return obj;
    for (let i = 0; i < langs.length; ++i) if (obj[langs[i]]) return obj[langs[i]];
    for (const k in obj) return obj[k];
    return '';
};

// Utility: compare states
function isStateEqual(a, b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    const aq = (a.q || '').trim();
    const bq = (b.q || '').trim();
    const at = (a.type || 'all');
    const bt = (b.type || 'all');
    const ac = (a.category || 'all');
    const bc = (b.category || 'all');
    return aq === bq && at === bt && ac === bc;
}

// --------------------- search helpers (unchanged) ---------------------

function getAllAvailableLangs(apiData) {
    const langs = Object.create(null);
    if (!apiData || !Array.isArray(apiData.type)) return ['en'];
    for (let i = 0, T = apiData.type.length; i < T; ++i) {
        const typeObj = apiData.type[i];
        if (typeof typeObj.name === 'object') for (const k in typeObj.name) langs[k] = 1;
        const categories = typeObj.category || [];
        for (let j = 0, C = categories.length; j < C; ++j) {
            const cat = categories[j];
            if (typeof cat.name === 'object') for (const k in cat.name) langs[k] = 1;
            const items = cat.data || [];
            for (let x = 0, N = items.length; x < N; ++x) {
                const item = items[x];
                if (typeof item.name === 'object') for (const k in item.name) langs[k] = 1;
                for (const k in item) if (/_name$/.test(k) && typeof item[k] === 'object')
                    for (const l in item[k]) langs[l] = 1;
            }
        }
    }
    return Object.keys(langs);
}

function generateAllKeywords(apiData) {
    const arr = [];
    const langs = getAllAvailableLangs(apiData);
    if (!apiData || !Array.isArray(apiData.type)) return [];
    for (let i = 0, T = apiData.type.length; i < T; ++i) {
        const typeObj = apiData.type[i];
        for (let l = 0, L = langs.length; l < L; ++l) {
            const lang = langs[l];
            const typeName = pickLang(typeObj.name, [lang]);
            if (typeName) arr.push({ typeObj, typeName, lang, key: typeName.toLowerCase(), isType: true });
        }
        const categories = typeObj.category || [];
        for (let j = 0, C = categories.length; j < C; ++j) {
            const cat = categories[j];
            for (let l = 0, L = langs.length; l < L; ++l) {
                const lang = langs[l];
                const catName = pickLang(cat.name, [lang]);
                if (catName) arr.push({ typeObj, category: cat, typeName: pickLang(typeObj.name, [lang]), catName, lang, key: catName.toLowerCase(), isCategory: true });
            }
            const items = cat.data || [];
            for (let x = 0, N = items.length; x < N; ++x) {
                const item = items[x];
                for (let l = 0, L = langs.length; l < L; ++l) {
                    const lang = langs[l];
                    const itemName = pickLang(item.name, [lang]);
                    if (itemName) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, [lang]), catName: pickLang(cat.name, [lang]), itemName, lang, key: itemName.toLowerCase(), isItem: true });
                }
                for (const k in item) {
                    if (/_name$/.test(k) && typeof item[k] === 'object') {
                        for (let l = 0, L = langs.length; l < L; ++l) {
                            const lang = langs[l];
                            const vVal = pickLang(item[k], [lang]);
                            if (vVal) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, [lang]), catName: pickLang(cat.name, [lang]), itemName: vVal, lang, key: vVal.toLowerCase(), isItem: true });
                        }
                    }
                }
                if (item.text) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'text', key: (item.text || '').toLowerCase(), isItem: true });
                if (item.api) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'api', key: (item.api || '').toLowerCase(), isItem: true });
            }
        }
    }
    return arr;
}

function levenshtein(a, b) {
    if (a === b) return 0;
    const al = a.length, bl = b.length;
    if (!al) return bl;
    if (!bl) return al;
    let v0 = new Uint16Array(bl + 1), v1 = new Uint16Array(bl + 1);
    for (let i = 0; i <= bl; ++i) v0[i] = i;
    for (let i = 0; i < al; ++i) {
        v1[0] = i + 1;
        for (let j = 0; j < bl; ++j)
            v1[j + 1] = Math.min(
                v1[j] + 1,
                v0[j + 1] + 1,
                v0[j] + (a[i] === b[j] ? 0 : 1)
            );
        let t = v0; v0 = v1; v1 = t;
    }
    return v0[bl];
}
const computeRelevanceScore = (query, target, baseScore = 100) => (!target ? baseScore : (() => {
    let s = levenshtein(query, target);
    if (target.startsWith(query)) s -= 1;
    if (target.includes(query)) s -= 0.5;
    return s;
})());
const keywordExactSubstringMatch = (query, allKeywords) => {
    query = query.toLowerCase();
    for (let i = 0, L = allKeywords.length; i < L; ++i) if (allKeywords[i].key.includes(query)) return true;
    return false;
};

function getBestKeywordMatches(query, allKeywords, maxCount = 12, allowGuess = true) {
    if (!query) return [];
    if (!allowGuess && keywordExactSubstringMatch(query, allKeywords)) return [];
    let out = [];
    for (let i = 0, L = allKeywords.length; i < L; ++i) {
        const k = allKeywords[i];
        let s = [computeRelevanceScore(query, k.key, 100)];
        if (k.isCategory && k.catName) s.push(computeRelevanceScore(query, k.catName, 110));
        if (k.typeName) s.push(computeRelevanceScore(query, k.typeName, 110));
        if (k.itemName) s.push(computeRelevanceScore(query, k.itemName, 120));
        if (k.item) {
            if (k.item.text) s.push(computeRelevanceScore(query, k.item.text, 120));
            if (k.item.api) s.push(computeRelevanceScore(query, k.item.api, 125));
        }
        k._score = Math.min.apply(null, s);
        out.push(k);
    }
    out.sort((a, b) => a._score - b._score);
    let seen = new Set(), uniq = [], cnt = 0;
    for (let i = 0, L = out.length; i < L && cnt < maxCount; ++i) {
        const k = out[i];
        if (k._score > 2) break;
        const uniqKey = k.isType ? `type|${k.typeName}|${k.lang}` : k.isCategory
            ? `cat|${k.typeName}|${k.catName}|${k.lang}` : `item|${k.typeName}|${k.catName}|${k.item && (k.item.api || k.item.text) || ''}|${k.lang}`;
        if (!seen.has(uniqKey)) { seen.add(uniqKey); uniq.push(Object.assign({}, k, { fuzzyScore: k._score })); ++cnt; }
    }
    return uniq;
}

function smartSearch(apiData, query, typeFilter, allKeywords) {
    query = (query || '').toLowerCase().trim();
    if (!query) return [];
    let results = [], langs = getAllAvailableLangs(apiData);

    if (!apiData || !Array.isArray(apiData.type)) return results;

    // Precise handling for single-character input
    if (query.length === 1) {
        let has = false;
        for (let i = 0, L = allKeywords.length; i < L; ++i) {
            if (allKeywords[i].key.includes(query)) { has = true; break; }
        }
        if (!has) return [];
    }

    for (let i = 0, T = apiData.type.length; i < T; ++i) {
        const typeObj = apiData.type[i];
        for (let l = 0, L = langs.length; l < L; ++l) {
            const lang = langs[l];
            let typeLabel = pickLang(typeObj.name, [lang]);
            if (typeFilter !== 'all' && pickLang(typeObj.name, [getLang()]) !== typeFilter) continue;
            const cats = typeObj.category || [];
            for (let j = 0, C = cats.length; j < C; ++j) {
                let cat = cats[j], catName = pickLang(cat.name, [lang]);
                const catNames = [catName.toLowerCase()], items = cat.data || [];
                for (let x = 0, N = items.length; x < N; ++x) {
                    let item = items[x], itemNames = [];
                    if (item.name) itemNames.push(pickLang(item.name, [lang]).toLowerCase());
                    for (const k in item) if (/_name$/.test(k) && item[k]) itemNames.push(pickLang(item[k], [lang]).toLowerCase());
                    const matchTokens = catNames.concat(itemNames, (item.text || ''), (item.api || ''));
                    let isMatch = false, minFuzz = 100;
                    for (let y = 0, Y = matchTokens.length; y < Y; ++y) {
                        const txt = matchTokens[y];
                        if (!txt) continue;
                        if (txt.includes(query)) isMatch = true;
                        minFuzz = Math.min(minFuzz, levenshtein(query, txt));
                    }
                    let isFuzzy = !isMatch && minFuzz <= 2;
                    if (isMatch || isFuzzy) results.push({
                        typeObj, typeName: typeLabel, category: cat, catName, item,
                        itemName: pickLang(item.name, [lang]), lang, fuzzy: !isMatch && isFuzzy, fuzzyScore: minFuzz
                    });
                }
            }
        }
    }

    // If any exact substring match, show only those (never fuzzy/predict)
    if (keywordExactSubstringMatch(query, allKeywords)) {
        let sub = [];
        for (let i = 0, L = results.length; i < L; ++i) if (!results[i].fuzzy) sub.push(results[i]);
        return sub.length ? sub : [];
    }

    // For query length 1: if not found above, no prediction is allowed, return []
    if (query.length === 1) return [];

    // For length >= 2: Prediction as before
    if (results.length) {
        let allFuzzy = true;
        for (let i = 0, L = results.length; i < L; ++i) if (!results[i].fuzzy) { allFuzzy = false; break; }
        if (allFuzzy) for (let i = 0, L = results.length; i < L; ++i) results[i].isPrediction = true;
        return results;
    }
    const predictionResults = getBestKeywordMatches(query, allKeywords, 10, false);
    if (!predictionResults.length) return [];
    let out = [];
    for (let i = 0, L = predictionResults.length; i < L; ++i) {
        const s = predictionResults[i];
        if (s.isType) out.push({
            typeObj: s.typeObj, typeName: s.typeName,
            category: (s.typeObj.category && s.typeObj.category[0]) || { name: "", data: [] },
            catName: pickLang((s.typeObj.category && s.typeObj.category[0] && s.typeObj.category[0].name) || "", [s.lang]),
            item: (((s.typeObj.category || [])[0] || {}).data || [{}])[0] || { text: '', api: '' },
            itemName: "", lang: s.lang, isSuggestion: true, isPrediction: true, suggestionType: 'type', suggestionKeyword: s.key, fuzzyScore: s.fuzzyScore
        });
        else if (s.isCategory) out.push({
            typeObj: s.typeObj, typeName: s.typeName, category: s.category, catName: s.catName,
            item: ((s.category.data && s.category.data.length) ? s.category.data[0] : { text: '', api: '' }),
            itemName: "", lang: s.lang, isSuggestion: true, isPrediction: true, suggestionType: 'category', suggestionKeyword: s.key, fuzzyScore: s.fuzzyScore
        });
        else out.push({
            typeObj: s.typeObj, typeName: s.typeName, category: s.category, catName: s.catName, item: s.item, itemName: s.itemName,
            lang: s.lang, isSuggestion: true, isPrediction: true, suggestionType: 'item', suggestionKeyword: s.key, fuzzyScore: s.fuzzyScore
        });
    }
    return out;
}

// --------------------- UI / Overlay / Suggestions ---------------------

function setupTypeFilter(selected = 'all') {
    const typeFilter = document.getElementById('typeFilter');
    if (!typeFilter) return;
    let buf = [`<option value="all">${t('all_types')}</option>`];
    if (apiData && Array.isArray(apiData.type)) {
        const lang = getLang();
        for (let i = 0, T = apiData.type.length; i < T; ++i) {
            let label = pickLang(apiData.type[i].name, [lang]);
            buf.push(`<option value="${label}">${label}</option>`);
        }
    }
    typeFilter.innerHTML = buf.join('');
    typeFilter.value = selected;
}

function setupCategoryFilter(categories, selected = 'all') {
    const catFilter = document.getElementById('categoryFilter');
    if (!catFilter) return;
    let buf = [`<option value="all">${t('all_categories')}</option>`];
    for (let i = 0, L = categories.length; i < L; ++i) {
        const { key, displayName } = categories[i];
        buf.push(`<option value="${key}">${displayName}</option>`);
    }
    catFilter.innerHTML = buf.join('');
    catFilter.style.display = '';
    catFilter.value = selected;
}

function getRandomSuggestions(arr, count = 5) {
    if (!arr || !arr.length) return [];
    let n = arr.length, out = [], idx;
    const pool = arr.slice();
    for (let i = 0; i < count && n > 0; ++i, --n) {
        idx = (Math.random() * n) | 0;
        out.push(pool[idx]);
        pool[idx] = pool[n - 1];
    }
    return out;
}

function extractResultCategories(results) {
    const lang = getLang();
    let categories = [], seen = Object.create(null);
    for (let i = 0, L = results.length; i < L; ++i) {
        const cat = results[i].category || { name: '' }, key = pickLang(cat.name, [lang]) || '';
        const displayName = key;
        if (!seen[key]) { seen[key] = 1; categories.push({ key, displayName }); }
    }
    return categories;
}

function showCopyToast(msg) {
    const toast = document.createElement('div');
    toast.className = 'copy-toast-message';
    toast.textContent = msg;
    const area = document.getElementById('copyToast') || document.body;
    area.appendChild(toast);
    setTimeout(() => { toast.style.opacity = '0'; toast.style.transform = 'translateY(-10px)'; setTimeout(() => toast.remove(), 250); }, 1400);
}

async function copyText(text) {
    try { await navigator.clipboard.writeText(text); showCopyToast(t('copy') + 'แล้ว'); }
    catch { showCopyToast('ไม่สามารถ' + t('copy') + 'ได้'); }
}

function renderSuggestionsBlock(lang, emojis = [], symbols = []) {
    let html = '';
    if (emojis.length) {
        html += `<div class="suggestions-head">${t('emoji_suggestions')}</div>`;
        for (let i = 0, L = emojis.length; i < L; ++i) html += renderSuggestionItemWithRealCategory(emojis[i], lang);
    }
    if (symbols.length) {
        html += `<div class="suggestions-head">${t('symbol_suggestions')}</div>`;
        for (let i = 0, L = symbols.length; i < L; ++i) html += renderSuggestionItemWithRealCategory(symbols[i], lang);
    }
    return `<div class="suggestions-block-list">${html}</div>`;
}
function renderSuggestionItemWithRealCategory(obj, lang) {
    const typeLabel = t('type'), catLabel = t('category');
    let catName = obj.category ? (pickLang(obj.category.name, [lang]) || obj.category.name || "") : '';
    let typeDisplay = obj.typeObj ? (pickLang(obj.typeObj.name, [lang]) || obj.typeObj.name || "") : '';
    if (!typeDisplay) typeDisplay = t('emoji');
    const text = obj.text || '-';
    const api = obj.api || '';
    return `<div class="result-item"><div class="result-content-area"><div class="result-text-area"><span class="result-text">${text}</span><span class="result-api">${api}</span></div><div class="result-meta-area"><span class="meta-type">${typeLabel}: ${typeDisplay}</span> <span class="meta-cat">${catLabel}: ${catName}</span></div><div class="result-actions"><button class="result-copy-btn" data-text="${encodeURIComponent(text)}">${t('copy')}</button></div></div></div>`;
}

function setBodyMarginForSearch(active) {
    const body = document.body;
    if (active) {
        if (body.style.marginBottom !== "60px") body.style.marginBottom = "60px";
    } else {
        if (body.style.marginBottom !== "") body.style.marginBottom = "";
    }
}

function renderResultItemHTML(res, lang) {
    let itemNames = [];
    if (res.item && res.item.name) itemNames.push(pickLang(res.item.name, [lang]));
    for (const k in (res.item || {})) if (/_name$/.test(k) && res.item[k]) itemNames.push(pickLang(res.item[k], [lang]));
    itemNames = itemNames.filter(Boolean).join(' / ');
    let typeDisplay = res.typeObj && res.typeObj.name ? pickLang(res.typeObj.name, [lang]) : "";
    if (!typeDisplay) typeDisplay = t('emoji');
    const catDisplay = (res.category && res.category.name) ? pickLang(res.category.name, [lang]) : '';
    let fuzzyHint = (res.fuzzy && res.isPrediction) ? `<div class="fuzzy-hint" style="color:#e08b35;font-size:.98em;font-weight:400; margin-bottom:4px;">${t('predicted')}</div>` : '';
    const text = res.item && res.item.text ? res.item.text : '-';
    const api = res.item && res.item.api ? res.item.api : '';
    return `<div class="result-item"><div class="result-content-area">${fuzzyHint}<div class="result-text-area"><span class="result-text">${text}</span><span class="result-api">${api}</span></div><div class="result-meta-area"><span class="meta-type">${t('type')}: ${typeDisplay}</span> <span class="meta-cat">${t('category')}: ${catDisplay}</span></div><div class="result-actions"><button class="result-copy-btn" data-text="${encodeURIComponent(text)}">${t('copy')}</button></div></div></div>`;
}

function disconnectRenderObserver() {
    if (renderObserver) {
        try { renderObserver.disconnect(); } catch (e) {}
        renderObserver = null;
    }
    const old = document.getElementById(sentinelId);
    if (old && old.parentNode) old.parentNode.removeChild(old);
}

function renderNextBatch() {
    const container = document.getElementById('searchResults');
    if (!container) return;
    const lang = getLang();
    const start = currentRenderIndex;
    const end = Math.min(currentRenderIndex + renderBatchSize, currentFilteredResults.length);
    let fragment = '';
    for (let i = start; i < end; ++i) {
        fragment += renderResultItemHTML(currentFilteredResults[i], lang);
    }
    const sentinelEl = document.getElementById(sentinelId);
    if (sentinelEl) {
        sentinelEl.insertAdjacentHTML('beforebegin', fragment);
    } else {
        container.insertAdjacentHTML('beforeend', fragment);
    }
    currentRenderIndex = end;

    if (currentRenderIndex >= currentFilteredResults.length) {
        disconnectRenderObserver();
    } else {
        if (!document.getElementById(sentinelId)) {
            const s = document.createElement('div');
            s.id = sentinelId;
            s.className = 'search-sentinel';
            s.style.cssText = 'width:100%;height:36px;display:block;';
            container.appendChild(s);
        }
        if (!renderObserver) {
            renderObserver = new IntersectionObserver((entries) => {
                for (let i = 0; i < entries.length; ++i) {
                    if (entries[i].isIntersecting) {
                        setTimeout(() => {
                            if (currentRenderIndex < currentFilteredResults.length) renderNextBatch();
                        }, 50);
                    }
                }
            }, { root: null, rootMargin: '0px', threshold: 0.1 });
            const sEl = document.getElementById(sentinelId);
            if (sEl) renderObserver.observe(sEl);
        }
    }
}

// --- URL / History helpers ---
function parseQueryString(qs) {
    const out = {};
    if (!qs) return out;
    qs = qs.replace(/^\?/, '');
    const parts = qs.split('&');
    for (let i = 0; i < parts.length; ++i) {
        const p = parts[i];
        if (!p) continue;
        const idx = p.indexOf('=');
        if (idx === -1) { out[decodeURIComponent(p)] = ''; }
        else {
            const key = decodeURIComponent(p.substring(0, idx));
            const val = decodeURIComponent(p.substring(idx + 1));
            out[key] = val;
        }
    }
    return out;
}
function buildQueryString(obj) {
    const parts = [];
    for (const k in obj) {
        if (obj[k] === undefined || obj[k] === null) continue;
        parts.push(encodeURIComponent(k) + '=' + encodeURIComponent(obj[k]));
    }
    return parts.length ? ('?' + parts.join('&')) : '';
}
function readStateFromURL() {
    const params = parseQueryString(window.location.search || '');
    return {
        q: params.q || '',
        type: params.type || 'all',
        category: params.category || 'all'
    };
}
function buildUrlForState(state) {
    const params = {};
    if (state.q) params.q = state.q;
    if (state.type && state.type !== 'all') params.type = state.type;
    if (state.category && state.category !== 'all') params.category = state.category;
    return buildQueryString(params);
}

function pushSearchStateToHistory(state) {
    try {
        if (isStateEqual(state, lastCommittedState)) {
            return;
        }
    } catch (e) {}
    const url = buildUrlForState(state);
    try {
        history.pushState(state, '', url);
    } catch (e) {
        history.replaceState(state, '', url);
    }
    try {
        const raw = sessionStorage.getItem(SEARCH_HISTORY_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        arr.push(Object.assign({}, state, { ts: Date.now() }));
        sessionStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(arr));
    } catch (e) {}
    lastCommittedState = { q: state.q || '', type: state.type || 'all', category: state.category || 'all' };
}

function restoreUIState(state) {
    suppressHistoryPush = true;
    try {
        const input = document.getElementById('searchInput');
        if (input) input.value = state.q || '';
        if (state.type) {
            const tf = document.getElementById('typeFilter');
            if (tf) {
                const has = Array.prototype.slice.call(tf.options).some(o => o.value === state.type);
                if (has) tf.value = state.type;
            }
            selectedType = state.type || 'all';
        }
        if (state.category) {
            const cf = document.getElementById('categoryFilter');
            if (cf) {
                const has = Array.prototype.slice.call(cf.options).some(o => o.value === state.category);
                if (has) cf.value = state.category;
            }
            selectedCategory = state.category || 'all';
        }
        doSearch(null, true);
    } finally {
        suppressHistoryPush = false;
    }
}

function cleanupRenderingState() {
    disconnectRenderObserver();
    currentFilteredResults = [];
    currentRenderIndex = 0;
}

function renderResults(results, showSuggestionsIfNoResult = false) {
    const container = document.getElementById('searchResults');
    const lang = getLang();
    if (!container) return;
    let filtered = (selectedCategory !== 'all') ? results.filter(res => pickLang((res.category && res.category.name) || '', [lang]) === selectedCategory) : results.slice();
    setBodyMarginForSearch(true);
    cleanupRenderingState();
    if (!filtered.length) {
        let html = `<div class="no-result">${t('not_found')}</div>`;
        if (showSuggestionsIfNoResult) {
            html += `<div class="suggestions-title-main">${t('suggestions_for_you')}</div>`;
            html += renderSuggestionsBlock(lang, getRandomSuggestions(emojiSuggestionsCache, 4), getRandomSuggestions(symbolSuggestionsCache, 4));
        }
        container.innerHTML = html;
        const catFilterEl = document.getElementById('categoryFilter');
        if (catFilterEl) catFilterEl.style.display = '';
        filterCategories = [];
        updateUILanguage();
        return;
    }
    currentFilteredResults = filtered;
    currentRenderIndex = 0;
    container.innerHTML = '';
    renderNextBatch();
    if (!window._copyResultTextHandlerSet) {
        container.addEventListener('click', function(e) {
            const btn = e.target.closest('.result-copy-btn');
            if (btn && btn.hasAttribute('data-text')) {
                e.preventDefault(); copyText(decodeURIComponent(btn.getAttribute('data-text')));
            }
        });
        window._copyResultTextHandlerSet = true;
    }
    updateUILanguage();
}

// Suggestions UI helpers (inside overlay)
function ensureSuggestionContainer() {
    let c = document.getElementById(suggestionContainerId);
    if (c) return c;
    const overlay = document.getElementById(overlayContainerId);
    if (!overlay) return null;
    c = document.createElement('div');
    c.id = suggestionContainerId;
    c.className = 'search-suggestions';
    c.style.cssText = 'position:relative; z-index:9999; max-height:320px; overflow:auto; background:#fff; border:1px solid #e6e9ee; box-shadow:0 8px 30px rgba(19,23,40,0.12); border-radius:10px; margin-top:10px;';
    overlay.appendChild(c);
    c.addEventListener('click', function(ev) {
        const it = ev.target.closest('.suggestion-item');
        if (!it) return;
        let val = it.getAttribute('data-val') || '';
        try { val = decodeURIComponent(val); } catch (e) {}
        const inputEl = document.getElementById('searchInput');
        if (inputEl) inputEl.value = val;
        hideSuggestions();
        doSearch(null, false);
    });
    return c;
}

function hideSuggestions() {
    const c = document.getElementById(suggestionContainerId);
    if (c) c.style.display = 'none';
}

function renderQuerySuggestions(query) {
    if (!overlayOpen) openSearchOverlay();
    const container = ensureSuggestionContainer();
    if (!container) return;
    if (!query || !query.trim()) {
        container.innerHTML = '';
        container.style.display = 'none';
        return;
    }
    const q = query.toLowerCase().trim();
    const matches = getBestKeywordMatches(q, allKeywordsCache, suggestionMax, true);
    if (!matches || !matches.length) {
        container.innerHTML = '';
        container.style.display = 'none';
        return;
    }
    const lang = getLang();
    let html = `<div class="suggestions-head" style="padding:8px 10px;font-weight:600;color:#333;">${t('suggestion_label')}</div>`;
    for (let i = 0; i < matches.length; ++i) {
        const s = matches[i];
        let display = '';
        let meta = '';
        if (s.isType) {
            display = s.typeName || s.key;
            meta = t('type');
        } else if (s.isCategory) {
            display = s.catName || s.key;
            meta = s.typeName || '';
        } else {
            display = s.itemName || (s.item && (s.item.text || s.item.api)) || s.key;
            meta = s.catName || s.typeName || '';
        }
        const safeDisplay = (display || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const safeMeta = (meta || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const val = s.key || display || '';
        html += `<div class="suggestion-item" data-val="${encodeURIComponent(val)}" tabindex="0" style="padding:8px 10px;border-top:1px solid #f4f6fa;cursor:pointer;display:flex;justify-content:space-between;align-items:center;"><span class="suggestion-text">${safeDisplay}</span><span class="suggestion-meta" style="color:#8b93a7;font-size:.9em;margin-left:12px;">${safeMeta}</span></div>`;
    }
    container.innerHTML = html;
    container.style.display = 'block';
}

// Overlay management
function openSearchOverlay() {
    if (overlayOpen) return;
    const wrapper = document.querySelector('.search-input-wrapper');
    if (!wrapper) return;
    // save original location
    originalInputParent = wrapper.parentNode;
    originalInputNextSibling = wrapper.nextSibling;
    // store pre-overlay state for potential revert
    const inputEl = document.getElementById('searchInput');
    preOverlayState = {
        q: inputEl ? (inputEl.value || '') : '',
        type: selectedType || 'all',
        category: selectedCategory || 'all'
    };

    // create backdrop
    let backdrop = document.getElementById(overlayBackdropId);
    if (!backdrop) {
        backdrop = document.createElement('div');
        backdrop.id = overlayBackdropId;
        backdrop.className = 'search-overlay-backdrop';
        backdrop.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(12,14,18,0.48);z-index:9998;backdrop-filter:blur(4px);';
        document.body.appendChild(backdrop);
    }
    // create overlay container
    let overlay = document.getElementById(overlayContainerId);
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = overlayContainerId;
        overlay.className = 'search-overlay search-overlay-open';
        // position input at top: justify-content:flex-start and padding-top
        overlay.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:24px 16px 16px 16px;box-sizing:border-box;';
        document.body.appendChild(overlay);
    } else {
        overlay.innerHTML = '';
    }

    // move wrapper into overlay and style to be elevated
    wrapper.classList.add('overlay-elevated');
    wrapper.style.width = '100%';
    wrapper.style.maxWidth = '720px';
    wrapper.style.marginTop = '6px';
    overlay.appendChild(wrapper);

    // suggestions container (will be created inside ensureSuggestionContainer)
    ensureSuggestionContainer();

    // focus input
    const input = document.getElementById('searchInput');
    if (input) {
        setTimeout(() => { try { input.focus(); input.select && input.select(); } catch (e) {} }, 20);
    }

    // prevent background scroll
    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';

    // backdrop click behavior:
    // - if input is focused (keyboard open) => treat as "search and close"
    // - if input not focused (keyboard closed) => revert to preOverlayState and close (no search)
    backdrop.onclick = function() {
        const inp = document.getElementById('searchInput');
        const focused = (document.activeElement === inp);
        if (focused) {
            // explicit action: search and close
            hideSuggestions();
            doSearch(null, false);
            // blur to close keyboard
            try { inp && inp.blur(); } catch (e) {}
        } else {
            // revert input to preOverlayState and close overlay without searching
            if (preOverlayState && typeof preOverlayState.q !== 'undefined') {
                const inp2 = document.getElementById('searchInput');
                if (inp2) inp2.value = preOverlayState.q || '';
                selectedType = preOverlayState.type || 'all';
                selectedCategory = preOverlayState.category || 'all';
            }
            // close overlay but ensure history is cleaned
            closeSearchOverlay();
        }
    };

    // close overlay on ESC
    document.addEventListener('keydown', overlayEscHandler);

    overlayOpen = true;

    // Push transient history state so Back button (hardware/browser) can close overlay
    try {
        history.pushState({ __overlay: true }, '');
        overlayHistoryPushed = true;
    } catch (e) {
        overlayHistoryPushed = false;
    }

    // --- Automatic search on overlay open: ONLY if there's actual input text ---
    const q = input ? (input.value || '').trim() : '';
    if (q) {
        // decide whether we should push history for the search (only when different from lastCommittedState)
        const candidateState = { q: q, type: selectedType || 'all', category: selectedCategory || 'all' };
        const shouldPush = !isStateEqual(candidateState, lastCommittedState);
        // Run search automatically but KEEP overlay open (we pass { keepOverlay: true })
        setTimeout(() => {
            doSearch(null, !shouldPush, { keepOverlay: true });
        }, 40);
    } else {
        // no input -> do not auto-run search (prevents immediate close)
    }
}

function overlayEscHandler(e) {
    if (e.key === 'Escape') {
        // revert to preOverlayState when closing via ESC (do not search)
        if (preOverlayState) {
            const inp = document.getElementById('searchInput');
            if (inp) inp.value = preOverlayState.q || '';
            selectedType = preOverlayState.type || 'all';
            selectedCategory = preOverlayState.category || 'all';
        }
        closeSearchOverlay();
    }
}

function closeSearchOverlay() {
    if (!overlayOpen) return;
    const wrapper = document.querySelector('.search-input-wrapper');
    if (!wrapper) return;

    // move wrapper back to original location first to avoid focus issues
    wrapper.classList.remove('overlay-elevated');
    wrapper.style.width = '';
    wrapper.style.maxWidth = '';
    wrapper.style.marginTop = '';
    if (originalInputParent) {
        if (originalInputNextSibling) originalInputParent.insertBefore(wrapper, originalInputNextSibling);
        else originalInputParent.appendChild(wrapper);
    }

    // remove suggestions container
    const sc = document.getElementById(suggestionContainerId);
    if (sc && sc.parentNode) sc.parentNode.removeChild(sc);

    // remove overlay and backdrop
    const overlay = document.getElementById(overlayContainerId);
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
    const backdrop = document.getElementById(overlayBackdropId);
    if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);

    document.documentElement.style.overflow = '';
    document.body.style.overflow = '';

    document.removeEventListener('keydown', overlayEscHandler);

    overlayOpen = false;

    // Clean up transient history entry if we pushed one
    if (overlayHistoryPushed) {
        // go back one step to remove the overlay state we pushed.
        // Suppress the next popstate because we're programmatically navigating.
        suppressNextPopstate = true;
        try { history.back(); } catch (e) { /* ignore */ }
        overlayHistoryPushed = false;
    }
}

// Suggestions caches
function prepareSuggestionCaches(apiData) {
    emojiSuggestionsCache = []; symbolSuggestionsCache = [];
    if (!apiData || !Array.isArray(apiData.type)) return;
    const langs = getAllAvailableLangs(apiData);
    for (let i = 0, T = apiData.type.length; i < T; ++i) {
        const typeObj = apiData.type[i], typeEn = (pickLang(typeObj.name, ["en"]) || '').toLowerCase();
        const categories = typeObj.category || [];
        for (let j = 0, C = categories.length; j < C; ++j) {
            const cat = categories[j], items = cat.data || [];
            for (let x = 0, N = items.length; x < N; ++x) {
                const item = items[x];
                if (typeEn === "emoji") emojiSuggestionsCache.push({ text: item.text, api: item.api, category: cat, typeObj });
                else if (typeEn === "symbol") symbolSuggestionsCache.push({ text: item.text, api: item.api, category: cat, typeObj });
            }
        }
    }
}

function closeMobileKeyboard() {
    const input = document.getElementById('searchInput');
    if (input && document.activeElement === input) input.blur();
}

// doSearch now accepts preventPush parameter and options{keepOverlay}
function doSearch(e, preventPush, options) {
    if (e) e.preventDefault();
    options = options || {};
    const qEl = document.getElementById('searchInput');
    const q = qEl ? qEl.value : '';
    selectedType = document.getElementById('typeFilter') ? document.getElementById('typeFilter').value : selectedType;
    selectedCategory = 'all';
    hideSuggestions();

    if (!q.trim()) {
        setBodyMarginForSearch(false);
        const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
        const sr = document.getElementById('searchResults');
        if (sr) sr.innerHTML = placeholderHtml;
        setupCategoryFilter([], 'all');
        filterCategories = [];
        updateUILanguage();
        const stateCleared = { q: '', type: 'all', category: 'all' };
        if (!preventPush && !suppressHistoryPush && !isStateEqual(stateCleared, lastCommittedState)) {
            try { history.pushState(stateCleared, '', '/'); } catch (e) { history.replaceState(stateCleared, '', '/'); }
            lastCommittedState = stateCleared;
            try {
                const raw = sessionStorage.getItem(SEARCH_HISTORY_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                arr.push(Object.assign({}, stateCleared, { ts: Date.now() }));
                sessionStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(arr));
            } catch (e) {}
        }
        // If overlay was open and this was an explicit search close it unless options.keepOverlay
        if (overlayOpen && !options.keepOverlay) closeSearchOverlay();
        return;
    }

    currentResults = smartSearch(apiData, q, selectedType, allKeywordsCache);
    filterCategories = extractResultCategories(currentResults);
    setupCategoryFilter(filterCategories, 'all');

    const stateObj = { q: q, type: selectedType || 'all', category: 'all' };
    const willPush = (!preventPush && !suppressHistoryPush && !isStateEqual(stateObj, lastCommittedState));
    if (willPush) {
        pushSearchStateToHistory(stateObj);
    }

    renderResults(currentResults, currentResults.length === 0);
    updateUILanguage();

    // Close overlay only for explicit searches (not for auto-run when opening)
    if (overlayOpen && !options.keepOverlay) closeSearchOverlay();
}

function onTypeChange() { selectedType = document.getElementById('typeFilter').value; doSearch(); }
function onCategoryChange() { selectedCategory = document.getElementById('categoryFilter').value; renderResults(currentResults, false); updateUILanguage(); }

function setupMobileSelectEnter() {
    ['typeFilter', 'categoryFilter'].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.onchange = () => (id === 'typeFilter' ? onTypeChange() : onCategoryChange());
        el.onkeyup = function(e) { if (e.key === 'Enter') (id === 'typeFilter' ? onTypeChange() : onCategoryChange()); };
    });
}
function setupAutoSearchInput() {
    const input = document.getElementById('searchInput');
    if (!input) return;
    input.setAttribute('enterkeyhint', 'search');
    input.oninput = function() { clearTimeout(debounceTimeout); debounceTimeout = setTimeout(() => {
        renderQuerySuggestions(this.value);
    }, 120); };
    input.onkeydown = function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            hideSuggestions();
            // explicit Enter -> search and close overlay
            doSearch();
            closeMobileKeyboard();
        } else if (e.key === 'ArrowDown') {
            const container = document.getElementById(suggestionContainerId);
            if (container) {
                const first = container.querySelector('.suggestion-item');
                if (first) first.focus && first.focus();
            }
        }
    };
    input.addEventListener('blur', function() { setTimeout(hideSuggestions, 200); });
    input.addEventListener('focus', function() { openSearchOverlay(); });
    input.addEventListener('click', function() { openSearchOverlay(); });
}

function updateUILanguage() {
    const input = document.getElementById('searchInput');
    if (input && input.placeholder !== t('search_placeholder')) input.placeholder = t('search_placeholder');
    const filterGroupLabels = document.querySelectorAll('.search-filters-panel .filter-group-label');
    if (filterGroupLabels.length > 0 && filterGroupLabels[0].textContent !== t('type')) filterGroupLabels[0].textContent = t('type');
    if (filterGroupLabels.length > 1 && filterGroupLabels[1].textContent !== t('category')) filterGroupLabels[1].textContent = t('category');
}

window.setUILanguage = function(lang) {
    localStorage.setItem('selectedLang', lang);
    updateUILanguage();
    setupTypeFilter(selectedType);
    setupCategoryFilter(filterCategories, selectedCategory);
    renderResults(currentResults, currentResults && currentResults.length === 0);
};

// popstate handler: handle normal restore and overlay-close behavior
window.addEventListener('popstate', function(e) {
    // If we suppressed the next popstate (because we programmatically called history.back()), ignore once
    if (suppressNextPopstate) { suppressNextPopstate = false; return; }

    const state = e.state || {};
    // If overlay is open and the popped state does NOT indicate overlay, then user pressed Back to close overlay.
    if (overlayOpen && !state.__overlay) {
        // revert input to preOverlayState and close overlay (no search)
        if (preOverlayState) {
            const inp = document.getElementById('searchInput');
            if (inp) inp.value = preOverlayState.q || '';
            selectedType = preOverlayState.type || 'all';
            selectedCategory = preOverlayState.category || 'all';
        }
        // close overlay without creating history entries (closeSearchOverlay will call history.back to remove overlay entry,
        // but since we're already handling popstate triggered by Back, avoid messing with history again)
        // So we directly remove DOM and flags (a lightweight close)
        const wrapper = document.querySelector('.search-input-wrapper');
        if (wrapper && originalInputParent) {
            wrapper.classList.remove('overlay-elevated');
            wrapper.style.width = '';
            wrapper.style.maxWidth = '';
            wrapper.style.marginTop = '';
            if (originalInputNextSibling) originalInputParent.insertBefore(wrapper, originalInputNextSibling);
            else originalInputParent.appendChild(wrapper);
        }
        const sc = document.getElementById(suggestionContainerId);
        if (sc && sc.parentNode) sc.parentNode.removeChild(sc);
        const overlay = document.getElementById(overlayContainerId);
        if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
        const backdrop = document.getElementById(overlayBackdropId);
        if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);
        document.documentElement.style.overflow = '';
        document.body.style.overflow = '';
        document.removeEventListener('keydown', overlayEscHandler);
        overlayOpen = false;
        overlayHistoryPushed = false;
        preOverlayState = null;
        return;
    }

    // Otherwise behave as normal: restore search state from history
    const st = (e.state && typeof e.state === 'object') ? e.state : readStateFromURL();
    if (st && st.q !== undefined) {
        restoreUIState({ q: st.q || '', type: st.type || 'all', category: st.category || 'all' });
    }
});

// Click outside suggestion container hides it (keeps current behavior)
document.addEventListener('click', function(ev) {
    const container = document.getElementById(suggestionContainerId);
    const input = document.getElementById('searchInput');
    if (!container) return;
    if (ev.target === input || container.contains(ev.target)) return;
    hideSuggestions();
});

// initial load
fetch('/assets/json/api-database.min.json')
    .then(res => res.json())
    .then(data => {
        apiData = data;
        allKeywordsCache = generateAllKeywords(apiData);
        prepareSuggestionCaches(apiData);
        setupTypeFilter('all');
        setupMobileSelectEnter();
        setupAutoSearchInput();
        setupCategoryFilter([], 'all');
        setBodyMarginForSearch(false);
        const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
        const sr = document.getElementById('searchResults');
        if (sr) sr.innerHTML = placeholderHtml;
        updateUILanguage();

        // Initialize lastCommittedState
        try {
            const hs = window.history && window.history.state;
            if (hs && typeof hs === 'object' && (hs.q !== undefined)) {
                lastCommittedState = { q: hs.q || '', type: hs.type || 'all', category: hs.category || 'all' };
            } else {
                const raw = sessionStorage.getItem(SEARCH_HISTORY_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                if (arr && arr.length) {
                    const last = arr[arr.length - 1];
                    lastCommittedState = { q: last.q || '', type: last.type || 'all', category: last.category || 'all' };
                } else {
                    lastCommittedState = null;
                }
            }
        } catch (e) {
            lastCommittedState = null;
        }

        // After UI setup, check URL for search params and restore if present
        const initial = readStateFromURL();
        if (initial && initial.q) {
            suppressHistoryPush = true;
            try {
                const input = document.getElementById('searchInput');
                if (input) input.value = initial.q;
                selectedType = initial.type || 'all';
                selectedCategory = initial.category || 'all';
                setupTypeFilter(selectedType);
                doSearch(null, true);
                try { history.replaceState({ q: initial.q, type: selectedType, category: selectedCategory }, '', buildUrlForState(initial)); } catch (e) {}
                lastCommittedState = { q: initial.q || '', type: selectedType || 'all', category: selectedCategory || 'all' };
            } finally { suppressHistoryPush = false; }
        } else {
            try { history.replaceState({ q: '', type: 'all', category: 'all' }, '', window.location.pathname); } catch (e) {}
            lastCommittedState = { q: '', type: 'all', category: 'all' };
        }
    })
    .catch(err => {
        console.error('Failed to load api database', err);
    });

const formEl = document.getElementById('searchForm');
if (formEl) formEl.addEventListener('submit', e => { e.preventDefault(); doSearch(); closeMobileKeyboard(); });
const inputEl = document.getElementById('searchInput');
if (inputEl) inputEl.addEventListener('keydown', function(e){ if(e.key === 'Enter') { e.preventDefault(); doSearch(); closeMobileKeyboard(); } });