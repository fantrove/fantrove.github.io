/* search-engine.min.js
   Refactored: core search logic, normalization, keyword generation, fuzzy matching,
   suggestion generation and smartSearch. No DOM / history / overlay code here.
   Exposes global window.SearchEngine with init(), querySuggestions(), search(), generateAllKeywords().
*/
(function(){
  // ---------- Core helpers ----------
  function normalizeText(s) {
    if (!s && s !== 0) return '';
    s = String(s).toLowerCase().trim();
    try { s = s.normalize('NFKD').replace(/[\u0300-\u036f]/g, ''); } catch (e) {}
    s = s.replace(/[\u200B-\u200D\uFEFF]/g, '');
    s = s.replace(/[\u2018\u2019\u201A\u201B\u2032\u2035]/g, "'").replace(/[\u201C\u201D\u201E\u201F\u2033\u2036]/g, '"');
    s = s.replace(/[\uFF01-\uFF5E]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
    s = s.replace(/[^\p{L}\p{N}\s]+/gu, ' ');
    s = s.replace(/\s+/g, ' ').trim();
    return s;
  }
  function containsThai(s){ return /[\u0E00-\u0E7F]/.test(String(s||'')); }
  function containsLatin(s){ return /[A-Za-z]/.test(String(s||'')); }
  function isLikelyCode(s) {
    const str = String(s||'').trim();
    if (!str) return false;
    if (/^[A-Za-z0-9_\-\/\.\:\~\+\=\#]+$/.test(str) && str.length <= 80) return true;
    return false;
  }
  function scriptsCompatible(query,target){
    if (!query) return true;
    const qHasThai = containsThai(query);
    const qHasLatin = containsLatin(query);
    if (qHasThai) return containsThai(target);
    if (qHasLatin) return containsLatin(target);
    return true;
  }

  // ---------- levenshtein ----------
  function levenshtein(a,b){
    if (a===b) return 0;
    const al=a.length, bl=b.length;
    if (!al) return bl;
    if (!bl) return al;
    let v0 = new Uint16Array(bl+1), v1 = new Uint16Array(bl+1);
    for (let i=0;i<=bl;i++) v0[i]=i;
    for (let i=0;i<al;i++){
      v1[0]=i+1;
      for (let j=0;j<bl;j++) v1[j+1]=Math.min(v1[j]+1, v0[j+1]+1, v0[j] + (a[i]===b[j]?0:1));
      let t=v0; v0=v1; v1=t;
    }
    return v0[bl];
  }

  // ---------- i18n-lite helper used by engine for picking language objects (kept small) ----------
  function pickLang(obj, langs){
    if (!obj || typeof obj !== 'object') return obj;
    for (let i=0;i<langs.length;i++) if (obj[langs[i]]) return obj[langs[i]];
    for (const k in obj) return obj[k];
    return '';
  }

  // ---------- Keyword extraction (same logic as before) ----------
  function getAllAvailableLangs(data) {
    const langs = Object.create(null);
    if (!data || !Array.isArray(data.type)) return ['en'];
    for (let i=0;i<data.type.length;i++) {
      const typeObj = data.type[i];
      if (typeof typeObj.name === 'object') for (const k in typeObj.name) langs[k]=1;
      const categories = typeObj.category || [];
      for (let j=0;j<categories.length;j++) {
        const cat = categories[j];
        if (typeof cat.name === 'object') for (const k in cat.name) langs[k]=1;
        const items = cat.data || [];
        for (let x=0;x<items.length;x++) {
          const item = items[x];
          if (typeof item.name === 'object') for (const k in item.name) langs[k]=1;
          for (const k in item) if (/_name$/.test(k) && typeof item[k] === 'object') for (const l in item[k]) langs[l]=1;
        }
      }
    }
    return Object.keys(langs);
  }

  function generateAllKeywords(data) {
    const arr = [];
    const langs = getAllAvailableLangs(data);
    if (!data || !Array.isArray(data.type)) return [];
    for (let i=0;i<data.type.length;i++){
      const typeObj = data.type[i];
      for (let l=0;l<langs.length;l++){
        const lang = langs[l];
        const typeName = pickLang(typeObj.name, [lang]);
        if (typeName) arr.push({ typeObj, typeName, lang, key: normalizeText(typeName), isType: true });
      }
      const categories = typeObj.category || [];
      for (let j=0;j<categories.length;j++){
        const cat = categories[j];
        for (let l=0;l<langs.length;l++){
          const lang = langs[l];
          const catName = pickLang(cat.name, [lang]);
          if (catName) arr.push({ typeObj, category: cat, typeName: pickLang(typeObj.name, [lang]), catName, lang, key: normalizeText(catName), isCategory: true });
        }
        const items = cat.data || [];
        for (let x=0;x<items.length;x++){
          const item = items[x];
          for (let l=0;l<langs.length;l++){
            const lang = langs[l];
            const itemName = pickLang(item.name, [lang]);
            if (itemName) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, [lang]), catName: pickLang(cat.name,[lang]), itemName, lang, key: normalizeText(itemName) });
          }
          for (const k in item) {
            if (/_name$/.test(k) && typeof item[k] === 'object') {
              for (let l=0;l<langs.length;l++) {
                const lang = langs[l];
                const vVal = pickLang(item[k],[lang]);
                if (vVal) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name,[lang]), catName: pickLang(cat.name,[lang]), itemName: vVal, lang, key: normalizeText(vVal) });
              }
            }
          }
          if (item.api) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'api', key: normalizeText(item.api || '') });
        }
      }
    }
    return arr;
  }

  // ---------- fuzzy keyword matching used for suggestions ----------
  const computeRelevanceScore = (query,target,baseScore=100) => (!target ? baseScore : (() => {
    let s = levenshtein(query, target);
    if (target.startsWith(query)) s -= 2;
    if (target.includes(query)) s -= 1;
    return s;
  })());

  const keywordExactSubstringMatch = (query, allKeywords) => {
    query = normalizeText(query);
    for (let i=0;i<allKeywords.length;i++) if ((allKeywords[i].key||'').includes(query)) return true;
    return false;
  };

  function getBestKeywordMatches(query, allKeywords, maxCount=12, allowGuess=true) {
    if (!query) return [];
    const nq = normalizeText(query);
    if (!allowGuess && keywordExactSubstringMatch(nq, allKeywords)) return [];
    let out = [];
    for (let i=0;i<allKeywords.length;i++){
      const k = allKeywords[i];
      let s = [computeRelevanceScore(nq, k.key||'', 100)];
      if (k.isCategory && k.catName) s.push(computeRelevanceScore(nq, normalizeText(k.catName), 110));
      if (k.typeName) s.push(computeRelevanceScore(nq, normalizeText(k.typeName), 110));
      if (k.itemName) s.push(computeRelevanceScore(nq, normalizeText(k.itemName), 120));
      if (k.item) {
        if (k.item.api) s.push(computeRelevanceScore(nq, normalizeText(k.item.api), 125));
      }
      k._score = Math.min.apply(null, s);
      out.push(k);
    }
    out.sort((a,b) => a._score - b._score);
    let seen = new Set(), uniq=[], cnt=0;
    for (let i=0;i<out.length && cnt<maxCount;i++){
      const k = out[i];
      if (k._score > 4) break;
      const uniqKey = k.isType ? `type|${k.typeName}|${k.lang}` : k.isCategory ? `cat|${k.typeName}|${k.catName}|${k.lang}` : `item|${k.typeName}|${k.catName}|${k.item && (k.item.api||'')}`;
      if (!seen.has(uniqKey)) { seen.add(uniqKey); uniq.push(Object.assign({}, k, { fuzzyScore: k._score })); ++cnt; }
    }
    return uniq;
  }

  // ---------- smartSearch: returns array of result objects similar to original ----------
  function smartSearch(data, query, typeFilter, allKeywords) {
    const qRaw = String(query || '').trim();
    const q = normalizeText(qRaw);
    if (!q) return [];
    let results = [];
    const langs = getAllAvailableLangs(data);
    if (!data || !Array.isArray(data.type)) return results;
    for (let i=0;i<data.type.length;i++){
      const typeObj = data.type[i];
      for (let l=0;l<langs.length;l++){
        const lang = langs[l];
        const typeLabel = pickLang(typeObj.name, [lang]);
        if (typeFilter !== 'all' && pickLang(typeObj.name,['en']) !== typeFilter && pickLang(typeObj.name,[lang]) !== typeFilter) {
          // allow filter compare against default language labels, but be permissive
          if (typeFilter !== 'all') continue;
        }
        const cats = typeObj.category || [];
        for (let j=0;j<cats.length;j++){
          const cat = cats[j];
          const catName = pickLang(cat.name, [lang]);
          const items = cat.data || [];
          for (let x=0;x<items.length;x++){
            const item = items[x];
            const tokens = [];
            if (item.name) tokens.push(normalizeText(pickLang(item.name, [lang])));
            for (const k in item) if (/_name$/.test(k) && item[k]) tokens.push(normalizeText(pickLang(item[k],[lang])));
            if (catName) tokens.push(normalizeText(catName));
            if (item.text) tokens.push(normalizeText(item.text));
            if (item.api) tokens.push(normalizeText(item.api));
            const flat = Array.from(new Set(tokens.filter(Boolean)));
            let isMatch = false;
            let bestFuzz = Infinity;
            for (let f=0; f<flat.length; f++){
              const txt = flat[f];
              if (!txt) continue;
              if (!scriptsCompatible(qRaw, txt)) continue;
              if (txt === q) { isMatch = true; bestFuzz = 0; break; }
              if (txt.startsWith(q)) { isMatch = true; bestFuzz = Math.min(bestFuzz, 1); }
              if (txt.includes(q)) { isMatch = true; bestFuzz = Math.min(bestFuzz, 2); }
              bestFuzz = Math.min(bestFuzz, levenshtein(q, txt));
            }
            const maxFuzzAllowed = Math.max(1, Math.min(2, Math.floor(q.length * 0.18)));
            const isFuzzy = !isMatch && bestFuzz <= maxFuzzAllowed;
            if (isMatch || isFuzzy) {
              const itemName = pickLang(item.name || {}, [lang]) || '';
              results.push({
                typeObj, category: cat, item,
                typeName: typeLabel, catName: catName, itemName: itemName,
                lang, fuzzy: !isMatch && isFuzzy, fuzzyScore: bestFuzz, matchExact: bestFuzz === 0
              });
            }
          }
        }
      }
    }
    if (keywordExactSubstringMatch(q, allKeywords)) {
      const sub = results.filter(r => !r.fuzzy);
      if (sub.length) results = sub;
    }
    results.forEach(r => {
      let score = 10 + (r.fuzzyScore || 0);
      const normItemName = normalizeText(r.itemName || '');
      const normApi = normalizeText(r.item && r.item.api || '');
      const normCat = normalizeText(r.catName || '');
      const normType = normalizeText(r.typeName || '');
      if (normItemName === q || normApi === q || normCat === q || normType === q) score = 0;
      else if ((normItemName && normItemName.startsWith(q)) || (normApi && normApi.startsWith(q)) || (normCat && normCat.startsWith(q)) || (normType && normType.startsWith(q))) score = 1;
      else if ((normItemName && normItemName.includes(q)) || (normApi && normApi.includes(q)) || (normCat && normCat.includes(q)) || (normType && normType.includes(q))) score = 2;
      else if (r.fuzzy) score = 3 + (r.fuzzyScore || 0);
      r._score = score;
    });
    results.sort((a,b) => a._score - b._score);
    return results;
  }

  // ---------- suggestion generation (returns display/raw/highlightedHtml/source similar to previous) ----------
  function highlightMatchesHtml(text, query) {
    if (!text) return '';
    if (!query) return escapeHtml(text);
    const normQuery = normalizeText(query);
    try {
      const normText = normalizeText(text);
      let startIdx = normText.indexOf(normQuery);
      if (startIdx !== -1) {
        let out = '';
        let qi = 0;
        for (let i=0;i<text.length;i++) {
          const ch = text[i];
          const nch = normalizeText(ch);
          if (nch && nch.length && qi < normQuery.length && normQuery.indexOf(nch) !== -1 && normalizeText(text.substr(i,1)) === nch && normQuery[qi] === nch) {
            out += '<strong>' + escapeHtml(ch) + '</strong>';
            qi++;
          } else {
            out += escapeHtml(ch);
          }
        }
        return out;
      }
    } catch (e) {}
    let out = '';
    for (let i=0;i<text.length;i++) {
      const ch = text[i];
      const nch = normalizeText(ch);
      if (nch && nch.length) {
        let matched = false;
        for (let j=0;j<nch.length;j++) {
          if (nch[j] && normQuery.indexOf(nch[j]) !== -1) { matched = true; break; }
        }
        if (matched) out += '<strong>' + escapeHtml(ch) + '</strong>';
        else out += escapeHtml(ch);
      } else {
        out += escapeHtml(ch);
      }
    }
    return out;
  }
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // ---------- SearchEngine public API ----------
  const SearchEngine = (function(){
    let _data = null;
    let _keywords = [];
    return {
      init: function(data){
        _data = data;
        _keywords = generateAllKeywords(data || {});
      },
      generateAllKeywords: function(){ return _keywords.slice(); },
      querySuggestions: function(rawQuery, maxCount){
        maxCount = maxCount || 8;
        const qn = normalizeText(String(rawQuery||''));
        if (!qn) return [];
        const matches = getBestKeywordMatches(qn, _keywords, Math.max(12, maxCount), true);
        if (!matches || !matches.length) return [];
        const seen = new Set();
        const out = [];
        const queryHasThai = containsThai(rawQuery);
        for (let i=0;i<matches.length && out.length < maxCount;i++){
          const s = matches[i];
          const candidates = [];
          // build candidate strings (prefer item name, api, category, type)
          if (s.item) {
            const it = s.item;
            const itemName = it.name ? pickLang(it.name, ['en']) : (s.itemName||'');
            if (itemName) candidates.push({ raw: itemName, source: 'item' });
            if (it.api) candidates.push({ raw: it.api, source: 'api' });
            if (s.catName) candidates.push({ raw: s.catName, source: 'category' });
            if (s.typeName) candidates.push({ raw: s.typeName, source: 'type' });
          } else if (s.isCategory && s.category) {
            const catName = pickLang(s.category.name||{}, ['en']) || s.catName || '';
            if (catName) candidates.push({ raw: catName, source: 'category' });
            const items = s.category.data || [];
            for (let k=0;k<items.length;k++){
              const it = items[k];
              const itName = it && it.name ? pickLang(it.name, ['en']) : (it && it.api ? it.api : '');
              if (itName) candidates.push({ raw: itName, source: 'item' });
            }
            if (s.typeName) candidates.push({ raw: s.typeName, source: 'type' });
          } else if (s.isType && s.typeObj) {
            const typeName = pickLang(s.typeObj.name||{}, ['en']) || s.typeName || '';
            if (typeName) candidates.push({ raw: typeName, source: 'type' });
            const cats = s.typeObj.category || [];
            for (let c=0;c<cats.length;c++){
              const cat = cats[c];
              const catName = pickLang(cat.name||{}, ['en']) || '';
              if (catName) candidates.push({ raw: catName, source: 'category' });
            }
          } else {
            if (s.itemName) candidates.push({ raw: s.itemName, source: 'item' });
            else if (s.key) candidates.push({ raw: s.key, source: 'keyword' });
          }

          for (let cidx=0;cidx<candidates.length && out.length < maxCount;cidx++){
            const cand = candidates[cidx];
            if (!cand || !cand.raw) continue;
            const raw = String(cand.raw).trim();
            const norm = normalizeText(raw);
            if (!norm) continue;
            if (!scriptsCompatible(rawQuery, raw)) continue;
            if (norm.indexOf(qn) === -1) {
              const dist = levenshtein(qn, norm);
              if (!(qn.length <= 3 && dist <= 1)) continue;
            }
            if (queryHasThai && isLikelyCode(raw)) continue;
            if (seen.has(norm)) continue;
            seen.add(norm);
            out.push({ display: raw, raw: raw, highlightedHtml: highlightMatchesHtml(raw, rawQuery), source: cand.source });
          }
        }
        return out;
      },
      search: function(q, typeFilter){
        const keywords = _keywords;
        const results = smartSearch(_data, q, typeFilter||'all', keywords);
        return { results: results, keywords: keywords };
      },
      // expose some internals for debugging if needed
      _internals: { normalizeText, levenshtein }
    };
  })();

  // export globally
  window.SearchEngine = SearchEngine;
})();