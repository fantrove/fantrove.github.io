// assets/js/search-engine.min.js
// Full search engine with centralized SearchManager, DB-based suggestions, highlight,
// improved history sync and backdrop behavior, and restored result rendering + copy buttons.
// Keep this file in sync with search/index.html and assets/css/search.min.css

(() => {
  // ---------- Core state ----------
  let apiData = null;
  let currentResults = [];
  let filterCategories = [];
  let selectedType = 'all';
  let selectedCategory = 'all';
  let debounceTimeout = null;
  let allKeywordsCache = [];
  const suggestionMax = 8;

  // incremental render
  let renderObserver = null;
  let renderBatchSize = 12;
  let currentRenderIndex = 0;
  let currentFilteredResults = [];
  const sentinelId = 'search-render-sentinel';

  // history / url
  const SEARCH_HISTORY_KEY = 'searchHistory_v1';
  let suppressHistoryPush = false; // when restoring UI from history
  let lastCommittedState = null;   // last "real" search state that was recorded
  // overlay / suggestion state
  const suggestionContainerId = 'searchSuggestions';
  const suggestionBackdropId = 'searchSuggestionBackdrop';
  const overlayBackdropId = 'searchOverlayBackdrop';
  const overlayContainerId = 'searchOverlayContainer';
  let originalInputParent = null;
  let originalInputNextSibling = null;
  let overlayOpen = false;
  let preOverlayState = null; // state at moment overlay opened
  let overlayHistoryPushed = false; // transient overlay history entry pushed?

  // avoid races between pointerdown/backdrop and blur/hideSuggestions
  let ignoreNextHideSuggestions = false;

  // ---------- Text normalization (improves matching) ----------
  function normalizeText(s) {
    if (!s && s !== 0) return '';
    s = String(s).toLowerCase().trim();
    try { s = s.normalize('NFKD').replace(/[\u0300-\u036f]/g, ''); } catch (e) {}
    s = s.replace(/[\u200B-\u200D\uFEFF]/g, '');
    s = s.replace(/[\u2018\u2019\u201A\u201B\u2032\u2035]/g, "'").replace(/[\u201C\u201D\u201E\u201F\u2033\u2036]/g, '"');
    s = s.replace(/[\uFF01-\uFF5E]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
    s = s.replace(/[^\p{L}\p{N}\s]+/gu, ' ');
    s = s.replace(/\s+/g, ' ').trim();
    return s;
  }

  // ---------- Script / type detection helpers (improve precision) ----------
  // Detect Thai characters
  function containsThai(s) { return /[\u0E00-\u0E7F]/.test(String(s || '')); }
  // Detect Latin letters
  function containsLatin(s) { return /[A-Za-z]/.test(String(s || '')); }
  // Detect presence of letters at all (unicode-aware)
  function containsLetters(s) { try { return /[\p{L}]/u.test(String(s || '')); } catch(e){ return /[A-Za-z]/.test(String(s||'')); } }
  // Likely code/API string detector (simple heuristic)
  function isLikelyCode(s) { 
    const str = String(s||'').trim();
    if (!str) return false;
    // common API/code characters (no spaces, mostly ascii symbols)
    if (/^[A-Za-z0-9_\-\/\.\:\~\+\=\#]+$/.test(str) && str.length <= 80) return true;
    return false;
  }
  // Require script compatibility: if query has Thai, prefer candidates containing Thai; if query has Latin, prefer Latin matches.
  function scriptsCompatible(query, target) {
    if (!query) return true;
    const qHasThai = containsThai(query);
    const qHasLatin = containsLatin(query);
    if (qHasThai) return containsThai(target);
    if (qHasLatin) return containsLatin(target);
    // otherwise be permissive
    return true;
  }

  // ---------- localization ----------
  const LANG_TEXTS = {
    th: { all_types: "ทุกประเภท", all_categories: "ทุกหมวดหมู่", not_found: "ไม่พบข้อมูลที่ตรงหรือใกล้เคียง", copy: "คัดลอก", suggestions_for_you: "คำแนะนำสำหรับคุณ", emoji: "อิโมจิ", suggestion_label: "คำแนะนำ", search_placeholder: "ค้นหาข้อมูล...", search_result_here: "พิมพ์คำค้นเพื่อเริ่มค้นหา", type: "ประเภท", category: "หมวดหมู่", copy_failed: "ไม่สามารถคัดลอกได้" },
    en: { all_types: "All Types", all_categories: "All Categories", not_found: "No data found related to your keyword.", copy: "Copy", suggestions_for_you: "Suggestions For You", emoji: "Emoji", suggestion_label: "Suggestions", search_placeholder: "Search...", search_result_here: "Type to search", type: "Type", category: "Category", copy_failed: "Unable to copy" }
  };
  const getLang = () => localStorage.getItem('selectedLang') || (navigator.language && navigator.language.startsWith('th') ? 'th' : 'en');
  const t = k => { const l = getLang(); return (LANG_TEXTS[l] && LANG_TEXTS[l][k]) || LANG_TEXTS.en[k] || k; };
  const pickLang = (obj, langs) => { if (!obj || typeof obj !== 'object') return obj; for (let i=0;i<langs.length;i++) if (obj[langs[i]]) return obj[langs[i]]; for (const k in obj) return obj[k]; return ''; };

  // ---------- Utilities ----------
  function isStateEqual(a,b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    const aq = (a.q||'').trim();
    const bq = (b.q||'').trim();
    const at = (a.type||'all');
    const bt = (b.type||'all');
    const ac = (a.category||'all');
    const bc = (b.category||'all');
    return aq===bq && at===bt && ac===bc;
  }

  function parseQueryString(qs) {
    const out = {};
    if (!qs) return out;
    qs = qs.replace(/^\?/, '');
    const parts = qs.split('&');
    for (let i=0;i<parts.length;i++) {
      const p = parts[i]; if (!p) continue;
      const idx = p.indexOf('=');
      if (idx === -1) { out[decodeURIComponent(p)] = ''; }
      else { out[decodeURIComponent(p.substring(0,idx))] = decodeURIComponent(p.substring(idx+1)); }
    }
    return out;
  }
  function buildQueryString(obj) {
    const parts = [];
    for (const k in obj) {
      if (obj[k] === undefined || obj[k] === null) continue;
      parts.push(encodeURIComponent(k)+'='+encodeURIComponent(obj[k]));
    }
    return parts.length ? ('?'+parts.join('&')) : '';
  }
  function readStateFromURL() {
    const params = parseQueryString(window.location.search || '');
    return { q: params.q || '', type: params.type || 'all', category: params.category || 'all' };
  }
  function buildUrlForState(state) {
    const params = {};
    if (state.q) params.q = state.q;
    if (state.type && state.type !== 'all') params.type = state.type;
    if (state.category && state.category !== 'all') params.category = state.category;
    return buildQueryString(params);
  }

  // ---------- History commit improvements ----------
  function commitSearchState(state) {
    try {
      if (isStateEqual(state, lastCommittedState)) return;
    } catch (e) {}
    const url = buildUrlForState(state);
    try {
      if (overlayHistoryPushed) {
        history.replaceState(state, '', url);
        overlayHistoryPushed = false;
      } else {
        history.pushState(state, '', url);
      }
    } catch (e) {
      try { history.replaceState(state, '', url); } catch (ee) {}
      overlayHistoryPushed = false;
    }
    try {
      const raw = sessionStorage.getItem(SEARCH_HISTORY_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      arr.push(Object.assign({}, state, { ts: Date.now() }));
      sessionStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(arr));
    } catch (e) {}
    lastCommittedState = { q: state.q || '', type: state.type || 'all', category: state.category || 'all' };
  }

  function removeTransientOverlayEntry() {
    if (!overlayHistoryPushed) return;
    try {
      const stateToRestore = lastCommittedState || { q: '', type: 'all', category: 'all' };
      history.replaceState(stateToRestore, '', buildUrlForState(stateToRestore));
    } catch (e) {}
    overlayHistoryPushed = false;
  }

  // ---------- search helpers (matching, fuzzy) ----------
  function getAllAvailableLangs(data) {
    const langs = Object.create(null);
    if (!data || !Array.isArray(data.type)) return ['en'];
    for (let i=0;i<data.type.length;i++) {
      const typeObj = data.type[i];
      if (typeof typeObj.name === 'object') for (const k in typeObj.name) langs[k]=1;
      const categories = typeObj.category || [];
      for (let j=0;j<categories.length;j++) {
        const cat = categories[j];
        if (typeof cat.name === 'object') for (const k in cat.name) langs[k]=1;
        const items = cat.data || [];
        for (let x=0;x<items.length;x++) {
          const item = items[x];
          if (typeof item.name === 'object') for (const k in item.name) langs[k]=1;
          for (const k in item) if (/_name$/.test(k) && typeof item[k] === 'object') for (const l in item[k]) langs[l]=1;
        }
      }
    }
    return Object.keys(langs);
  }

  function generateAllKeywords(data) {
    const arr = [];
    const langs = getAllAvailableLangs(data);
    if (!data || !Array.isArray(data.type)) return [];
    for (let i=0;i<data.type.length;i++) {
      const typeObj = data.type[i];
      for (let l=0;l<langs.length;l++) {
        const lang = langs[l];
        const typeName = pickLang(typeObj.name, [lang]);
        if (typeName) arr.push({ typeObj, typeName, lang, key: normalizeText(typeName), isType: true });
      }
      const categories = typeObj.category || [];
      for (let j=0;j<categories.length;j++) {
        const cat = categories[j];
        for (let l=0;l<langs.length;l++) {
          const lang = langs[l];
          const catName = pickLang(cat.name, [lang]);
          if (catName) arr.push({ typeObj, category: cat, typeName: pickLang(typeObj.name, [lang]), catName, lang, key: normalizeText(catName), isCategory: true });
        }
        const items = cat.data || [];
        for (let x=0;x<items.length;x++) {
          const item = items[x];
          for (let l=0;l<langs.length;l++) {
            const lang = langs[l];
            const itemName = pickLang(item.name, [lang]);
            if (itemName) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, [lang]), catName: pickLang(cat.name,[lang]), itemName, lang, key: normalizeText(itemName) });
          }
          for (const k in item) {
            if (/_name$/.test(k) && typeof item[k] === 'object') {
              for (let l=0;l<langs.length;l++) {
                const lang = langs[l];
                const vVal = pickLang(item[k],[lang]);
                if (vVal) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name,[lang]), catName: pickLang(cat.name,[lang]), itemName: vVal, lang, key: normalizeText(vVal) });
              }
            }
          }
          if (item.api) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'api', key: normalizeText(item.api || '') });
        }
      }
    }
    return arr;
  }

  function levenshtein(a,b) {
    if (a===b) return 0;
    const al=a.length, bl=b.length;
    if (!al) return bl;
    if (!bl) return al;
    let v0 = new Uint16Array(bl+1), v1 = new Uint16Array(bl+1);
    for (let i=0;i<=bl;i++) v0[i]=i;
    for (let i=0;i<al;i++){
      v1[0]=i+1;
      for (let j=0;j<bl;j++) v1[j+1]=Math.min(v1[j]+1, v0[j+1]+1, v0[j] + (a[i]===b[j]?0:1));
      let t=v0; v0=v1; v1=t;
    }
    return v0[bl];
  }

  const computeRelevanceScore = (query,target,baseScore=100) => (!target ? baseScore : (() => {
    let s = levenshtein(query, target);
    if (target.startsWith(query)) s -= 2;
    if (target.includes(query)) s -= 1;
    return s;
  })());

  const keywordExactSubstringMatch = (query, allKeywords) => {
    query = normalizeText(query);
    for (let i=0;i<allKeywords.length;i++) if ((allKeywords[i].key||'').includes(query)) return true;
    return false;
  };

  function getBestKeywordMatches(query, allKeywords, maxCount=12, allowGuess=true) {
    if (!query) return [];
    const nq = normalizeText(query);
    if (!allowGuess && keywordExactSubstringMatch(nq, allKeywords)) return [];
    let out = [];
    for (let i=0;i<allKeywords.length;i++){
      const k = allKeywords[i];
      let s = [computeRelevanceScore(nq, k.key||'', 100)];
      if (k.isCategory && k.catName) s.push(computeRelevanceScore(nq, normalizeText(k.catName), 110));
      if (k.typeName) s.push(computeRelevanceScore(nq, normalizeText(k.typeName), 110));
      if (k.itemName) s.push(computeRelevanceScore(nq, normalizeText(k.itemName), 120));
      if (k.item) {
        if (k.item.api) s.push(computeRelevanceScore(nq, normalizeText(k.item.api), 125));
      }
      k._score = Math.min.apply(null, s);
      out.push(k);
    }
    out.sort((a,b) => a._score - b._score);
    let seen = new Set(), uniq=[], cnt=0;
    // tighten threshold for suggestion fuzzy inclusion (improves precision)
    for (let i=0;i<out.length && cnt<maxCount;i++){
      const k = out[i];
      if (k._score > 4) break; // stricter than before to reduce unrelated suggestions
      const uniqKey = k.isType ? `type|${k.typeName}|${k.lang}` : k.isCategory ? `cat|${k.typeName}|${k.catName}|${k.lang}` : `item|${k.typeName}|${k.catName}|${k.item && (k.item.api||'')}`;
      if (!seen.has(uniqKey)) { seen.add(uniqKey); uniq.push(Object.assign({}, k, { fuzzyScore: k._score })); ++cnt; }
    }
    return uniq;
  }

  // ---------- Accurate Search (smartSearch) ----------
  // returns results with _score property (lower = better)
  function smartSearch(data, query, typeFilter, allKeywords) {
    const qRaw = String(query || '').trim();
    const q = normalizeText(qRaw);
    if (!q) return [];
    let results = [];
    const langs = getAllAvailableLangs(data);
    if (!data || !Array.isArray(data.type)) return results;

    for (let i=0;i<data.type.length;i++){
      const typeObj = data.type[i];
      for (let l=0;l<langs.length;l++){
        const lang = langs[l];
        const typeLabel = pickLang(typeObj.name, [lang]);
        if (typeFilter !== 'all' && pickLang(typeObj.name,[getLang()]) !== typeFilter) continue;
        const cats = typeObj.category || [];
        for (let j=0;j<cats.length;j++){
          const cat = cats[j];
          const catName = pickLang(cat.name, [lang]);
          const items = cat.data || [];
          for (let x=0;x<items.length;x++){
            const item = items[x];
            const tokens = [];
            // candidate fields for matching (names, api, text, category, type)
            if (item.name) tokens.push(normalizeText(pickLang(item.name, [lang])));
            for (const k in item) if (/_name$/.test(k) && item[k]) tokens.push(normalizeText(pickLang(item[k],[lang])));
            if (catName) tokens.push(normalizeText(catName));
            if (item.text) tokens.push(normalizeText(item.text));
            if (item.api) tokens.push(normalizeText(item.api));
            const flat = Array.from(new Set(tokens.filter(Boolean)));
            let isMatch = false;
            let bestFuzz = Infinity;
            let bestField = '';
            for (let f=0; f<flat.length; f++){
              const txt = flat[f];
              if (!txt) continue;
              // require script compatibility (avoid mixing Thai query with English-only field)
              if (!scriptsCompatible(qRaw, txt)) continue;
              if (txt === q) {
                isMatch = true; bestFuzz = 0; bestField = txt; break;
              }
              if (txt.startsWith(q)) { isMatch = true; bestFuzz = Math.min(bestFuzz, 1); bestField = txt; }
              if (txt.includes(q)) { isMatch = true; bestFuzz = Math.min(bestFuzz, 2); if (!bestField) bestField = txt; }
              bestFuzz = Math.min(bestFuzz, levenshtein(q, txt));
            }
            // tighten fuzzy acceptance: allow fuzzy only when small distance and scripts compatible
            const maxFuzzAllowed = Math.max(1, Math.min(2, Math.floor(q.length * 0.18)));
            const isFuzzy = !isMatch && bestFuzz <= maxFuzzAllowed;
            if (isMatch || isFuzzy) {
              const itemName = pickLang(item.name || {}, [lang]) || '';
              results.push({
                typeObj,
                category: cat,
                item,
                typeName: typeLabel,
                catName: catName,
                itemName: itemName,
                lang,
                fuzzy: !isMatch && isFuzzy,
                fuzzyScore: bestFuzz,
                matchExact: bestFuzz === 0
              });
            }
          }
        }
      }
    }

    // If exact substring present in keywords -> prefer non-fuzzy
    if (keywordExactSubstringMatch(q, allKeywords)) {
      const sub = results.filter(r => !r.fuzzy);
      if (sub.length) results = sub;
    }

    // Score and sort: exact match (0) -> prefix (1) -> contains (2) -> fuzzy (>=3)
    results.forEach(r => {
      let score = 10 + (r.fuzzyScore || 0);
      // promote exact matches on itemName/api/category/type
      const normItemName = normalizeText(r.itemName || '');
      const normApi = normalizeText(r.item && r.item.api || '');
      const normCat = normalizeText(r.catName || '');
      const normType = normalizeText(r.typeName || '');
      if (normItemName === q || normApi === q || normCat === q || normType === q) score = 0;
      else if ((normItemName && normItemName.startsWith(q)) || (normApi && normApi.startsWith(q)) || (normCat && normCat.startsWith(q)) || (normType && normType.startsWith(q))) score = 1;
      else if ((normItemName && normItemName.includes(q)) || (normApi && normApi.includes(q)) || (normCat && normCat.includes(q)) || (normType && normType.includes(q))) score = 2;
      else if (r.fuzzy) score = 3 + (r.fuzzyScore || 0);
      r._score = score;
    });

    results.sort((a,b) => a._score - b._score);
    return results;
  }

  // ---------- UI rendering & suggestions ----------
  function setBodyMarginForSearch(active) {
    const body = document.body;
    if (active) { if (body.style.marginBottom !== "60px") body.style.marginBottom = "60px"; }
    else { if (body.style.marginBottom !== "") body.style.marginBottom = ""; }
  }

  function renderResultItemHTML(res, lang) {
    let itemNames = [];
    if (res.item && res.item.name) itemNames.push(pickLang(res.item.name, [lang]));
    for (const k in (res.item||{})) if (/_name$/.test(k) && res.item[k]) itemNames.push(pickLang(res.item[k], [lang]));
    itemNames = itemNames.filter(Boolean).join(' / ');
    let typeDisplay = res.typeObj && res.typeObj.name ? pickLang(res.typeObj.name, [lang]) : "";
    if (!typeDisplay) typeDisplay = t('emoji');
    const catDisplay = (res.category && res.category.name) ? pickLang(res.category.name, [lang]) : '';
    const text = res.item && res.item.text ? res.item.text : '-';
    const api = res.item && res.item.api ? res.item.api : '';
    // copy button includes text (prefer text, fallback to itemName or api)
    const copyTextVal = encodeURIComponent(res.item && res.item.text ? res.item.text : (res.itemName || api || ''));
    return `<div class="result-item">
      <div class="result-content-area">
        <div class="result-text-area">
          <span class="result-text">${escapeHtml(text)}</span>
          ${api ? `<span class="result-api">${escapeHtml(api)}</span>` : ''}
        </div>
        <div class="result-names">${escapeHtml(itemNames)}</div>
        <div class="result-meta">
          <span class="result-meta-label">${t('type')}:</span><span class="result-meta-value">${escapeHtml(typeDisplay)}</span>
          <span class="result-meta-label" style="margin-left:8px">${t('category')}:</span><span class="result-meta-value">${escapeHtml(catDisplay)}</span>
        </div>
        <button class="result-copy-btn" data-text="${copyTextVal}" aria-label="${t('copy')}">${t('copy')}</button>
      </div>
    </div>`;
  }

  function disconnectRenderObserver() {
    if (renderObserver) {
      try { renderObserver.disconnect(); } catch (e) {}
      renderObserver = null;
    }
    const old = document.getElementById(sentinelId);
    if (old && old.parentNode) old.parentNode.removeChild(old);
  }

  function renderNextBatch() {
    const container = document.getElementById('searchResults');
    if (!container) return;
    const lang = getLang();
    const start = currentRenderIndex;
    const end = Math.min(currentRenderIndex + renderBatchSize, currentFilteredResults.length);
    let fragment = '';
    for (let i=start;i<end;i++) fragment += renderResultItemHTML(currentFilteredResults[i], lang);
    const sentinelEl = document.getElementById(sentinelId);
    if (sentinelEl) sentinelEl.insertAdjacentHTML('beforebegin', fragment);
    else container.insertAdjacentHTML('beforeend', fragment);
    currentRenderIndex = end;
    if (currentRenderIndex >= currentFilteredResults.length) disconnectRenderObserver();
    else {
      if (!document.getElementById(sentinelId)) {
        const s = document.createElement('div'); s.id = sentinelId; s.className='search-sentinel'; s.style.cssText='width:100%;height:36px;display:block;';
        container.appendChild(s);
      }
      if (!renderObserver) {
        renderObserver = new IntersectionObserver((entries)=>{
          for (let i=0;i<entries.length;i++) if (entries[i].isIntersecting) setTimeout(()=>{ if (currentRenderIndex < currentFilteredResults.length) renderNextBatch(); }, 50);
        }, { root:null, rootMargin:'0px', threshold:0.1 });
        const sEl = document.getElementById(sentinelId);
        if (sEl) renderObserver.observe(sEl);
      }
    }
  }

  function renderResults(results, showSuggestionsIfNoResult=false) {
    const container = document.getElementById('searchResults');
    const lang = getLang();
    if (!container) return;
    let filtered = (selectedCategory !== 'all') ? results.filter(res => pickLang((res.category && res.category.name) || '', [lang]) === selectedCategory) : results.slice();
    setBodyMarginForSearch(true);
    disconnectRenderObserver();
    currentFilteredResults = [];
    currentRenderIndex = 0;
    if (!filtered.length) {
      let html = `<div class="no-result">${t('not_found')}</div>`;
      if (showSuggestionsIfNoResult) {
        html += `<div class="suggestions-title-main">${t('suggestions_for_you')}</div>`;
        html += renderSuggestionsBlock(lang, getRandomSuggestions([],4), getRandomSuggestions([],4));
      }
      container.innerHTML = html;
      const catFilterEl = document.getElementById('categoryFilter');
      if (catFilterEl) catFilterEl.style.display = '';
      filterCategories = [];
      updateUILanguage();
      return;
    }
    currentFilteredResults = filtered;
    currentRenderIndex = 0;
    container.innerHTML = '';
    renderNextBatch();
    if (!window._copyResultTextHandlerSet) {
      container.addEventListener('click', function(e){
        const btn = e.target.closest('.result-copy-btn');
        if (btn && btn.hasAttribute('data-text')) { e.preventDefault(); copyText(decodeURIComponent(btn.getAttribute('data-text'))); }
      });
      window._copyResultTextHandlerSet = true;
    }
    updateUILanguage();
  }

  // ---------- Suggestions UI and overlay helpers ----------
  function createSuggestionBackdrop() {
    const overlay = document.getElementById(overlayContainerId);
    if (!overlay) return null;
    let bd = document.getElementById(suggestionBackdropId);
    if (bd) return bd;
    bd = document.createElement('div');
    bd.id = suggestionBackdropId;
    bd.style.cssText = 'position:absolute;left:0;top:0;right:0;bottom:0;z-index:10000;background:transparent;pointer-events:auto;';
    bd.addEventListener('pointerdown', function(ev) {
      const sugg = document.getElementById(suggestionContainerId);
      if (sugg && sugg.contains(ev.target)) return;
      ignoreNextHideSuggestions = true;
      setTimeout(()=>{ ignoreNextHideSuggestions = false; }, 300);
      // Delegate to central logic that decides whether to search/close and whether to commit history
      handleBackdropClickAction();
    }, { passive: true });
    overlay.insertBefore(bd, overlay.firstChild);
    return bd;
  }
  function removeSuggestionBackdrop() {
    const bd = document.getElementById(suggestionBackdropId);
    if (bd && bd.parentNode) bd.parentNode.removeChild(bd);
  }
  function ensureSuggestionContainer() {
    let c = document.getElementById(suggestionContainerId);
    const overlay = document.getElementById(overlayContainerId);
    if (!overlay) return null;
    if (!c) {
      c = document.createElement('div');
      c.id = suggestionContainerId;
      c.className = 'search-suggestions';
      c.style.cssText = 'position:relative; z-index:10001; max-height:320px; overflow:auto; background:#fff; border:1px solid #e6e9ee; box-shadow:0 8px 30px rgba(19,23,40,0.12); border-radius:10px; margin-top:8px;';
      overlay.appendChild(c);
      c.addEventListener('keydown', function(ev) {
        const items = Array.from(c.querySelectorAll('.suggestion-item'));
        if (!items.length) return;
        const active = document.activeElement;
        const idx = items.indexOf(active);
        if (ev.key === 'ArrowDown') { ev.preventDefault(); const next = (idx === -1) ? items[0] : items[Math.min(items.length-1, idx+1)]; next && next.focus && next.focus(); }
        else if (ev.key === 'ArrowUp') { ev.preventDefault(); const prev = (idx === -1) ? items[items.length-1] : items[Math.max(0, idx-1)]; prev && prev.focus && prev.focus(); }
        else if (ev.key === 'Enter') { ev.preventDefault(); if (active && active.classList && active.classList.contains('suggestion-item')) active.click && active.click(); }
        else if (ev.key === 'Escape') { ev.preventDefault(); hideSuggestions(); }
      });
      c.addEventListener('click', function(ev) {
        const it = ev.target.closest('.suggestion-item');
        if (!it) return;
        ev && ev.stopPropagation && ev.stopPropagation();
        ev && ev.preventDefault && ev.preventDefault();
        let val = it.getAttribute('data-val') || '';
        try { val = decodeURIComponent(val); } catch (e) {}
        const inputEl = document.getElementById('searchInput');
        if (inputEl) inputEl.value = val;
        hideSuggestions();
        doSearch(null, false);
      });
    }
    return c;
  }
  function hideSuggestions() {
    if (ignoreNextHideSuggestions) return;
    const c = document.getElementById(suggestionContainerId);
    if (c) c.style.display = 'none';
    removeSuggestionBackdrop();
  }

  // ---------- SearchManager (centralized search service) ----------
  const SearchManager = (function(){
    let _data = null;
    let _keywords = [];
    return {
      init: function(data) {
        _data = data;
        _keywords = generateAllKeywords(data || {});
      },
      querySuggestions: function(q, maxCount) {
        maxCount = maxCount || suggestionMax;
        const rawQuery = String(q || '');
        const qn = normalizeText(rawQuery);
        if (!qn) return [];
        // Use keyword fuzzy matches to get candidate buckets
        const matches = getBestKeywordMatches(qn, _keywords, Math.max(12, maxCount), true);
        if (!matches || !matches.length) return [];
        const lang = getLang();
        const seen = new Set();
        const out = [];
        const queryHasThai = containsThai(rawQuery);
        const queryHasLatin = containsLatin(rawQuery);
        for (let i=0; i<matches.length && out.length < maxCount; i++) {
          const s = matches[i];
          const candidates = [];
          if (s.item) {
            const it = s.item;
            const itemName = it.name ? pickLang(it.name, [lang]) : (s.itemName || '');
            if (itemName) candidates.push({ raw: itemName, source: 'item' });
            if (it.api) candidates.push({ raw: it.api, source: 'api' });
            if (s.catName) candidates.push({ raw: s.catName, source: 'category' });
            if (s.typeName) candidates.push({ raw: s.typeName, source: 'type' });
          } else if (s.isCategory && s.category) {
            const catName = pickLang(s.category.name || {}, [lang]) || s.catName || '';
            if (catName) candidates.push({ raw: catName, source: 'category' });
            const items = s.category.data || [];
            for (let k=0; k<items.length; k++) {
              const it = items[k];
              const itName = it && it.name ? pickLang(it.name, [lang]) : (it && it.api ? it.api : '');
              if (itName) candidates.push({ raw: itName, source: 'item' });
            }
            if (s.typeName) candidates.push({ raw: s.typeName, source: 'type' });
          } else if (s.isType && s.typeObj) {
            const typeName = pickLang(s.typeObj.name || {}, [lang]) || s.typeName || '';
            if (typeName) candidates.push({ raw: typeName, source: 'type' });
            const cats = s.typeObj.category || [];
            for (let c=0; c<cats.length; c++) {
              const cat = cats[c];
              const catName = pickLang(cat.name || {}, [lang]) || '';
              if (catName) candidates.push({ raw: catName, source: 'category' });
              const items = cat.data || [];
              for (let k=0; k<items.length; k++) {
                const it = items[k];
                const itName = it && it.name ? pickLang(it.name, [lang]) : (it && it.api ? it.api : '');
                if (itName) candidates.push({ raw: itName, source: 'item' });
              }
            }
          } else {
            if (s.itemName) candidates.push({ raw: s.itemName, source: 'item' });
            else if (s.key) candidates.push({ raw: s.key, source: 'keyword' });
          }

          // Filter candidates: stricter logic to ensure suggestions closely match user's typed characters.
          for (let cidx=0; cidx<candidates.length && out.length < maxCount; cidx++) {
            const cand = candidates[cidx];
            if (!cand || !cand.raw) continue;
            const raw = String(cand.raw).trim();
            const norm = normalizeText(raw);
            if (!norm) continue;

            // Ensure script compatibility (e.g., Thai query -> Thai suggestions)
            if (!scriptsCompatible(rawQuery, raw)) continue;

            // Require that normalized candidate contains normalized query as substring.
            // This enforces suggestions to be closely tied to what user typed.
            if (norm.indexOf(qn) === -1) {
              // allow limited fuzzy suggestion only when user query is short and candidate is very similar
              const dist = levenshtein(qn, norm);
              if (!(qn.length <= 3 && dist <= 1)) continue;
            }

            // If user typed Thai, avoid showing API/code-like candidates (typically ASCII)
            if (queryHasThai && isLikelyCode(raw)) continue;

            if (seen.has(norm)) continue;
            seen.add(norm);
            const highlighted = highlightMatchesHtml(raw, rawQuery);
            out.push({ display: raw, raw: raw, highlightedHtml: highlighted, source: cand.source });
          }
        }
        return out;
      },
      doSearch: function(q, preventPush, options) {
        const qEl = document.getElementById('searchInput');
        if (qEl && typeof q !== 'undefined') qEl.value = q;
        return doSearch(null, preventPush, options);
      }
    };
  })();

  // ---------- helpers for highlighted suggestion rendering ----------
  function highlightMatchesHtml(text, query) {
    if (!text) return '';
    if (!query) return escapeHtml(text);
    const normQuery = normalizeText(query);
    // Highlight exact substring occurrences first (better UX for stricter matching)
    try {
      const normText = normalizeText(text);
      let startIdx = normText.indexOf(normQuery);
      if (startIdx !== -1) {
        // We need to map normalized indices back to original string chars.
        // Simpler approach: mark characters in original that match query's characters when compared sequentially.
        let out = '';
        let qi = 0;
        for (let i=0;i<text.length;i++) {
          const ch = text[i];
          const nch = normalizeText(ch);
          if (nch && nch.length && qi < normQuery.length && normQuery.indexOf(nch) !== -1 && normalizeText(text.substr(i,1)) === nch && normQuery[qi] === nch) {
            out += '<strong>' + escapeHtml(ch) + '</strong>';
            qi++;
          } else {
            out += escapeHtml(ch);
          }
        }
        return out;
      }
    } catch (e) {}
    // fallback to per-character heuristic (previous behavior)
    let out = '';
    for (let i=0;i<text.length;i++) {
      const ch = text[i];
      const nch = normalizeText(ch);
      if (nch && nch.length) {
        let matched = false;
        for (let j=0;j<nch.length;j++) {
          if (nch[j] && normQuery.indexOf(nch[j]) !== -1) { matched = true; break; }
        }
        if (matched) out += '<strong>' + escapeHtml(ch) + '</strong>';
        else out += escapeHtml(ch);
      } else {
        out += escapeHtml(ch);
      }
    }
    return out;
  }
  function escapeHtml(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function renderQuerySuggestions(query) {
    if (!overlayOpen) openSearchOverlay();
    const container = ensureSuggestionContainer();
    if (!container) return;
    if (!query || !query.trim()) { container.innerHTML = ''; container.style.display = 'none'; removeSuggestionBackdrop(); return; }

    const suggestions = SearchManager.querySuggestions(query, suggestionMax);
    if (!suggestions || !suggestions.length) { container.innerHTML = ''; container.style.display = 'none'; removeSuggestionBackdrop(); return; }

    let html = `<div class="suggestions-head" style="padding:8px 10px;font-weight:600;color:#333;">${t('suggestion_label')}</div>`;
    for (let i=0;i<suggestions.length;i++){
      const s = suggestions[i];
      // keep consistent styling, use precomputed highlightedHtml
      html += `<div class="suggestion-item" role="option" tabindex="0" data-val="${encodeURIComponent(s.raw)}" style="padding:8px 10px;border-top:1px solid #f4f6fa;cursor:pointer;display:flex;justify-content:space-between;align-items:center;"><div style="flex:1 1 auto;min-width:0">${s.highlightedHtml}</div><div class="suggestion-meta" aria-hidden="true">${escapeHtml(s.source||'')}</div></div>`;
    }

    container.innerHTML = html;
    container.style.display = 'block';
    createSuggestionBackdrop();
    const inputEl = document.getElementById('searchInput');
    if (inputEl) {
      inputEl.onkeydown = function(e) {
        if (e.key === 'ArrowDown') { e.preventDefault(); const first = container.querySelector('.suggestion-item'); if (first) first.focus && first.focus(); }
        else if (e.key === 'Escape') hideSuggestions();
      };
    }
  }

  // ---------- Overlay open/close with precise history sync ----------
  function openSearchOverlay() {
    if (overlayOpen) return;
    const wrapper = document.querySelector('.search-input-wrapper');
    if (!wrapper) return;
    originalInputParent = wrapper.parentNode;
    originalInputNextSibling = wrapper.nextSibling;
    const inputEl = document.getElementById('searchInput');
    preOverlayState = { q: inputEl ? (inputEl.value || '') : '', type: selectedType || 'all', category: selectedCategory || 'all' };

    // create backdrop
    let backdrop = document.getElementById(overlayBackdropId);
    if (!backdrop) {
      backdrop = document.createElement('div');
      backdrop.id = overlayBackdropId;
      backdrop.className = 'search-overlay-backdrop';
      backdrop.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(12,14,18,0.48);z-index:9998;backdrop-filter:blur(4px);pointer-events:auto;';
      backdrop.onclick = function(ev) {
        ignoreNextHideSuggestions = true;
        setTimeout(()=>{ ignoreNextHideSuggestions = false; }, 300);
        handleBackdropClickAction();
      };
      document.body.appendChild(backdrop);
    }
    // create overlay container
    let overlay = document.getElementById(overlayContainerId);
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = overlayContainerId;
      overlay.className = 'search-overlay search-overlay-open';
      overlay.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:24px 16px 16px;pointer-events:auto;';
      document.body.appendChild(overlay);
    } else {
      overlay.innerHTML = '';
    }

    // move wrapper
    wrapper.classList.add('overlay-elevated');
    wrapper.style.width = '100%';
    wrapper.style.maxWidth = '720px';
    wrapper.style.marginTop = '6px';
    wrapper.style.pointerEvents = 'auto';
    overlay.appendChild(wrapper);

    ensureSuggestionContainer();

    if (inputEl) setTimeout(() => { try { inputEl.focus(); inputEl.select && inputEl.select(); } catch (e) {} }, 20);

    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';

    // push a transient overlay history entry so Back can close it predictably
    try {
      history.pushState({ __overlay: true, __overlay_from: lastCommittedState || null }, '', window.location.href);
      overlayHistoryPushed = true;
    } catch (e) { overlayHistoryPushed = false; }

    document.addEventListener('keydown', overlayEscHandler);
    overlayOpen = true;

    // auto-run search only when there's text and we want auto-run (keeps overlay open)
    const q = inputEl ? (inputEl.value || '').trim() : '';
    if (q) {
      const candidateState = { q: q, type: selectedType || 'all', category: selectedCategory || 'all' };
      const shouldPush = !isStateEqual(candidateState, lastCommittedState);
      setTimeout(()=>{ doSearch(null, !shouldPush, { keepOverlay:true }); }, 40);
    }
  }

  function overlayEscHandler(e) {
    if (e.key === 'Escape') {
      if (preOverlayState) {
        const inp = document.getElementById('searchInput');
        if (inp) inp.value = preOverlayState.q || '';
        selectedType = preOverlayState.type || 'all';
        selectedCategory = preOverlayState.category || 'all';
      }
      closeSearchOverlay();
    }
  }

  // Centralized backdrop action logic
  function handleBackdropClickAction() {
    const inp = document.getElementById('searchInput');
    const curr = inp ? (inp.value || '') : '';
    // If input is empty -> close overlay (restore) as usual
    if (!curr || !curr.trim()) {
      removeTransientOverlayEntry();
      closeSearchOverlay();
      return;
    }
    // If unchanged from preOverlayState -> do a search but do NOT commit history
    if (preOverlayState && typeof preOverlayState.q !== 'undefined' && curr === (preOverlayState.q || '')) {
      hideSuggestions();
      doSearch(null, true); // preventPush = true -> do not commit history
      try { inp && inp.blur(); } catch (e) {}
      closeSearchOverlay();
      return;
    }
    // If changed -> perform search and commit
    hideSuggestions();
    doSearch(null, false);
    try { inp && inp.blur(); } catch (e) {}
  }

  function closeSearchOverlay() {
    if (!overlayOpen) return;
    removeTransientOverlayEntry();

    const wrapper = document.querySelector('.search-input-wrapper');
    if (!wrapper) return;

    wrapper.classList.remove('overlay-elevated');
    wrapper.style.width = '';
    wrapper.style.maxWidth = '';
    wrapper.style.marginTop = '';
    wrapper.style.pointerEvents = '';
    if (originalInputParent) {
      if (originalInputNextSibling) originalInputParent.insertBefore(wrapper, originalInputNextSibling);
      else originalInputParent.appendChild(wrapper);
    }

    const sc = document.getElementById(suggestionContainerId);
    if (sc && sc.parentNode) sc.parentNode.removeChild(sc);
    removeSuggestionBackdrop();

    const overlay = document.getElementById(overlayContainerId);
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
    const backdrop = document.getElementById(overlayBackdropId);
    if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);

    document.documentElement.style.overflow = '';
    document.body.style.overflow = '';

    document.removeEventListener('keydown', overlayEscHandler);
    overlayOpen = false;
  }

  // ---------- doSearch: only commit when explicit and there is a real change ----------
  function doSearch(e, preventPush, options) {
    if (e) e.preventDefault();
    options = options || {};
    const qEl = document.getElementById('searchInput');
    const q = qEl ? qEl.value : '';
    selectedType = document.getElementById('typeFilter') ? document.getElementById('typeFilter').value : selectedType;
    selectedCategory = 'all';
    hideSuggestions();

    if (!q.trim()) {
      setBodyMarginForSearch(false);
      const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
      const sr = document.getElementById('searchResults');
      if (sr) sr.innerHTML = placeholderHtml;
      setupCategoryFilter([], 'all');
      filterCategories = [];
      updateUILanguage();
      const stateCleared = { q: '', type: 'all', category: 'all' };
      if (!preventPush && !suppressHistoryPush && !isStateEqual(stateCleared, lastCommittedState)) {
        commitSearchState(stateCleared);
      }
      if (overlayOpen && !options.keepOverlay) closeSearchOverlay();
      return;
    }

    currentResults = smartSearch(apiData, q, selectedType, allKeywordsCache);
    filterCategories = extractResultCategories(currentResults);
    setupCategoryFilter(filterCategories, 'all');

    const stateObj = { q: q, type: selectedType || 'all', category: 'all' };
    const willCommit = (!preventPush && !suppressHistoryPush && !isStateEqual(stateObj, lastCommittedState));
    if (willCommit) {
      commitSearchState(stateObj);
    }

    renderResults(currentResults, currentResults.length === 0);
    updateUILanguage();

    if (overlayOpen && !options.keepOverlay) closeSearchOverlay();
  }

  // ---------- small UI helpers ----------
  function setupTypeFilter(selected='all') {
    const typeFilter = document.getElementById('typeFilter');
    if (!typeFilter) return;
    let buf = [`<option value="all">${t('all_types')}</option>`];
    if (apiData && Array.isArray(apiData.type)) {
      const lang = getLang();
      for (let i=0;i<apiData.type.length;i++) {
        let label = pickLang(apiData.type[i].name, [lang]);
        buf.push(`<option value="${label}">${escapeHtml(label)}</option>`);
      }
    }
    typeFilter.innerHTML = buf.join('');
    typeFilter.value = selected;
  }

  function setupCategoryFilter(categories, selected='all') {
    const catFilter = document.getElementById('categoryFilter');
    if (!catFilter) return;
    let buf = [`<option value="all">${t('all_categories')}</option>`];
    for (let i=0;i<categories.length;i++){
      const { key, displayName } = categories[i];
      buf.push(`<option value="${escapeHtml(key)}">${escapeHtml(displayName)}</option>`);
    }
    catFilter.innerHTML = buf.join('');
    catFilter.style.display = '';
    catFilter.value = selected;
  }

  function getRandomSuggestions(arr, count=5) {
    if (!arr || !arr.length) return [];
    let n = arr.length, out = [], idx;
    const pool = arr.slice();
    for (let i=0;i<count && n>0;i++,n--){
      idx = (Math.random()*n)|0;
      out.push(pool[idx]);
      pool[idx] = pool[n-1];
    }
    return out;
  }

  function extractResultCategories(results) {
    const lang = getLang();
    let categories = [], seen = Object.create(null);
    for (let i=0;i<results.length;i++) {
      const cat = results[i].category || { name: '' }, key = pickLang(cat.name,[lang]) || '';
      const displayName = key;
      if (!seen[key]) { seen[key]=1; categories.push({ key, displayName }); }
    }
    return categories;
  }

  function showCopyToast(msg) {
    const toast = document.createElement('div');
    toast.className = 'copy-toast-message';
    toast.textContent = msg;
    const area = document.getElementById('copyToast') || document.body;
    area.appendChild(toast);
    setTimeout(()=>{ toast.style.opacity='0'; toast.style.transform='translateY(-10px)'; setTimeout(()=>toast.remove(),250); }, 1400);
  }
  async function copyText(text) {
    try { await navigator.clipboard.writeText(text); showCopyToast(t('copy') + 'แล้ว'); } catch { showCopyToast(t('copy_failed')); }
  }

  // ---------- restore UI state from history (ensures results follow history) ----------
  function restoreUIState(st) {
    try {
      suppressHistoryPush = true;
      const input = document.getElementById('searchInput');
      if (input) input.value = st.q || '';
      selectedType = st.type || 'all';
      selectedCategory = st.category || 'all';
      setupTypeFilter(selectedType);
      // run search but prevent pushing a new history entry (since we're restoring)
      doSearch(null, true);
    } finally {
      suppressHistoryPush = false;
    }
  }

  // ---------- startup & wiring ----------
  window.addEventListener('popstate', function(e){
    const state = e.state || {};
    // If overlay open and popped state does NOT indicate overlay -> Back closed overlay
    if (overlayOpen && !state.__overlay) {
      if (preOverlayState) {
        const inp = document.getElementById('searchInput');
        if (inp) inp.value = preOverlayState.q || '';
        selectedType = preOverlayState.type || 'all';
        selectedCategory = preOverlayState.category || 'all';
      }
      const wrapper = document.querySelector('.search-input-wrapper');
      if (wrapper && originalInputParent) {
        wrapper.classList.remove('overlay-elevated');
        wrapper.style.width = ''; wrapper.style.maxWidth=''; wrapper.style.marginTop='';
        if (originalInputNextSibling) originalInputParent.insertBefore(wrapper, originalInputNextSibling);
        else originalInputParent.appendChild(wrapper);
      }
      const sc = document.getElementById(suggestionContainerId);
      if (sc && sc.parentNode) sc.parentNode.removeChild(sc);
      removeSuggestionBackdrop();
      const overlay = document.getElementById(overlayContainerId);
      if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
      const backdrop = document.getElementById(overlayBackdropId);
      if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);
      document.documentElement.style.overflow=''; document.body.style.overflow='';
      document.removeEventListener('keydown', overlayEscHandler);
      overlayOpen = false; overlayHistoryPushed = false; preOverlayState = null;
      return;
    }

    // Normal restore: restore search state from history (committed search)
    const st = (e.state && typeof e.state === 'object') ? e.state : readStateFromURL();
    if (st && st.q !== undefined) {
      restoreUIState(st);
    }
  });

  // Click outside suggestions hides them when overlay is not open
  document.addEventListener('click', function(ev) {
    const container = document.getElementById(suggestionContainerId);
    const input = document.getElementById('searchInput');
    if (!container) return;
    if (overlayOpen) return;
    if (ev.target === input || container.contains(ev.target)) return;
    hideSuggestions();
  }, false);

  // pointerdown capture for outside overlay clicks -> reliable backdrop detection
  document.addEventListener('pointerdown', function(ev) {
    if (!overlayOpen) return;
    if (ev.target.closest('#' + overlayContainerId)) return;
    ignoreNextHideSuggestions = true;
    setTimeout(()=>{ ignoreNextHideSuggestions = false; }, 300);
    handleBackdropClickAction();
  }, true);

  // initial load
  fetch('/assets/json/api-database.min.json').then(res=>res.json()).then(data=>{
    apiData = data;
    allKeywordsCache = generateAllKeywords(apiData);
    SearchManager.init(apiData);
    setupTypeFilter('all');
    setupMobileSelectEnter();
    setupAutoSearchInput();
    setupCategoryFilter([], 'all');
    setBodyMarginForSearch(false);
    const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
    const sr = document.getElementById('searchResults');
    if (sr) sr.innerHTML = placeholderHtml;
    updateUILanguage();

    // Initialize lastCommittedState from history or sessionStorage
    try {
      const hs = window.history && window.history.state;
      if (hs && typeof hs === 'object' && (hs.q !== undefined)) {
        lastCommittedState = { q: hs.q || '', type: hs.type || 'all', category: hs.category || 'all' };
      } else {
        const raw = sessionStorage.getItem(SEARCH_HISTORY_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        if (arr && arr.length) {
          const last = arr[arr.length - 1];
          lastCommittedState = { q: last.q || '', type: last.type || 'all', category: last.category || 'all' };
        } else lastCommittedState = null;
      }
    } catch (e) { lastCommittedState = null; }

    // Restore initial URL search if present (without double-push)
    const initial = readStateFromURL();
    if (initial && initial.q) {
      try {
        suppressHistoryPush = true;
        const input = document.getElementById('searchInput');
        if (input) input.value = initial.q;
        selectedType = initial.type || 'all';
        selectedCategory = initial.category || 'all';
        setupTypeFilter(selectedType);
        doSearch(null, true);
        try { history.replaceState({ q: initial.q, type: selectedType, category: selectedCategory }, '', buildUrlForState(initial)); } catch (e) {}
        lastCommittedState = { q: initial.q || '', type: selectedType || 'all', category: selectedCategory || 'all' };
      } finally { suppressHistoryPush = false; }
    } else {
      try { history.replaceState({ q: '', type: 'all', category: 'all' }, '', window.location.pathname); } catch (e) {}
      lastCommittedState = { q: '', type: 'all', category: 'all' };
    }
  }).catch(err => console.error('Failed to load api database', err));

  // form/input wiring
  const formEl = document.getElementById('searchForm');
  if (formEl) formEl.addEventListener('submit', e => { e.preventDefault(); doSearch(); closeMobileKeyboard(); });
  const inputEl = document.getElementById('searchInput');
  if (inputEl) inputEl.addEventListener('keydown', function(e){ if (e.key === 'Enter') { e.preventDefault(); doSearch(); closeMobileKeyboard(); } });

  function prepareSuggestionCaches(data) {
    // kept for backward compatibility (not used directly for suggestions now)
    // but still populates emoji/symbol caches if needed
  }

  function setupMobileSelectEnter() {
    ['typeFilter','categoryFilter'].forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      el.onchange = () => (id==='typeFilter' ? onTypeChange() : onCategoryChange());
      el.onkeyup = function(e){ if (e.key === 'Enter') (id==='typeFilter' ? onTypeChange() : onCategoryChange()); };
    });
  }
  function setupAutoSearchInput() {
    const input = document.getElementById('searchInput');
    if (!input) return;
    input.setAttribute('enterkeyhint','search');
    input.oninput = function(){ clearTimeout(debounceTimeout); debounceTimeout = setTimeout(()=>{ renderQuerySuggestions(this.value); }, 120); };
    input.onkeydown = function(e){
      if (e.key === 'Enter') { e.preventDefault(); hideSuggestions(); doSearch(); closeMobileKeyboard(); }
      else if (e.key === 'ArrowDown') { const container = document.getElementById(suggestionContainerId); if (container) { const first = container.querySelector('.suggestion-item'); if (first) first.focus && first.focus(); } }
    };
    input.addEventListener('blur', function(){ if (ignoreNextHideSuggestions) return; setTimeout(hideSuggestions, 200); });
    input.addEventListener('focus', function(){ openSearchOverlay(); });
    input.addEventListener('click', function(){ openSearchOverlay(); });
  }
  function updateUILanguage() {
    const input = document.getElementById('searchInput');
    if (input && input.placeholder !== t('search_placeholder')) input.placeholder = t('search_placeholder');
    const filterGroupLabels = document.querySelectorAll('.search-filters-panel .filter-group-label');
    if (filterGroupLabels.length>0 && filterGroupLabels[0].textContent !== t('type')) filterGroupLabels[0].textContent = t('type');
    if (filterGroupLabels.length>1 && filterGroupLabels[1].textContent !== t('category')) filterGroupLabels[1].textContent = t('category');
  }
  function onTypeChange(){ selectedType = document.getElementById('typeFilter').value; doSearch(); }
  function onCategoryChange(){ selectedCategory = document.getElementById('categoryFilter').value; renderResults(currentResults,false); updateUILanguage(); }
  function closeMobileKeyboard(){ const input = document.getElementById('searchInput'); if (input && document.activeElement === input) input.blur(); }
  function renderSuggestionsBlock(lang, emojis=[], symbols=[]) {
    let html = '';
    if (emojis.length) { html += `<div class="suggestions-head">${t('emoji_suggestions')}</div>`; for (let i=0;i<emojis.length;i++) html += renderSuggestionItemWithRealCategory(emojis[i], lang); }
    if (symbols.length) { html += `<div class="suggestions-head">${t('symbol_suggestions')}</div>`; for (let i=0;i<symbols.length;i++) html += renderSuggestionItemWithRealCategory(symbols[i], lang); }
    return `<div class="suggestions-block-list">${html}</div>`;
  }
  function renderSuggestionItemWithRealCategory(obj, lang) {
    const typeLabel = t('type'), catLabel = t('category');
    let catName = obj.category ? (pickLang(obj.category.name, [lang]) || obj.category.name || "") : '';
    let typeDisplay = obj.typeObj ? (pickLang(obj.typeObj.name, [lang]) || obj.typeObj.name || "") : '';
    if (!typeDisplay) typeDisplay = t('emoji');
    const text = obj.text || '-';
    const api = obj.api || '';
    return `<div class="result-item"><div class="result-content-area"><div class="result-text-area"><span class="result-text">${escapeHtml(text)}</span><span class="result-api">${escapeHtml(api)}</spa[...]</div></div></div>`;
  }

  // Expose debug helpers
  window.__searchEngineDebug = {
    getLastCommittedState: () => lastCommittedState,
    getOverlayHistoryPushed: () => overlayHistoryPushed,
    getSessionHistory: () => { try { return JSON.parse(sessionStorage.getItem(SEARCH_HISTORY_KEY) || '[]'); } catch(e){return[];} },
    querySuggestions: (q) => SearchManager.querySuggestions(q, suggestionMax)
  };

  // End of IIFE
})();