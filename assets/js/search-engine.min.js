// search-engine.min.js
// Renovated single-file search + overlay + suggestions + modern history commit system
// - Keeps all original UI functions (overlay, suggestions, smartSearch, rendering, keyboard nav).
// - Major redesign of history behaviour: record history ONLY when an explicit search is committed.
// - Overlay push is transient: Back closes overlay. On commit, transient is replaced by committed search state.
// - No history entries while typing; no duplicate/garbage history entries after closing overlay.
// - SessionStorage search log updated only on committed searches.
// - Aim: production-grade predictable history, preserve original UX and APIs.

(() => {
  // ---------- Core state ----------
  let apiData = null;
  let currentResults = [];
  let filterCategories = [];
  let selectedType = 'all';
  let selectedCategory = 'all';
  let debounceTimeout = null;
  let allKeywordsCache = [];
  let emojiSuggestionsCache = [];
  let symbolSuggestionsCache = [];

  // incremental render
  let renderObserver = null;
  let renderBatchSize = 12;
  let currentRenderIndex = 0;
  let currentFilteredResults = [];
  const sentinelId = 'search-render-sentinel';

  // history / url
  const SEARCH_HISTORY_KEY = 'searchHistory_v1';
  let suppressHistoryPush = false; // when restoring UI from history
  let lastCommittedState = null;   // last "real" search state that was recorded
  // overlay / suggestion state
  const suggestionContainerId = 'searchSuggestions';
  const suggestionBackdropId = 'searchSuggestionBackdrop';
  const suggestionMax = 8;
  const overlayBackdropId = 'searchOverlayBackdrop';
  const overlayContainerId = 'searchOverlayContainer';
  let originalInputParent = null;
  let originalInputNextSibling = null;
  let overlayOpen = false;
  let preOverlayState = null; // state at moment overlay opened
  let overlayHistoryPushed = false; // transient overlay history entry pushed?

  // avoid races between pointerdown/backdrop and blur/hideSuggestions
  let ignoreNextHideSuggestions = false;

  // ---------- Text normalization (improves matching) ----------
  function normalizeText(s) {
    if (!s && s !== 0) return '';
    s = String(s).toLowerCase().trim();
    try { s = s.normalize('NFKD').replace(/[\u0300-\u036f]/g, ''); } catch (e) {}
    s = s.replace(/[\u200B-\u200D\uFEFF]/g, '');
    s = s.replace(/[\u2018\u2019\u201A\u201B\u2032\u2035]/g, "'").replace(/[\u201C\u201D\u201E\u201F\u2033\u2036]/g, '"');
    s = s.replace(/[\uFF01-\uFF5E]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
    // keep unicode letters/numbers, replace other punctuation with space
    s = s.replace(/[^\p{L}\p{N}\s]+/gu, ' ');
    s = s.replace(/\s+/g, ' ').trim();
    return s;
  }

  // ---------- localization ----------
  const LANG_TEXTS = {
    th: { all_types: "ทุกประเภท", all_categories: "ทุกหมวดหมู่", not_found: "ไม่พบข้อมูลที่ตรงหรือใกล้เคียงกับคีย์เวิร์ดของคุณ", copy: "คัดลอก", suggestions_for_you: "คำแนะนำสำหรับคุณ", emoji_suggestions: "คำแนะนำอิโมจิ", symbol_suggestions: "คำแนะนำสัญลักษณ์", type: "ประเภท", category: "หมวดหมู่", emoji: "อิโมจิ", predicted: "คาดเดา", search_placeholder: "ค้นหา... (ตัวอย่าง: smile, heart)", search_result_here: "ผลการค้นหาจะแสดงที่นี่", suggestion_label: "คำค้นที่แนะนำ" },
    en: { all_types: "All Types", all_categories: "All Categories", not_found: "No data found related to your keyword.", copy: "Copy", suggestions_for_you: "Suggestions For You", emoji_suggestions: "Emoji Suggestions", symbol_suggestions: "Symbol Suggestions", type: "Type", category: "Category", emoji: "Emoji", predicted: "Predicted", search_placeholder: "Search... (e.g. smile, heart)", search_result_here: "Search results will appear here", suggestion_label: "Suggested queries" }
  };
  const t = k => { const l = getLang(); return (LANG_TEXTS[l] && LANG_TEXTS[l][k]) || LANG_TEXTS.en[k] || k; };
  const getLang = () => localStorage.getItem('selectedLang') || (navigator.language && navigator.language.startsWith('th') ? 'th' : 'en');
  const pickLang = (obj, langs) => { if (!obj || typeof obj !== 'object') return obj; for (let i=0;i<langs.length;i++) if (obj[langs[i]]) return obj[langs[i]]; for (const k in obj) return obj[k]; return ''; };

  // ---------- Utilities ----------
  function isStateEqual(a,b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    const aq = (a.q||'').trim();
    const bq = (b.q||'').trim();
    const at = (a.type||'all');
    const bt = (b.type||'all');
    const ac = (a.category||'all');
    const bc = (b.category||'all');
    return aq===bq && at===bt && ac===bc;
  }

  function parseQueryString(qs) {
    const out = {};
    if (!qs) return out;
    qs = qs.replace(/^\?/, '');
    const parts = qs.split('&');
    for (let i=0;i<parts.length;i++) {
      const p = parts[i]; if (!p) continue;
      const idx = p.indexOf('=');
      if (idx === -1) { out[decodeURIComponent(p)] = ''; }
      else { out[decodeURIComponent(p.substring(0,idx))] = decodeURIComponent(p.substring(idx+1)); }
    }
    return out;
  }
  function buildQueryString(obj) {
    const parts = [];
    for (const k in obj) {
      if (obj[k] === undefined || obj[k] === null) continue;
      parts.push(encodeURIComponent(k)+'='+encodeURIComponent(obj[k]));
    }
    return parts.length ? ('?'+parts.join('&')) : '';
  }
  function readStateFromURL() {
    const params = parseQueryString(window.location.search || '');
    return { q: params.q || '', type: params.type || 'all', category: params.category || 'all' };
  }
  function buildUrlForState(state) {
    const params = {};
    if (state.q) params.q = state.q;
    if (state.type && state.type !== 'all') params.type = state.type;
    if (state.category && state.category !== 'all') params.category = state.category;
    return buildQueryString(params);
  }

  // ---------- History commit improvements ----------
  // commitSearchState - records a real search state into history + sessionStorage
  // Behavior:
  // - If overlay transient entry exists (overlayHistoryPushed), we replace that transient entry with the committed state (history.replaceState).
  // - Otherwise we push a new history entry.
  // - In any case update lastCommittedState and append to sessionStorage log.
  function commitSearchState(state) {
    try {
      if (isStateEqual(state, lastCommittedState)) {
        // nothing changed
        return;
      }
    } catch (e) {}
    const url = buildUrlForState(state);
    try {
      if (overlayHistoryPushed) {
        // Replace transient overlay entry with committed search state
        history.replaceState(state, '', url);
        overlayHistoryPushed = false;
      } else {
        history.pushState(state, '', url);
      }
    } catch (e) {
      try { history.replaceState(state, '', url); } catch (ee) {}
      overlayHistoryPushed = false;
    }
    // Append to sessionStorage search log
    try {
      const raw = sessionStorage.getItem(SEARCH_HISTORY_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      arr.push(Object.assign({}, state, { ts: Date.now() }));
      sessionStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(arr));
    } catch (e) {}
    lastCommittedState = { q: state.q || '', type: state.type || 'all', category: state.category || 'all' };
  }

  // When overlay is closed by any method, ensure transient overlay entry is removed from history.
  // We do that by replacing it with lastCommittedState (or blank state).
  function removeTransientOverlayEntry() {
    if (!overlayHistoryPushed) return;
    try {
      const stateToRestore = lastCommittedState || { q: '', type: 'all', category: 'all' };
      history.replaceState(stateToRestore, '', buildUrlForState(stateToRestore));
    } catch (e) {}
    overlayHistoryPushed = false;
  }

  // ---------- search helpers (matching, fuzzy) ----------
  function getAllAvailableLangs(data) {
    const langs = Object.create(null);
    if (!data || !Array.isArray(data.type)) return ['en'];
    for (let i=0;i<data.type.length;i++) {
      const typeObj = data.type[i];
      if (typeof typeObj.name === 'object') for (const k in typeObj.name) langs[k]=1;
      const categories = typeObj.category || [];
      for (let j=0;j<categories.length;j++) {
        const cat = categories[j];
        if (typeof cat.name === 'object') for (const k in cat.name) langs[k]=1;
        const items = cat.data || [];
        for (let x=0;x<items.length;x++) {
          const item = items[x];
          if (typeof item.name === 'object') for (const k in item.name) langs[k]=1;
          for (const k in item) if (/_name$/.test(k) && typeof item[k] === 'object') for (const l in item[k]) langs[l]=1;
        }
      }
    }
    return Object.keys(langs);
  }

  function generateAllKeywords(data) {
    const arr = [];
    const langs = getAllAvailableLangs(data);
    if (!data || !Array.isArray(data.type)) return [];
    for (let i=0;i<data.type.length;i++) {
      const typeObj = data.type[i];
      for (let l=0;l<langs.length;l++) {
        const lang = langs[l];
        const typeName = pickLang(typeObj.name, [lang]);
        if (typeName) arr.push({ typeObj, typeName, lang, key: normalizeText(typeName), isType: true });
      }
      const categories = typeObj.category || [];
      for (let j=0;j<categories.length;j++) {
        const cat = categories[j];
        for (let l=0;l<langs.length;l++) {
          const lang = langs[l];
          const catName = pickLang(cat.name, [lang]);
          if (catName) arr.push({ typeObj, category: cat, typeName: pickLang(typeObj.name, [lang]), catName, lang, key: normalizeText(catName), isCategory: true });
        }
        const items = cat.data || [];
        for (let x=0;x<items.length;x++) {
          const item = items[x];
          for (let l=0;l<langs.length;l++) {
            const lang = langs[l];
            const itemName = pickLang(item.name, [lang]);
            if (itemName) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, [lang]), catName: pickLang(cat.name,[lang]), itemName, lang, key: normalizeText(itemName) });
          }
          for (const k in item) {
            if (/_name$/.test(k) && typeof item[k] === 'object') {
              for (let l=0;l<langs.length;l++) {
                const lang = langs[l];
                const vVal = pickLang(item[k],[lang]);
                if (vVal) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name,[lang]), catName: pickLang(cat.name,[lang]), itemName: vVal, lang, key: normalizeText(vVal) });
              }
            }
          }
          if (item.text) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'text', key: normalizeText(item.text) });
          if (item.api) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'api', key: normalizeText(item.api) });
        }
      }
    }
    return arr;
  }

  function levenshtein(a,b) {
    if (a===b) return 0;
    const al=a.length, bl=b.length;
    if (!al) return bl;
    if (!bl) return al;
    let v0 = new Uint16Array(bl+1), v1 = new Uint16Array(bl+1);
    for (let i=0;i<=bl;i++) v0[i]=i;
    for (let i=0;i<al;i++){
      v1[0]=i+1;
      for (let j=0;j<bl;j++) v1[j+1]=Math.min(v1[j]+1, v0[j+1]+1, v0[j] + (a[i]===b[j]?0:1));
      let t=v0; v0=v1; v1=t;
    }
    return v0[bl];
  }

  const computeRelevanceScore = (query,target,baseScore=100) => (!target ? baseScore : (() => {
    let s = levenshtein(query, target);
    if (target.startsWith(query)) s -= 1;
    if (target.includes(query)) s -= 0.5;
    return s;
  })());

  const keywordExactSubstringMatch = (query, allKeywords) => {
    query = normalizeText(query);
    for (let i=0;i<allKeywords.length;i++) if ((allKeywords[i].key||'').includes(query)) return true;
    return false;
  };

  // getBestKeywordMatches, smartSearch - adapted to use normalized keys
  function getBestKeywordMatches(query, allKeywords, maxCount=12, allowGuess=true) {
    if (!query) return [];
    const nq = normalizeText(query);
    if (!allowGuess && keywordExactSubstringMatch(nq, allKeywords)) return [];
    let out = [];
    for (let i=0;i<allKeywords.length;i++){
      const k = allKeywords[i];
      let s = [computeRelevanceScore(nq, k.key||'', 100)];
      if (k.isCategory && k.catName) s.push(computeRelevanceScore(nq, normalizeText(k.catName), 110));
      if (k.typeName) s.push(computeRelevanceScore(nq, normalizeText(k.typeName), 110));
      if (k.itemName) s.push(computeRelevanceScore(nq, normalizeText(k.itemName), 120));
      if (k.item) {
        if (k.item.text) s.push(computeRelevanceScore(nq, normalizeText(k.item.text), 120));
        if (k.item.api) s.push(computeRelevanceScore(nq, normalizeText(k.item.api), 125));
      }
      k._score = Math.min.apply(null, s);
      out.push(k);
    }
    out.sort((a,b) => a._score - b._score);
    let seen = new Set(), uniq=[], cnt=0;
    for (let i=0;i<out.length && cnt<maxCount;i++){
      const k = out[i];
      if (k._score > 2) break;
      const uniqKey = k.isType ? `type|${k.typeName}|${k.lang}` : k.isCategory ? `cat|${k.typeName}|${k.catName}|${k.lang}` : `item|${k.typeName}|${k.catName}|${k.item && (k.item.api||k.item.text)||''}|${k.lang}`;
      if (!seen.has(uniqKey)) { seen.add(uniqKey); uniq.push(Object.assign({}, k, { fuzzyScore: k._score })); ++cnt; }
    }
    return uniq;
  }

  function smartSearch(data, query, typeFilter, allKeywords) {
    query = normalizeText((query||'').toLowerCase().trim());
    if (!query) return [];
    let results = [], langs = getAllAvailableLangs(data);
    if (!data || !Array.isArray(data.type)) return results;

    if (query.length === 1) {
      let has=false;
      for (let i=0;i<allKeywords.length;i++) if ((allKeywords[i].key||'').includes(query)) { has=true; break; }
      if (!has) return [];
    }

    for (let i=0;i<data.type.length;i++){
      const typeObj = data.type[i];
      for (let l=0;l<langs.length;l++){
        const lang = langs[l];
        let typeLabel = pickLang(typeObj.name, [lang]);
        if (typeFilter !== 'all' && pickLang(typeObj.name,[getLang()]) !== typeFilter) continue;
        const cats = typeObj.category || [];
        for (let j=0;j<cats.length;j++){
          const cat = cats[j], catName = pickLang(cat.name, [lang]);
          const items = cat.data || [];
          for (let x=0;x<items.length;x++){
            const item = items[x];
            const tokens = [];
            if (item.name) tokens.push(normalizeText(pickLang(item.name, [lang])));
            for (const k in item) if (/_name$/.test(k) && item[k]) tokens.push(normalizeText(pickLang(item[k],[lang])));
            if (catName) tokens.push(normalizeText(catName));
            if (item.text) tokens.push(normalizeText(item.text));
            if (item.api) tokens.push(normalizeText(item.api));
            const flat = Array.from(new Set(tokens.filter(Boolean)));
            let isMatch=false;
            let minFuzz=100;
            for (let tt=0;tt<flat.length;tt++){
              const txt = flat[tt];
              if (!txt) continue;
              if (txt.includes(query)) isMatch=true;
              const qParts = query.split(' ');
              let allPartsFound=true;
              for (let qp=0; qp<qParts.length; qp++){
                if (!qParts[qp]) continue;
                if (!txt.includes(qParts[qp])) { allPartsFound=false; break; }
              }
              if (allPartsFound) isMatch=true;
              minFuzz = Math.min(minFuzz, levenshtein(query, txt));
            }
            const isFuzzy = !isMatch && minFuzz <= Math.max(2, Math.floor(query.length * 0.25));
            if (isMatch || isFuzzy) results.push({ typeObj, typeName: typeLabel, category: cat, catName, item, itemName: pickLang(item.name,[lang]), lang, fuzzy: !isMatch && isFuzzy, fuzzyScore: minFuzz });
          }
        }
      }
    }

    if (keywordExactSubstringMatch(query, allKeywords)) {
      const sub = results.filter(r => !r.fuzzy);
      return sub.length ? sub : [];
    }
    if (query.length === 1) return [];
    if (results.length) {
      let allFuzzy = results.every(r => r.fuzzy);
      if (allFuzzy) results.forEach(r => r.isPrediction = true);
      return results;
    }
    const predictionResults = getBestKeywordMatches(query, allKeywords, 10, false);
    if (!predictionResults.length) return [];
    const out = [];
    for (let i=0;i<predictionResults.length;i++){
      const s = predictionResults[i];
      if (s.isType) out.push({ typeObj: s.typeObj, typeName: s.typeName, category: (s.typeObj.category && s.typeObj.category[0]) || { name:'', data:[] }, catName: normalizeText((s.typeObj.category && s.typeObj.category[0] && s.typeObj.category[0].name) || ''), item: (((s.typeObj.category||[0])[0]||{}).data||[{}])[0] || {text:'',api:''}, itemName:'', lang:s.lang, isSuggestion:true, isPrediction:true, suggestionType:'type', suggestionKeyword:s.key, fuzzyScore:s.fuzzyScore });
      else if (s.isCategory) out.push({ typeObj: s.typeObj, typeName: s.typeName, category: s.category, catName: s.catName, item: ((s.category.data && s.category.data.length)? s.category.data[0] : {text:'',api:''}), itemName:'', lang:s.lang, isSuggestion:true, isPrediction:true, suggestionType:'category', suggestionKeyword:s.key, fuzzyScore:s.fuzzyScore });
      else out.push({ typeObj: s.typeObj, typeName: s.typeName, category: s.category, catName: s.catName, item: s.item, itemName: s.itemName, lang: s.lang, isSuggestion:true, isPrediction:true, suggestionType:'item', suggestionKeyword:s.key, fuzzyScore:s.fuzzyScore });
    }
    return out;
  }

  // ---------- UI rendering & suggestions (kept functionality) ----------
  function setBodyMarginForSearch(active) {
    const body = document.body;
    if (active) { if (body.style.marginBottom !== "60px") body.style.marginBottom = "60px"; }
    else { if (body.style.marginBottom !== "") body.style.marginBottom = ""; }
  }

  function renderResultItemHTML(res, lang) {
    let itemNames = [];
    if (res.item && res.item.name) itemNames.push(pickLang(res.item.name, [lang]));
    for (const k in (res.item||{})) if (/_name$/.test(k) && res.item[k]) itemNames.push(pickLang(res.item[k], [lang]));
    itemNames = itemNames.filter(Boolean).join(' / ');
    let typeDisplay = res.typeObj && res.typeObj.name ? pickLang(res.typeObj.name, [lang]) : "";
    if (!typeDisplay) typeDisplay = t('emoji');
    const catDisplay = (res.category && res.category.name) ? pickLang(res.category.name, [lang]) : '';
    let fuzzyHint = (res.fuzzy && res.isPrediction) ? `<div class="fuzzy-hint" style="color:#e08b35;font-size:.98em;font-weight:400;margin-bottom:4px;">${t('predicted')}</div>` : '';
    const text = res.item && res.item.text ? res.item.text : '-';
    const api = res.item && res.item.api ? res.item.api : '';
    return `<div class="result-item"><div class="result-content-area">${fuzzyHint}<div class="result-text-area"><span class="result-text">${text}</span><span class="result-api">${api}</span></div><div class="result-meta"><div><span class="result-meta-label">${t('type')}:</span><span class="result-meta-value">${typeDisplay}</span></div><div><span class="result-meta-label">${t('category')}:</span><span class="result-meta-value">${catDisplay}</span></div></div><button class="result-copy-btn" data-text="${encodeURIComponent(api||text)}">${t('copy')}</button></div></div>`;
  }

  function disconnectRenderObserver() {
    if (renderObserver) {
      try { renderObserver.disconnect(); } catch (e) {}
      renderObserver = null;
    }
    const old = document.getElementById(sentinelId);
    if (old && old.parentNode) old.parentNode.removeChild(old);
  }

  function renderNextBatch() {
    const container = document.getElementById('searchResults');
    if (!container) return;
    const lang = getLang();
    const start = currentRenderIndex;
    const end = Math.min(currentRenderIndex + renderBatchSize, currentFilteredResults.length);
    let fragment = '';
    for (let i=start;i<end;i++) fragment += renderResultItemHTML(currentFilteredResults[i], lang);
    const sentinelEl = document.getElementById(sentinelId);
    if (sentinelEl) sentinelEl.insertAdjacentHTML('beforebegin', fragment);
    else container.insertAdjacentHTML('beforeend', fragment);
    currentRenderIndex = end;
    if (currentRenderIndex >= currentFilteredResults.length) disconnectRenderObserver();
    else {
      if (!document.getElementById(sentinelId)) {
        const s = document.createElement('div'); s.id = sentinelId; s.className='search-sentinel'; s.style.cssText='width:100%;height:36px;display:block;';
        container.appendChild(s);
      }
      if (!renderObserver) {
        renderObserver = new IntersectionObserver((entries)=>{
          for (let i=0;i<entries.length;i++) if (entries[i].isIntersecting) setTimeout(()=>{ if (currentRenderIndex < currentFilteredResults.length) renderNextBatch(); }, 50);
        }, { root:null, rootMargin:'0px', threshold:0.1 });
        const sEl = document.getElementById(sentinelId);
        if (sEl) renderObserver.observe(sEl);
      }
    }
  }

  function renderResults(results, showSuggestionsIfNoResult=false) {
    const container = document.getElementById('searchResults');
    const lang = getLang();
    if (!container) return;
    let filtered = (selectedCategory !== 'all') ? results.filter(res => pickLang((res.category && res.category.name) || '', [lang]) === selectedCategory) : results.slice();
    setBodyMarginForSearch(true);
    disconnectRenderObserver();
    currentFilteredResults = [];
    currentRenderIndex = 0;
    if (!filtered.length) {
      let html = `<div class="no-result">${t('not_found')}</div>`;
      if (showSuggestionsIfNoResult) {
        html += `<div class="suggestions-title-main">${t('suggestions_for_you')}</div>`;
        html += renderSuggestionsBlock(lang, getRandomSuggestions(emojiSuggestionsCache,4), getRandomSuggestions(symbolSuggestionsCache,4));
      }
      container.innerHTML = html;
      const catFilterEl = document.getElementById('categoryFilter');
      if (catFilterEl) catFilterEl.style.display = '';
      filterCategories = [];
      updateUILanguage();
      return;
    }
    currentFilteredResults = filtered;
    currentRenderIndex = 0;
    container.innerHTML = '';
    renderNextBatch();
    if (!window._copyResultTextHandlerSet) {
      container.addEventListener('click', function(e){
        const btn = e.target.closest('.result-copy-btn');
        if (btn && btn.hasAttribute('data-text')) { e.preventDefault(); copyText(decodeURIComponent(btn.getAttribute('data-text'))); }
      });
      window._copyResultTextHandlerSet = true;
    }
    updateUILanguage();
  }

  // ---------- Suggestions UI and overlay helpers (kept behavior) ----------
  function createSuggestionBackdrop() {
    const overlay = document.getElementById(overlayContainerId);
    if (!overlay) return null;
    let bd = document.getElementById(suggestionBackdropId);
    if (bd) return bd;
    bd = document.createElement('div');
    bd.id = suggestionBackdropId;
    bd.style.cssText = 'position:absolute;left:0;top:0;right:0;bottom:0;z-index:10000;background:transparent;pointer-events:auto;';
    bd.addEventListener('pointerdown', function(ev) {
      const sugg = document.getElementById(suggestionContainerId);
      if (sugg && sugg.contains(ev.target)) return;
      ev && ev.stopPropagation && ev.stopPropagation();
      ev && ev.preventDefault && ev.preventDefault();
      hideSuggestions();
    }, { passive: true });
    overlay.insertBefore(bd, overlay.firstChild);
    return bd;
  }
  function removeSuggestionBackdrop() {
    const bd = document.getElementById(suggestionBackdropId);
    if (bd && bd.parentNode) bd.parentNode.removeChild(bd);
  }
  function ensureSuggestionContainer() {
    let c = document.getElementById(suggestionContainerId);
    const overlay = document.getElementById(overlayContainerId);
    if (!overlay) return null;
    if (!c) {
      c = document.createElement('div');
      c.id = suggestionContainerId;
      c.className = 'search-suggestions';
      c.style.cssText = 'position:relative; z-index:10001; max-height:320px; overflow:auto; background:#fff; border:1px solid #e6e9ee; box-shadow:0 8px 30px rgba(19,23,40,0.12); border-radius:10px; margin-top:8px; pointer-events:auto; -webkit-overflow-scrolling:touch; overscroll-behavior: contain;';
      overlay.appendChild(c);
      c.addEventListener('keydown', function(ev) {
        const items = Array.from(c.querySelectorAll('.suggestion-item'));
        if (!items.length) return;
        const active = document.activeElement;
        const idx = items.indexOf(active);
        if (ev.key === 'ArrowDown') { ev.preventDefault(); const next = (idx === -1) ? items[0] : items[Math.min(items.length-1, idx+1)]; next && next.focus && next.focus(); }
        else if (ev.key === 'ArrowUp') { ev.preventDefault(); const prev = (idx === -1) ? items[items.length-1] : items[Math.max(0, idx-1)]; prev && prev.focus && prev.focus(); }
        else if (ev.key === 'Enter') { ev.preventDefault(); if (active && active.classList && active.classList.contains('suggestion-item')) active.click && active.click(); }
        else if (ev.key === 'Escape') { ev.preventDefault(); hideSuggestions(); }
      });
      c.addEventListener('click', function(ev) {
        const it = ev.target.closest('.suggestion-item');
        if (!it) return;
        ev && ev.stopPropagation && ev.stopPropagation();
        ev && ev.preventDefault && ev.preventDefault();
        let val = it.getAttribute('data-val') || '';
        try { val = decodeURIComponent(val); } catch (e) {}
        const inputEl = document.getElementById('searchInput');
        if (inputEl) inputEl.value = val;
        hideSuggestions();
        doSearch(null, false);
      });
    }
    return c;
  }
  function hideSuggestions() {
    if (ignoreNextHideSuggestions) return;
    const c = document.getElementById(suggestionContainerId);
    if (c) c.style.display = 'none';
    removeSuggestionBackdrop();
  }

  function renderQuerySuggestions(query) {
    if (!overlayOpen) openSearchOverlay();
    const container = ensureSuggestionContainer();
    if (!container) return;
    if (!query || !query.trim()) { container.innerHTML = ''; container.style.display = 'none'; removeSuggestionBackdrop(); return; }
    const q = normalizeText(query);
    const matches = getBestKeywordMatches(q, allKeywordsCache, suggestionMax, true);
    if (!matches || !matches.length) { container.innerHTML = ''; container.style.display = 'none'; removeSuggestionBackdrop(); return; }
    const lang = getLang();
    let html = `<div class="suggestions-head" style="padding:8px 10px;font-weight:600;color:#333;">${t('suggestion_label')}</div>`;
    for (let i=0;i<matches.length;i++){
      const s = matches[i];
      let display='', meta='';
      if (s.isType) { display = s.typeName || s.key; meta = t('type'); }
      else if (s.isCategory) { display = s.catName || s.key; meta = s.typeName || ''; }
      else { display = s.itemName || (s.item && (s.item.text || s.item.api)) || s.key; meta = s.catName || s.typeName || ''; }
      const safeDisplay = (display||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      const safeMeta = (meta||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      const val = s.key || display || '';
      html += `<div class="suggestion-item" role="option" tabindex="0" data-val="${encodeURIComponent(val)}" style="padding:8px 10px;border-top:1px solid #f4f6fa;cursor:pointer;display:flex;justify-content:space-between;align-items:center;"><div style="min-width:0"><div style="font-weight:600;color:#1f3b57;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${safeDisplay}</div><div class="suggestion-meta" style="font-size:.92em;color:#8b93a7;margin-top:3px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${safeMeta}</div></div></div>`;
    }
    container.innerHTML = html;
    container.style.display = 'block';
    createSuggestionBackdrop();
    const inputEl = document.getElementById('searchInput');
    if (inputEl) {
      inputEl.onkeydown = function(e) {
        if (e.key === 'ArrowDown') { e.preventDefault(); const first = container.querySelector('.suggestion-item'); if (first) first.focus && first.focus(); }
        else if (e.key === 'Escape') hideSuggestions();
      };
    }
  }

  // ---------- Overlay open/close with precise history sync ----------
  function openSearchOverlay() {
    if (overlayOpen) return;
    const wrapper = document.querySelector('.search-input-wrapper');
    if (!wrapper) return;
    originalInputParent = wrapper.parentNode;
    originalInputNextSibling = wrapper.nextSibling;
    const inputEl = document.getElementById('searchInput');
    preOverlayState = { q: inputEl ? (inputEl.value || '') : '', type: selectedType || 'all', category: selectedCategory || 'all' };

    // create backdrop
    let backdrop = document.getElementById(overlayBackdropId);
    if (!backdrop) {
      backdrop = document.createElement('div');
      backdrop.id = overlayBackdropId;
      backdrop.className = 'search-overlay-backdrop';
      backdrop.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(12,14,18,0.48);z-index:9998;backdrop-filter:blur(4px);';
      document.body.appendChild(backdrop);
    }
    // create overlay container
    let overlay = document.getElementById(overlayContainerId);
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = overlayContainerId;
      overlay.className = 'search-overlay search-overlay-open';
      // overlay acts as layout layer; children accept pointer events
      overlay.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:24px 16px 16px;pointer-events:none;';
      document.body.appendChild(overlay);
    } else {
      overlay.innerHTML = '';
    }

    // move wrapper
    wrapper.classList.add('overlay-elevated');
    wrapper.style.width = '100%';
    wrapper.style.maxWidth = '720px';
    wrapper.style.marginTop = '6px';
    wrapper.style.pointerEvents = 'auto';
    overlay.appendChild(wrapper);

    ensureSuggestionContainer();

    if (inputEl) setTimeout(() => { try { inputEl.focus(); inputEl.select && inputEl.select(); } catch (e) {} }, 20);

    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';

    // push a transient overlay history entry so Back can close it predictably
    try {
      history.pushState({ __overlay: true, __overlay_from: lastCommittedState || null }, '', window.location.href);
      overlayHistoryPushed = true;
    } catch (e) { overlayHistoryPushed = false; }

    // guard backdrop click: avoid blur race
    backdrop.onclick = function(ev) {
      ignoreNextHideSuggestions = true;
      setTimeout(()=>{ ignoreNextHideSuggestions = false; }, 300);
      ev && ev.stopPropagation && ev.stopPropagation();
      handleBackdropClickAction();
    };

    document.addEventListener('keydown', overlayEscHandler);
    overlayOpen = true;

    // auto-run search only when there's text and we want auto-run (keeps overlay open)
    const q = inputEl ? (inputEl.value || '').trim() : '';
    if (q) {
      const candidateState = { q: q, type: selectedType || 'all', category: selectedCategory || 'all' };
      const shouldPush = !isStateEqual(candidateState, lastCommittedState);
      setTimeout(()=>{ doSearch(null, !shouldPush, { keepOverlay:true }); }, 40);
    }
  }

  function overlayEscHandler(e) {
    if (e.key === 'Escape') {
      if (preOverlayState) {
        const inp = document.getElementById('searchInput');
        if (inp) inp.value = preOverlayState.q || '';
        selectedType = preOverlayState.type || 'all';
        selectedCategory = preOverlayState.category || 'all';
      }
      closeSearchOverlay();
    }
  }

  // Centralized backdrop action logic (decides whether to commit a search or just close)
  function handleBackdropClickAction() {
    const inp = document.getElementById('searchInput');
    const curr = inp ? (inp.value || '') : '';
    // 1) If unchanged from preOverlayState -> close overlay without recording
    if (preOverlayState && typeof preOverlayState.q !== 'undefined' && curr === (preOverlayState.q || '')) {
      closeSearchOverlay();
      return;
    }
    // 2) If current candidate equals lastCommittedState -> nothing to commit -> close overlay
    const candidate = { q: curr, type: selectedType || 'all', category: 'all' };
    if (isStateEqual(candidate, lastCommittedState)) {
      closeSearchOverlay();
      return;
    }
    // 3) Otherwise, perform search and record commit (doSearch will call commitSearchState)
    hideSuggestions();
    doSearch(null, false);
    try { inp && inp.blur(); } catch (e) {}
  }

  function closeSearchOverlay() {
    if (!overlayOpen) return;
    const wrapper = document.querySelector('.search-input-wrapper');
    if (!wrapper) return;

    wrapper.classList.remove('overlay-elevated');
    wrapper.style.width = '';
    wrapper.style.maxWidth = '';
    wrapper.style.marginTop = '';
    wrapper.style.pointerEvents = '';
    if (originalInputParent) {
      if (originalInputNextSibling) originalInputParent.insertBefore(wrapper, originalInputNextSibling);
      else originalInputParent.appendChild(wrapper);
    }

    const sc = document.getElementById(suggestionContainerId);
    if (sc && sc.parentNode) sc.parentNode.removeChild(sc);
    removeSuggestionBackdrop();

    const overlay = document.getElementById(overlayContainerId);
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
    const backdrop = document.getElementById(overlayBackdropId);
    if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);

    document.documentElement.style.overflow = '';
    document.body.style.overflow = '';

    document.removeEventListener('keydown', overlayEscHandler);
    overlayOpen = false;

    // Remove transient entry if present by replacing with lastCommittedState
    removeTransientOverlayEntry();
  }

  // ---------- doSearch: only commit when explicit and there is a real change ----------
  // doSearch(e, preventPush, options)
  // - preventPush: if true, do not push/commit to history (e.g., when auto-running on overlay open and we decide not to commit)
  // - options.keepOverlay: if true, keep overlay open after auto-run
  function doSearch(e, preventPush, options) {
    if (e) e.preventDefault();
    options = options || {};
    const qEl = document.getElementById('searchInput');
    const q = qEl ? qEl.value : '';
    selectedType = document.getElementById('typeFilter') ? document.getElementById('typeFilter').value : selectedType;
    selectedCategory = 'all';
    hideSuggestions();

    if (!q.trim()) {
      setBodyMarginForSearch(false);
      const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
      const sr = document.getElementById('searchResults');
      if (sr) sr.innerHTML = placeholderHtml;
      setupCategoryFilter([], 'all');
      filterCategories = [];
      updateUILanguage();
      const stateCleared = { q: '', type: 'all', category: 'all' };
      if (!preventPush && !suppressHistoryPush && !isStateEqual(stateCleared, lastCommittedState)) {
        // commit cleared state as a real search
        commitSearchState(stateCleared);
      }
      if (overlayOpen && !options.keepOverlay) closeSearchOverlay();
      return;
    }

    currentResults = smartSearch(apiData, q, selectedType, allKeywordsCache);
    filterCategories = extractResultCategories(currentResults);
    setupCategoryFilter(filterCategories, 'all');

    const stateObj = { q: q, type: selectedType || 'all', category: 'all' };
    const willCommit = (!preventPush && !suppressHistoryPush && !isStateEqual(stateObj, lastCommittedState));
    if (willCommit) {
      // commit using robust commitSearchState (replaces transient overlay entry if any)
      commitSearchState(stateObj);
    }

    renderResults(currentResults, currentResults.length === 0);
    updateUILanguage();

    if (overlayOpen && !options.keepOverlay) closeSearchOverlay();
  }

  // ---------- small UI helpers ----------
  function setupTypeFilter(selected='all') {
    const typeFilter = document.getElementById('typeFilter');
    if (!typeFilter) return;
    let buf = [`<option value="all">${t('all_types')}</option>`];
    if (apiData && Array.isArray(apiData.type)) {
      const lang = getLang();
      for (let i=0;i<apiData.type.length;i++) {
        let label = pickLang(apiData.type[i].name, [lang]);
        buf.push(`<option value="${label}">${label}</option>`);
      }
    }
    typeFilter.innerHTML = buf.join('');
    typeFilter.value = selected;
  }

  function setupCategoryFilter(categories, selected='all') {
    const catFilter = document.getElementById('categoryFilter');
    if (!catFilter) return;
    let buf = [`<option value="all">${t('all_categories')}</option>`];
    for (let i=0;i<categories.length;i++){
      const { key, displayName } = categories[i];
      buf.push(`<option value="${key}">${displayName}</option>`);
    }
    catFilter.innerHTML = buf.join('');
    catFilter.style.display = '';
    catFilter.value = selected;
  }

  function getRandomSuggestions(arr, count=5) {
    if (!arr || !arr.length) return [];
    let n = arr.length, out = [], idx;
    const pool = arr.slice();
    for (let i=0;i<count && n>0;i++,n--){
      idx = (Math.random()*n)|0;
      out.push(pool[idx]);
      pool[idx] = pool[n-1];
    }
    return out;
  }

  function extractResultCategories(results) {
    const lang = getLang();
    let categories = [], seen = Object.create(null);
    for (let i=0;i<results.length;i++) {
      const cat = results[i].category || { name: '' }, key = pickLang(cat.name,[lang]) || '';
      const displayName = key;
      if (!seen[key]) { seen[key]=1; categories.push({ key, displayName }); }
    }
    return categories;
  }

  function showCopyToast(msg) {
    const toast = document.createElement('div');
    toast.className = 'copy-toast-message';
    toast.textContent = msg;
    const area = document.getElementById('copyToast') || document.body;
    area.appendChild(toast);
    setTimeout(()=>{ toast.style.opacity='0'; toast.style.transform='translateY(-10px)'; setTimeout(()=>toast.remove(),250); }, 1400);
  }
  async function copyText(text) {
    try { await navigator.clipboard.writeText(text); showCopyToast(t('copy') + 'แล้ว'); } catch { showCopyToast('ไม่สามารถ' + t('copy') + 'ได้'); }
  }

  // ---------- startup & wiring ----------
  window.addEventListener('popstate', function(e){
    const state = e.state || {};
    // If overlay open and popped state does NOT indicate overlay -> Back closed overlay
    if (overlayOpen && !state.__overlay) {
      if (preOverlayState) {
        const inp = document.getElementById('searchInput');
        if (inp) inp.value = preOverlayState.q || '';
        selectedType = preOverlayState.type || 'all';
        selectedCategory = preOverlayState.category || 'all';
      }
      const wrapper = document.querySelector('.search-input-wrapper');
      if (wrapper && originalInputParent) {
        wrapper.classList.remove('overlay-elevated');
        wrapper.style.width = ''; wrapper.style.maxWidth=''; wrapper.style.marginTop='';
        if (originalInputNextSibling) originalInputParent.insertBefore(wrapper, originalInputNextSibling);
        else originalInputParent.appendChild(wrapper);
      }
      const sc = document.getElementById(suggestionContainerId);
      if (sc && sc.parentNode) sc.parentNode.removeChild(sc);
      removeSuggestionBackdrop();
      const overlay = document.getElementById(overlayContainerId);
      if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
      const backdrop = document.getElementById(overlayBackdropId);
      if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);
      document.documentElement.style.overflow=''; document.body.style.overflow='';
      document.removeEventListener('keydown', overlayEscHandler);
      overlayOpen = false; overlayHistoryPushed = false; preOverlayState = null;
      return;
    }

    // Normal restore: restore search state from history (committed search)
    const st = (e.state && typeof e.state === 'object') ? e.state : readStateFromURL();
    if (st && st.q !== undefined) {
      suppressHistoryPush = true;
      try { restoreUIState({ q: st.q || '', type: st.type || 'all', category: st.category || 'all' }); }
      finally { suppressHistoryPush = false; }
    }
  });

  // Click outside suggestions hides them when overlay is not open
  document.addEventListener('click', function(ev) {
    const container = document.getElementById(suggestionContainerId);
    const input = document.getElementById('searchInput');
    if (!container) return;
    if (overlayOpen) return;
    if (ev.target === input || container.contains(ev.target)) return;
    hideSuggestions();
  }, false);

  // pointerdown capture for outside overlay clicks -> reliable backdrop detection
  document.addEventListener('pointerdown', function(ev) {
    if (!overlayOpen) return;
    if (ev.target.closest('#' + overlayContainerId)) return;
    ignoreNextHideSuggestions = true;
    setTimeout(()=>{ ignoreNextHideSuggestions = false; }, 300);
    handleBackdropClickAction();
  }, true);

  // initial load
  fetch('/assets/json/api-database.min.json').then(res=>res.json()).then(data=>{
    apiData = data;
    allKeywordsCache = generateAllKeywords(apiData);
    prepareSuggestionCaches(apiData);
    setupTypeFilter('all');
    setupMobileSelectEnter();
    setupAutoSearchInput();
    setupCategoryFilter([], 'all');
    setBodyMarginForSearch(false);
    const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
    const sr = document.getElementById('searchResults');
    if (sr) sr.innerHTML = placeholderHtml;
    updateUILanguage();

    // Initialize lastCommittedState from history or sessionStorage
    try {
      const hs = window.history && window.history.state;
      if (hs && typeof hs === 'object' && (hs.q !== undefined)) {
        lastCommittedState = { q: hs.q || '', type: hs.type || 'all', category: hs.category || 'all' };
      } else {
        const raw = sessionStorage.getItem(SEARCH_HISTORY_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        if (arr && arr.length) {
          const last = arr[arr.length - 1];
          lastCommittedState = { q: last.q || '', type: last.type || 'all', category: last.category || 'all' };
        } else lastCommittedState = null;
      }
    } catch (e) { lastCommittedState = null; }

    // Restore initial URL search if present (without double-push)
    const initial = readStateFromURL();
    if (initial && initial.q) {
      suppressHistoryPush = true;
      try {
        const input = document.getElementById('searchInput');
        if (input) input.value = initial.q;
        selectedType = initial.type || 'all';
        selectedCategory = initial.category || 'all';
        setupTypeFilter(selectedType);
        doSearch(null, true);
        try { history.replaceState({ q: initial.q, type: selectedType, category: selectedCategory }, '', buildUrlForState(initial)); } catch (e) {}
        lastCommittedState = { q: initial.q || '', type: selectedType || 'all', category: selectedCategory || 'all' };
      } finally { suppressHistoryPush = false; }
    } else {
      try { history.replaceState({ q: '', type: 'all', category: 'all' }, '', window.location.pathname); } catch (e) {}
      lastCommittedState = { q: '', type: 'all', category: 'all' };
    }
  }).catch(err => console.error('Failed to load api database', err));

  // form/input wiring
  const formEl = document.getElementById('searchForm');
  if (formEl) formEl.addEventListener('submit', e => { e.preventDefault(); doSearch(); closeMobileKeyboard(); });
  const inputEl = document.getElementById('searchInput');
  if (inputEl) inputEl.addEventListener('keydown', function(e){ if (e.key === 'Enter') { e.preventDefault(); doSearch(); closeMobileKeyboard(); } });

  // helpers implemented earlier but defined as small functions to keep file complete:
  function prepareSuggestionCaches(data) {
    emojiSuggestionsCache = []; symbolSuggestionsCache = [];
    if (!data || !Array.isArray(data.type)) return;
    const langs = getAllAvailableLangs(data);
    for (let i=0;i<data.type.length;i++){
      const typeObj = data.type[i], typeEn = (pickLang(typeObj.name, ["en"]) || '').toLowerCase();
      const categories = typeObj.category || [];
      for (let j=0;j<categories.length;j++){
        const cat = categories[j], items = cat.data || [];
        for (let x=0;x<items.length;x++){
          const item = items[x];
          if (typeEn === "emoji") emojiSuggestionsCache.push({ text: item.text, api: item.api, category: cat, typeObj });
          else if (typeEn === "symbol") symbolSuggestionsCache.push({ text: item.text, api: item.api, category: cat, typeObj });
        }
      }
    }
  }
  function setupMobileSelectEnter() {
    ['typeFilter','categoryFilter'].forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      el.onchange = () => (id==='typeFilter' ? onTypeChange() : onCategoryChange());
      el.onkeyup = function(e){ if (e.key === 'Enter') (id==='typeFilter' ? onTypeChange() : onCategoryChange()); };
    });
  }
  function setupAutoSearchInput() {
    const input = document.getElementById('searchInput');
    if (!input) return;
    input.setAttribute('enterkeyhint','search');
    input.oninput = function(){ clearTimeout(debounceTimeout); debounceTimeout = setTimeout(()=>{ renderQuerySuggestions(this.value); }, 120); };
    input.onkeydown = function(e){
      if (e.key === 'Enter') { e.preventDefault(); hideSuggestions(); doSearch(); closeMobileKeyboard(); }
      else if (e.key === 'ArrowDown') { const container = document.getElementById(suggestionContainerId); if (container) { const first = container.querySelector('.suggestion-item'); if (first) first.focus && first.focus(); } }
    };
    input.addEventListener('blur', function(){ if (ignoreNextHideSuggestions) return; setTimeout(hideSuggestions, 200); });
    input.addEventListener('focus', function(){ openSearchOverlay(); });
    input.addEventListener('click', function(){ openSearchOverlay(); });
  }
  function updateUILanguage() {
    const input = document.getElementById('searchInput');
    if (input && input.placeholder !== t('search_placeholder')) input.placeholder = t('search_placeholder');
    const filterGroupLabels = document.querySelectorAll('.search-filters-panel .filter-group-label');
    if (filterGroupLabels.length>0 && filterGroupLabels[0].textContent !== t('type')) filterGroupLabels[0].textContent = t('type');
    if (filterGroupLabels.length>1 && filterGroupLabels[1].textContent !== t('category')) filterGroupLabels[1].textContent = t('category');
  }
  function onTypeChange(){ selectedType = document.getElementById('typeFilter').value; doSearch(); }
  function onCategoryChange(){ selectedCategory = document.getElementById('categoryFilter').value; renderResults(currentResults,false); updateUILanguage(); }
  function closeMobileKeyboard(){ const input = document.getElementById('searchInput'); if (input && document.activeElement === input) input.blur(); }
  function renderSuggestionsBlock(lang, emojis=[], symbols=[]) {
    let html = '';
    if (emojis.length) { html += `<div class="suggestions-head">${t('emoji_suggestions')}</div>`; for (let i=0;i<emojis.length;i++) html += renderSuggestionItemWithRealCategory(emojis[i], lang); }
    if (symbols.length) { html += `<div class="suggestions-head">${t('symbol_suggestions')}</div>`; for (let i=0;i<symbols.length;i++) html += renderSuggestionItemWithRealCategory(symbols[i], lang); }
    return `<div class="suggestions-block-list">${html}</div>`;
  }
  function renderSuggestionItemWithRealCategory(obj, lang) {
    const typeLabel = t('type'), catLabel = t('category');
    let catName = obj.category ? (pickLang(obj.category.name, [lang]) || obj.category.name || "") : '';
    let typeDisplay = obj.typeObj ? (pickLang(obj.typeObj.name, [lang]) || obj.typeObj.name || "") : '';
    if (!typeDisplay) typeDisplay = t('emoji');
    const text = obj.text || '-';
    const api = obj.api || '';
    return `<div class="result-item"><div class="result-content-area"><div class="result-text-area"><span class="result-text">${text}</span><span class="result-api">${api}</span></div><div class="result-meta"><div><span class="result-meta-label">${typeLabel}:</span><span class="result-meta-value">${typeDisplay}</span></div><div><span class="result-meta-label">${catLabel}:</span><span class="result-meta-value">${catName}</span></div></div><button class="result-copy-btn" data-text="${encodeURIComponent(api||text)}">${t('copy')}</button></div></div>`;
  }

  // Expose minimal debug functions to window for testing (optional)
  window.__searchEngineDebug = {
    getLastCommittedState: () => lastCommittedState,
    getOverlayHistoryPushed: () => overlayHistoryPushed,
    getSessionHistory: () => { try { return JSON.parse(sessionStorage.getItem(SEARCH_HISTORY_KEY) || '[]'); } catch(e){return[];} }
  };

  // End of IIFE
})();