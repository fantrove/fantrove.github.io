// ส่วนที่ 1: Instant Loading Overlay

(function showInstantLoadingOverlay() {
    // สร้าง overlay container
    const overlay = document.createElement('div');
    overlay.id = 'instant-loading-overlay';
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100vw';
    overlay.style.height = '100vh';
    overlay.style.background = 'rgba(255,255,255,0.94)';
    overlay.style.zIndex = '2147483647';
    overlay.style.display = 'flex';
    overlay.style.flexDirection = 'column';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';
    overlay.style.transition = 'opacity 0.36s cubic-bezier(.7,0,.7,1)';
    overlay.style.opacity = '1';
    
    // Spinner styles (เหมือน ContentLoadingManager)
    const style = document.createElement('style');
    style.textContent = `
        #instant-loading-overlay .content-loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            animation: content-loading-fade-in 0.3s ease-in;
        }
        #instant-loading-overlay .spinner-svg {
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #instant-loading-overlay .loading-message {
            font-size: 1.22rem;
            color: #2196f3;
            text-align: center;
            margin-top: 10px;
            font-weight: 500;
            letter-spacing: 0.04em;
            opacity: 0.92;
        }
        @keyframes content-loading-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes instant-spinner-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        #instant-loading-overlay .spinner-svg-fg {
            stroke: #4285f4;
            stroke-width: 6;
            stroke-linecap: round;
            stroke-dasharray: 90 125;
            animation: instant-spinner-rotate 1s linear infinite;
        }
        #instant-loading-overlay .spinner-svg-bg {
            stroke: #eee;
            stroke-width: 6;
        }
    `;
    document.head.appendChild(style);
    
    // Overlay inner HTML
    overlay.innerHTML = `
        <div class="content-loading-spinner">
            <div class="spinner-svg" aria-label="loading">
                <svg width="48" height="48" viewBox="0 0 48 48" focusable="false">
                    <circle
                        class="spinner-svg-bg"
                        cx="24" cy="24" r="20"
                        fill="none"
                    />
                    <circle
                        class="spinner-svg-fg"
                        cx="24" cy="24" r="20"
                        fill="none"
                    />
                </svg>
            </div>
            <div class="loading-message">
                ${(localStorage.getItem('selectedLang') || 'en') === 'th'
                    ? 'กำลังโหลดเนื้อหา...'
                    : 'Loading content...'}
            </div>
        </div>
    `;
    document.body.appendChild(overlay);
    
    // ลบ overlay เมื่อเนื้อหาพร้อม (function สำหรับเรียกจากส่วนอื่น)
    let overlayRemoved = false;
    window.__removeInstantLoadingOverlay = function() {
        if (overlayRemoved) return;
        overlayRemoved = true;
        if (overlay) {
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';
            setTimeout(() => {
                if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
                if (style.parentNode) style.parentNode.removeChild(style);
            }, 400);
        }
    };
    window.__instantLoadingOverlayShown = true;
})();

// ส่วนที่ 2: Element & DOM Initialization

// ฟังก์ชันสำหรับสร้างหรือหา element ใน DOM ถ้ายังไม่มีให้สร้าง
function ensureElement(selector, tag = 'div', id = '') {
    let el = document.querySelector(selector);
    if (!el) {
        el = document.createElement(tag);
        if (id) el.id = id;
        // ใส่ใน body ถ้ายังไม่มี
        document.body.appendChild(el);
    }
    return el;
}

// สร้าง elements หลักที่ระบบต้องใช้
const header = ensureElement('header', 'header');
const navList = ensureElement('#nav-list', 'ul', 'nav-list');
const subButtonsContainer = ensureElement('#sub-buttons-container', 'div', 'sub-buttons-container');
const contentLoading = ensureElement('#content-loading', 'div', 'content-loading');
const logo = ensureElement('.logo', 'div', 'logo');

// เก็บ elements ลง object สำหรับใช้ในส่วนอื่น
window._headerV2_elements = {
    header,
    navList,
    subButtonsContainer,
    contentLoading,
    logo
    // navButtons จะสร้างหรือ query ในขั้นตอน render ปุ่มหลัก
};

// ส่วนที่ 3: Utils & Notification/Error System

// Notification utility
function showNotification(message, type = 'info', options = {}) {
    const lang = localStorage.getItem('selectedLang') || 'en';
    const messages = {
        th: {
            success: '✨ สำเร็จ!',
            error: '❌ ข้อผิดพลาด',
            warning: '⚠️ คำเตือน',
            info: 'ℹ️ ข้อมูล',
            loading: '⌛ กำลังโหลด'
        },
        en: {
            success: '✨ Success!',
            error: '❌ Error',
            warning: '⚠️ Warning',
            info: 'ℹ️ Information',
            loading: '⌛ Loading'
        }
    };
    try {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.setAttribute('data-timestamp', Date.now());
        
        // Icon
        const icon = document.createElement('div');
        icon.className = 'notification-icon';
        icon.innerHTML = type === 'success' ? '✓' :
            type === 'error' ? '✕' :
            type === 'warning' ? '⚠' :
            type === 'loading' ? '⌛' : 'ℹ';
        
        // Message content
        const messageContainer = document.createElement('div');
        messageContainer.className = 'notification-message-container';
        messageContainer.innerHTML = `
            <div class="notification-title">${messages[lang][type]}</div>
            <div class="notification-content">${message}</div>
        `;
        
        // Close button
        if (options.dismissible !== false) {
            const closeButton = document.createElement('button');
            closeButton.className = 'notification-close';
            closeButton.innerHTML = '×';
            closeButton.onclick = () => {
                notification.style.animation = 'slideOut 0.3s ease forwards';
                setTimeout(() => notification.remove(), 300);
            };
            notification.appendChild(closeButton);
        }
        
        notification.appendChild(icon);
        notification.appendChild(messageContainer);
        
        // Add styles if not exist
        if (!document.querySelector('#notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
                .notification {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 16px;
                    border-radius: 12px;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-20px);
                    animation: slideIn 0.3s ease forwards;
                    max-width: 400px;
                    backdrop-filter: blur(10px);
                    color: white;
                }
                .notification-success { background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); }
                .notification-error { background: linear-gradient(135deg, #f44336 0%, #e53935 100%); }
                .notification-warning { background: linear-gradient(135deg, #ff9800 0%, #fb8c00 100%); }
                .notification-info { background: linear-gradient(135deg, #2196f3 0%, #1e88e5 100%); }
                .notification-loading { background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%); }
                .notification-icon { background: rgba(255,255,255,0.2); width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; animation: scaleIn 0.3s ease forwards; }
                .notification-message-container { flex: 1; }
                .notification-title { font-size: 16px; font-weight: 600; margin-bottom: 4px; }
                .notification-content { font-size: 14px; opacity: 0.9; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
                .notification-close { background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; opacity: 0.8; transition: opacity 0.2s; }
                .notification-close:hover { opacity: 1; }
                @keyframes slideIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
                @keyframes scaleIn { from { transform: scale(0); } to { transform: scale(1); } }
                @keyframes slideOut { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-20px); } }
                .notification-loading .notification-icon { animation: spin 1s linear infinite; }
                @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
            `;
            document.head.appendChild(style);
        }
        
        document.body.appendChild(notification);
        
        // Auto remove if not loading
        if (type !== 'loading' && options.duration !== Infinity) {
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease forwards';
                setTimeout(() => { notification.remove(); }, 300);
            }, options.duration || 3000);
        }
        return notification;
    } catch (error) {
        console.error('Error showing notification:', error);
    }
}

// Error Manager
class ErrorManager {
    constructor() {
        this.errorStates = new Map();
        this.timeouts = new Map();
    }
    isValidError(error) {
        return error && (
            error instanceof Error ||
            error.message ||
            typeof error === 'string'
        );
    }
    isDuplicateError(errorKey, message) {
        const existingError = this.errorStates.get(errorKey);
        return existingError && existingError.message === message;
    }
    showError(errorKey, error, options = {}) {
        if (!this.isValidError(error)) return;
        const message = error.message || error.toString();
        if (this.isDuplicateError(errorKey, message)) return;
        if (this.timeouts.has(errorKey)) clearTimeout(this.timeouts.get(errorKey));
        this.errorStates.set(errorKey, { message, timestamp: Date.now(), type: options.type || 'error' });
        showNotification(message, options.type || 'error', {
            duration: options.duration || 3000,
            position: options.position || 'top',
            dismissible: options.dismissible !== false
        });
        const timeout = setTimeout(() => {
            this.errorStates.delete(errorKey);
            this.timeouts.delete(errorKey);
        }, options.duration || 3000);
        this.timeouts.set(errorKey, timeout);
    }
    clearErrors() {
        this.errorStates.clear();
        this.timeouts.forEach(clearTimeout);
        this.timeouts.clear();
    }
}
window._headerV2_errorManager = new ErrorManager();

// Utils
window._headerV2_utils = {
    debounce(func, wait = 250) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    },
    throttle(func, limit = 100) {
        let inThrottle;
        return (...args) => {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    },
    isOnline() {
        return navigator.onLine;
    },
    showNotification,
    errorManager: window._headerV2_errorManager
};

// ส่วนที่ 4: DataManager (โหลด config, database, category group, api content)
// ใช้งาน cache ในตัว, รองรับ fetchWithRetry

window._headerV2_dataManager = {
    constants: {
        FETCH_TIMEOUT: 1000, // ultra-low for network, but rarely used
        RETRY_DELAY: 200,
        MAX_RETRIES: 0, // don't wait to retry
        CACHE_DURATION: 2 * 60 * 60 * 1000, // 2 hours memory cache
        API_DATABASE_PATH: '/assets/json/api-database.min.json',
        BUTTONS_CONFIG_PATH: '/assets/json/buttons.min.json'
    },
    cache: new Map(),
    apiCache: null,
    apiCacheTimestamp: 0,
    _dbPromise: null,
    _jsonDbIndex: null,
    _jsonDbIndexReady: false,
    _jsonDbIndexPromise: null,

    // IndexedDB helpers (async persistent cache, but only used if not in memory)
    _openIndexedDB() {
        if (this._dbPromise) return this._dbPromise;
        this._dbPromise = new Promise((resolve, reject) => {
            const req = indexedDB.open('HeaderV2DB', 5);
            req.onupgradeneeded = e => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('json')) db.createObjectStore('json');
            };
            req.onsuccess = e => resolve(e.target.result);
            req.onerror = e => reject(e.target.error);
        });
        return this._dbPromise;
    },
    async _getFromIndexedDB(key) {
        try {
            const db = await this._openIndexedDB();
            return await new Promise((resolve, reject) => {
                const tx = db.transaction('json', 'readonly');
                const store = tx.objectStore('json');
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => reject(req.error);
            });
        } catch { return null; }
    },
    async _setToIndexedDB(key, data) {
        try {
            const db = await this._openIndexedDB();
            await new Promise((resolve, reject) => {
                const tx = db.transaction('json', 'readwrite');
                const store = tx.objectStore('json');
                const req = store.put(data, key);
                req.onsuccess = () => resolve();
                req.onerror = () => reject(req.error);
            });
        } catch {}
    },

    // Super-fast in-memory cache
    getCached(key) {
        const cached = this.cache.get(key);
        if (!cached) return null;
        if (Date.now() > cached.expiry) {
            this.cache.delete(key);
            return null;
        }
        return cached.data;
    },
    setCache(key, data, expiry = this.constants.CACHE_DURATION) {
        this.cache.set(key, { data, expiry: Date.now() + expiry });
    },
    clearCache() {
        this.cache.clear();
        this.apiCache = null;
        this.apiCacheTimestamp = 0;
        this._jsonDbIndex = null;
        this._jsonDbIndexReady = false;
        this._jsonDbIndexPromise = null;
    },

    // Aggressive prefetch & memory warmup on first usage
    _warmupPromise: null,
    async _warmup() {
        if (this._warmupPromise) return this._warmupPromise;
        // Prefetch and index both DBs ASAP in background
        this._warmupPromise = Promise.all([
            this.fetchWithRetry(this.constants.API_DATABASE_PATH).catch(()=>{}),
            this.fetchWithRetry(this.constants.BUTTONS_CONFIG_PATH).catch(()=>{})
        ]);
        return this._warmupPromise;
    },

    // fetch JSON: memory first, then idb (both sync, promise.any), fallback to network (lowest priority)
    async fetchWithRetry(url, options = {}) {
        const key = `${url}-${JSON.stringify(options)}`;
        const cached = this.getCached(key);
        if (cached) return cached;
        // Race memory, IndexedDB, and network: whichever wins first (target <20ms if warm)
        return await Promise.any([
            (async()=>{ // idb (but only if not already in memory)
                const dbData = await this._getFromIndexedDB(key);
                if (dbData) {
                    this.setCache(key, dbData);
                    return dbData;
                }
                throw new Error('no idb');
            })(),
            (async()=>{ // network (should be rare)
                let lastError;
                try {
                    if (!window._headerV2_utils.isOnline()) throw new Error('Offline');
                    const controller = new AbortController();
                    const fetchPromise = fetch(url, {
                        ...options,
                        headers: { 'Content-Type': 'application/json', ...options.headers },
                        signal: controller.signal,
                        cache: "force-cache"
                    });
                    const timeoutId = setTimeout(() => controller.abort(), this.constants.FETCH_TIMEOUT);
                    const response = await fetchPromise;
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error(`Fetch error: ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    if (options.cache !== false) {
                        this.setCache(key, data);
                        this._setToIndexedDB(key, data);
                    }
                    return data;
                } catch (err) {
                    lastError = err;
                }
                window._headerV2_utils.errorManager.showError(key, lastError, {
                    duration: 1000,
                    type: 'error',
                    dismissible: true,
                    position: 'top-right'
                });
                throw lastError;
            })()
        ]).catch(()=>{ // fallback: network forced
            return fetch(url, {
                ...options,
                headers: { 'Content-Type': 'application/json', ...options.headers },
                cache: "reload"
            }).then(r=>r.json());
        });
    },

    async loadApiDatabase() {
        this._warmup();
        // 1. memory
        if (this.apiCache && Date.now() - this.apiCacheTimestamp < this.constants.CACHE_DURATION) {
            if (!this._jsonDbIndexReady) this._buildJsonDbIndex(this.apiCache);
            return this.apiCache;
        }
        // 2. idb/network (should be very quick after first load)
        let db = await this.fetchWithRetry(this.constants.API_DATABASE_PATH);
        this.apiCache = db;
        this.apiCacheTimestamp = Date.now();
        this._buildJsonDbIndex(db);
        return db;
    },

    // Build super-fast index (async, but as eager as possible)
    async _buildJsonDbIndex(db) {
        if (this._jsonDbIndexReady && this._jsonDbIndex) return this._jsonDbIndex;
        if (this._jsonDbIndexPromise) return this._jsonDbIndexPromise;
        this._jsonDbIndexPromise = new Promise(resolve => {
            // Use microtask to keep UI responsive
            Promise.resolve().then(() => {
                const apiMap = new Map();
                const idMap = new Map();
                const textMap = new Map();
                const catToTypeMap = new Map();
                function walk(obj, parentTypeObj) {
                    if (Array.isArray(obj)) {
                        obj.forEach(item => walk(item, parentTypeObj));
                    } else if (typeof obj === 'object' && obj !== null) {
                        if (obj.api) apiMap.set(obj.api, obj);
                        if (obj.id) idMap.set(obj.id, obj);
                        if (obj.text) textMap.set(obj.text, obj);
                        if (obj.category && Array.isArray(obj.category) && obj.id) {
                            for (const cat of obj.category) {
                                catToTypeMap.set(cat.id, obj);
                            }
                        }
                        for (const key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                walk(obj[key], obj);
                            }
                        }
                    }
                }
                walk(db?.type || db, null);
                this._jsonDbIndex = { apiMap, idMap, textMap, catToTypeMap };
                this._jsonDbIndexReady = true;
                resolve(this._jsonDbIndex);
            });
        });
        await this._jsonDbIndexPromise;
        return this._jsonDbIndex;
    },

    // Ultra-fast content lookup (target <20ms)
    async fetchApiContent(apiCode) {
        const db = await this.loadApiDatabase();
        const idx = this._jsonDbIndexReady ? this._jsonDbIndex : (await this._buildJsonDbIndex(db));
        if (idx && idx.apiMap.has(apiCode)) {
            const node = idx.apiMap.get(apiCode);
            return node.text || node;
        }
        // fallback scan (should almost never happen)
        function findApiValue(obj, targetApi) {
            if (Array.isArray(obj)) {
                for (const item of obj) {
                    const found = findApiValue(item, targetApi);
                    if (found) return found;
                }
            } else if (typeof obj === 'object' && obj !== null) {
                if (obj.api === targetApi) return obj.text || obj;
                for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        const found = findApiValue(obj[key], targetApi);
                        if (found) return found;
                    }
                }
            }
            return null;
        }
        const content = findApiValue(db, apiCode);
        if (!content) throw new Error(`API code not found: ${apiCode}`);
        return content;
    },

    async fetchCategoryGroup(categoryId) {
        const idRaw = categoryId.replace(/_category$/, '');
        const db = await this.loadApiDatabase();
        const idx = this._jsonDbIndexReady ? this._jsonDbIndex : (await this._buildJsonDbIndex(db));
        let found = null, typeName = "", typeId = "";
        if (idx && idx.idMap.has(idRaw)) {
            found = idx.idMap.get(idRaw);
            const typeObj = idx.catToTypeMap.get(idRaw);
            if (typeObj) {
                typeId = typeObj.id;
                typeName = typeObj.name;
            }
        }
        // fallback
        if (!found && Array.isArray(db?.type)) {
            for (const typeObj of db.type) {
                typeId = typeObj.id;
                typeName = typeObj.name;
                if (Array.isArray(typeObj.category)) {
                    for (const cat of typeObj.category) {
                        if (cat.id === idRaw) { found = cat; break; }
                    }
                }
                if (found) break;
            }
        }
        if (!found && Array.isArray(db)) {
            for (const typeObj of db) {
                typeId = typeObj.id;
                typeName = typeObj.name;
                if (Array.isArray(typeObj.category)) {
                    for (const cat of typeObj.category) {
                        if (cat.id === idRaw) { found = cat; break; }
                    }
                }
                if (found) break;
            }
        }
        if (!found) throw new Error(`Category not found: ${categoryId}`);
        const currentLang = localStorage.getItem('selectedLang') || 'en';
        const header = {
            title: found.name?.[currentLang] || found.name?.en || found.id,
            description: typeName?.[currentLang] || typeName?.en || "",
            typeId,
            categoryId: found.id,
            className: "auto-category-header"
        };
        return { id: found.id, name: found.name, data: found.data, header };
    }
};

// ส่วนที่ 5: ContentLoadingManager (สำหรับแสดง/ซ่อน spinner ใน container เนื้อหา)

window._headerV2_contentLoadingManager = {
    spinnerElement: null,
    LOADING_CONTAINER_ID: 'content-loading',
    
    createSpinner(message = '') {
        if (this.spinnerElement && document.body.contains(this.spinnerElement)) {
            this.updateMessage(message);
            return this.spinnerElement;
        }
        const spinner = document.createElement('div');
        spinner.className = 'content-loading-spinner content-loading-fade-in';
        spinner.innerHTML = `
            <div class="spinner-svg" aria-label="loading">
                <svg width="48" height="48" viewBox="0 0 48 48" focusable="false">
                    <circle class="spinner-svg-bg" cx="24" cy="24" r="20" fill="none" stroke="#eee" stroke-width="6"/>
                    <circle class="spinner-svg-fg" cx="24" cy="24" r="20" fill="none" stroke="#4285f4" stroke-width="6" stroke-linecap="round" stroke-dasharray="90 125" stroke-dashoffset="0"/>
                </svg>
            </div>
            <div class="loading-message">${message || this.getDefaultMessage()}</div>
        `;
        this.spinnerElement = spinner;
        return spinner;
    },
    
    show(message = '') {
        const container = document.getElementById(this.LOADING_CONTAINER_ID);
        if (!container) return;
        this.hide();
        const spinner = this.createSpinner(message);
        spinner.classList.remove('content-loading-fade-out');
        spinner.classList.add('content-loading-fade-in');
        container.appendChild(spinner);
    },
    
    hide() {
        if (this.spinnerElement && this.spinnerElement.parentNode) {
            this.spinnerElement.classList.remove('content-loading-fade-in');
            this.spinnerElement.classList.add('content-loading-fade-out');
            const spinnerToRemove = this.spinnerElement;
            const removeSpinner = () => {
                if (spinnerToRemove.parentNode) spinnerToRemove.parentNode.removeChild(spinnerToRemove);
                if (this.spinnerElement === spinnerToRemove) this.spinnerElement = null;
            };
            spinnerToRemove.addEventListener('animationend', removeSpinner, { once: true });
            setTimeout(removeSpinner, 400);
        } else {
            this.spinnerElement = null;
        }
    },
    
    updateMessage(message = '') {
        if (this.spinnerElement) {
            const msg = this.spinnerElement.querySelector('.loading-message');
            if (msg) msg.textContent = message || this.getDefaultMessage();
        }
    },
    
    getDefaultMessage() {
        const lang = localStorage.getItem('selectedLang') || 'en';
        return lang === 'th' ? 'กำลังโหลดเนื้อหา...' : 'Loading content...';
    }
};

window._headerV2_footerManager={
    _show:!1,_obs:null,
    hideFooter(){this._show=!1;const f=document.querySelector("footer");if(f)f.style.display="none"},
    showFooter(){this._show=!0;const f=document.querySelector("footer");
        if(f)f.style.display="";
        else if(!this._obs){
            this._obs=new MutationObserver(()=>{const f2=document.querySelector("footer");
                if(f2&&this._show){f2.style.display="";this._obs.disconnect();this._obs=null}
            });
            this._obs.observe(document.body,{childList:!0,subtree:!0});
        }
    }
};

window._headerV2_contentManager = {
    _vn: [],
    _items: [],
    _rset: new Set(),
    _scroll: null,
    _cleanup: null,

    async clearContent() {
        window._headerV2_footerManager.hideFooter();
        const c = document.getElementById(window._headerV2_contentLoadingManager.LOADING_CONTAINER_ID);
        if (c) c.textContent = "";
        window._headerV2_contentLoadingManager.hide();
        this._vn = [];
        this._items = [];
        this._rset.clear();
        if (this._scroll) window.removeEventListener("scroll", this._scroll);
        this._scroll = null;
        if (typeof this._cleanup === "function") this._cleanup();
        this._cleanup = null;
    },

    async renderContent(data) {
        if (!Array.isArray(data)) throw "Content data should be array";
        const c = document.getElementById(window._headerV2_contentLoadingManager.LOADING_CONTAINER_ID);
        if (!c) return;
        await this.clearContent();
        window._headerV2_contentLoadingManager.show();

        // === ปรับใหม่: render ทุกอย่างขนาน + preload DB (ถ้าต้องใช้) ===
        const items = data, vn = [], rset = new Set();
        this._vn = vn;
        this._items = items;
        this._rset = rset;
        this._cleanup = () => {
            vn.forEach(n => n && n.parentNode && n.parentNode.removeChild(n));
            vn.length = 0;
            rset.clear();
        };

        // preload DB สำหรับปุ่มที่ต้องใช้
        let dbPromise = null;
        if (items.some(it => it.api || it.group?.categoryId || it.categoryId)) {
            dbPromise = window._headerV2_dataManager.loadApiDatabase();
        }

        // ---- render ทุกอันขนานกัน ----
        const renderTasks = items.map(async (it, i) => {
            const el = document.createElement("div");
            el.id = it.id || `content-item-${i}`;
            const inner = this.createContainer(it);

            if (it.group?.categoryId) {
                await this.renderGroupItems(inner, it.group, dbPromise);
            } else if (it.categoryId) {
                await this.renderGroupItems(inner, { categoryId: it.categoryId, type: it.type || "button" }, dbPromise);
            } else {
                await this.renderSingleItem(inner, it, dbPromise);
            }

            el.appendChild(inner);
            el.style.opacity = 0;
            el.classList.add("fade-in");
            el.style.transition = "opacity 400ms cubic-bezier(.7,0,.7,1)";
            vn.push(el);
            rset.add(i);
            return el;
        });

        const allElements = await Promise.all(renderTasks);

        // === append ลง DOM ทีเดียว เพื่อลด reflow/repaint ===
        const frag = document.createDocumentFragment();
        allElements.forEach(el => frag.appendChild(el));
        c.appendChild(frag);
        requestAnimationFrame(() => { allElements.forEach(n => n.style.opacity = 1); });
        window._headerV2_contentLoadingManager.hide();
        setTimeout(() => { window._headerV2_footerManager.showFooter(); }, 0);
    },

    createContainer(it) {
        const d = document.createElement("div");
        d.className = (it.group?.type === "button" || it.type === "button") ? "button-content-container" : "card-content-container";
        if (it.group?.containerClass) d.classList.add(it.group.containerClass);
        return d;
    },

    async renderGroupItems(container, group, dbPromise) {
        if (!group.categoryId) throw "Group ต้องระบุ categoryId";
        const { data, header } = await window._headerV2_dataManager.fetchCategoryGroup(group.categoryId);
        const frag = document.createDocumentFragment();
        frag.appendChild(this.createGroupHeader(header));
        if (group.type !== "button") throw "รองรับเฉพาะ type: 'button' ใน group";
        // === createButton ทุกปุ่มขนาน ===
        const db = dbPromise ? await dbPromise : null;
        const btns = await Promise.all(data.map(item => this.createButton(item, db)));
        btns.forEach(btn => btn && frag.appendChild(btn));
        container.appendChild(frag);
    },

    createGroupHeader(hc) {
        const h = document.createElement("div");
        h.className = "group-header";
        const lang = localStorage.getItem("selectedLang") || "en";
        if (typeof hc === "string") return this.createSimpleHeader(hc, h);
        if (hc.className) h.classList.add(hc.className);
        this.createHeaderComponents(h, hc, lang);
        this.addLangListener(h, hc);
        return h;
    },

    createSimpleHeader(txt, c) {
        const h2 = document.createElement("h2");
        h2.className = "group-header-text";
        h2.textContent = txt;
        c.appendChild(h2);
        return c;
    },

    createHeaderComponents(c, cfg, lang) {
        if (cfg.icon) c.appendChild(this.createHeaderIcon(cfg.icon));
        const hc = document.createElement("div");
        hc.className = "header-content";
        hc.appendChild(this.createHeaderTitle(cfg, lang));
        if (cfg.description) hc.appendChild(this.createHeaderDesc(cfg.description, lang));
        c.appendChild(hc);
        if (cfg.actions) c.appendChild(this.createHeaderActions(cfg.actions, lang));
    },

    createHeaderTitle(cfg, lang) {
        const t = document.createElement("h2");
        t.className = "group-header-text";
        if (typeof cfg.title === "object") {
            Object.entries(cfg.title).forEach(([l, tx]) => t.dataset[`title${l.toUpperCase()}`] = tx);
            t.textContent = cfg.title[lang] || cfg.title.en;
        } else t.textContent = cfg.title;
        return t;
    },

    createHeaderDesc(desc, lang) {
        const d = document.createElement("p");
        d.className = "group-header-description";
        if (typeof desc === "object") {
            Object.entries(desc).forEach(([l, tx]) => d.dataset[`desc${l.toUpperCase()}`] = tx);
            d.textContent = desc[lang] || desc.en;
        } else d.textContent = desc;
        return d;
    },

    addLangListener(c, cfg) {
        if (!c._langListenerBound) {
            window.addEventListener("languageChange", e => this.updateHeaderLang(c, cfg, e.detail.language));
            c._langListenerBound = !0;
        }
    },

    updateHeaderLang(c, cfg, lang) {
        const t = c.querySelector(".group-header-text");
        if (t && cfg.title && typeof cfg.title === "object") t.textContent = cfg.title[lang] || cfg.title.en || t.textContent;
        const d = c.querySelector(".group-header-description");
        if (d && cfg.description && typeof cfg.description === "object") d.textContent = cfg.description[lang] || cfg.description.en || d.textContent;
    },

    async renderSingleItem(container, it, dbPromise) {
        if (it.categoryId) {
            await this.renderGroupItems(container, { categoryId: it.categoryId, type: it.type || "button" }, dbPromise);
            return;
        }
        const db = dbPromise ? await dbPromise : null;
        const e = it.type === "button"
            ? await this.createButton(it, db)
            : await this.createCard(it);
        if (e) container.appendChild(e);
    },

    async createButton(cfg, db) {
        const b = document.createElement("button");
        b.className = "button-content";
        let fc = "", api = cfg.api || null, type = cfg.type || null;
        try {
            if (api) {
                db = db || await window._headerV2_dataManager.loadApiDatabase();
                function findApiNode(o, code) {
                    if (Array.isArray(o)) return o.map(v => findApiNode(v, code)).find(Boolean);
                    if (o && typeof o === "object") {
                        if (o.api === code) return o;
                        return Object.keys(o).map(k => findApiNode(o[k], code)).find(Boolean);
                    }
                }
                const nd = findApiNode(db, api);
                if (nd) {
                    fc = nd.text;
                    type = type || (nd.api ? "emoji" : "symbol");
                } else fc = api;
            } else if (cfg.content) {
                fc = cfg.content;
                type = "symbol";
            } else if (cfg.text) {
                fc = cfg.text;
                type = "symbol";
            } else throw "ต้องระบุ api, content หรือ text สำหรับ button";
            b.textContent = fc;
        } catch {
            b.textContent = "Error";
        }
        b.addEventListener("click", async () => {
            try {
                await unifiedCopyToClipboard({ text: fc, api, type, name: api ? `${api}` : "" });
            } catch {
                window._headerV2_utils.showNotification("Copy failed", "error");
            }
        });
        b.classList.add("fade-in");
        b.style.opacity = 0;
        requestAnimationFrame(() => { b.style.opacity = 1; });
        return b;
    },

    async createCard(cfg) {
        const lang = localStorage.getItem("selectedLang") || "en";
        const card = document.createElement("div");
        card.className = "card";
        if (cfg.image) {
            const img = document.createElement("img");
            img.className = "card-image";
            img.src = cfg.image;
            img.loading = "lazy";
            img.alt = cfg.imageAlt?.[lang] || cfg.imageAlt?.en || "";
            card.appendChild(img);
        }
        const cdiv = document.createElement("div");
        cdiv.className = "card-content";
        const tdiv = document.createElement("div");
        tdiv.className = "card-title";
        if (typeof cfg.title === "object") {
            Object.entries(cfg.title).forEach(([l, tx]) => tdiv.dataset[`title${l.toUpperCase()}`] = tx);
            tdiv.textContent = cfg.title[lang] || cfg.title.en;
        } else if (cfg.name && typeof cfg.name === "object") tdiv.textContent = cfg.name[lang] || cfg.name.en;
        else tdiv.textContent = cfg.title || cfg.name || "";
        cdiv.appendChild(tdiv);

        const ddiv = document.createElement("div");
        ddiv.className = "card-description";
        if (typeof cfg.description === "object") {
            Object.entries(cfg.description).forEach(([l, tx]) => ddiv.dataset[`desc${l.toUpperCase()}`] = tx);
            ddiv.textContent = cfg.description[lang] || cfg.description.en;
        } else if (cfg.name && typeof cfg.name === "object") ddiv.textContent = cfg.name[lang] || cfg.name.en;
        else ddiv.textContent = cfg.description || "";
        cdiv.appendChild(ddiv);
        card.appendChild(cdiv);

        if (cfg.link) card.addEventListener("click", () => window.open(cfg.link, "_blank", "noopener"));
        if (cfg.className) card.classList.add(cfg.className);
        card.classList.add("fade-in");
        card.style.opacity = 0;
        card.style.transition = "opacity 400ms cubic-bezier(.7,0,.7,1)";
        requestAnimationFrame(() => { card.style.opacity = 1; });
        return card;
    },

    updateCardsLanguage(lang) {
        document.querySelectorAll(".card").forEach(card => {
            const t = card.querySelector(".card-title");
            if (t) {
                const nt = t.dataset[`title${lang.toUpperCase()}`];
                if (nt) t.textContent = nt;
            }
            const d = card.querySelector(".card-description");
            if (d) {
                const nd = d.dataset[`desc${lang.toUpperCase()}`];
                if (nd) d.textContent = nd;
            }
            const img = card.querySelector(".card-image");
            if (img) {
                const na = img.dataset[`alt${lang.toUpperCase()}`];
                if (na) img.alt = na;
            }
        });
    }
};

// ... (โค้ดส่วนอื่นคงเดิม) ...

// ส่วนที่ 7: NavigationManager (จัดการ route, URL, button states, scroll active button)

window._headerV2_navigationManager = {
    state: {
        isNavigating: false,
        currentMainRoute: '',
        currentSubRoute: '',
        previousUrl: '',
        lastScrollPosition: 0
    },

    // Normalize various URL formats to standard ?type=...__&page=...
    // ปรับปรุง: ถ้า main button ไม่มีปุ่มย่อย จะไม่เติม __ หรือ &page= ลงใน URL เด็ดขาด
    normalizeUrl(url) {
        if (!url) return '';
        // เตรียม config
        const buttonConfig = window._headerV2_buttonManager?.buttonConfig;
        let main = '', sub = '';
        if (typeof url === 'object') {
            main = (url.type || '').toLowerCase();
            sub = (url.page || '').toLowerCase();
        } else if (url.startsWith('?')) {
            const params = new URLSearchParams(url);
            main = (params.get('type') || '').replace(/__$/, '').toLowerCase();
            sub = (params.get('page') || '').toLowerCase();
        } else if (url.includes('-')) {
            const [m, s] = url.split('-');
            main = m; sub = s || '';
        } else {
            main = url.toLowerCase();
        }
        // หา mainButton
        const mainButton = buttonConfig?.mainButtons?.find(btn => btn.url === main || btn.jsonFile === main);
        const hasSub = !!(mainButton && Array.isArray(mainButton.subButtons) && mainButton.subButtons.length > 0);
        if (hasSub) {
            // ถ้ามีปุ่มย่อย
            if (sub) return `?type=${main}__&page=${sub}`;
            return `?type=${main}__`;
        }
        // ไม่มีปุ่มย่อย
        return `?type=${main}`;
    },

    parseUrl() {
        const params = new URLSearchParams(window.location.search);
        const type = params.get('type');
        const page = params.get('page');
        return {
            main: type ? type.replace(/__$/, '') : '',
            sub: page || ''
        };
    },

    async validateUrl(url) {
        // Validate if url exists in button config
        const { main, sub } = typeof url === 'object' ? url :
            (() => {
                if (url.startsWith('?')) {
                    const params = new URLSearchParams(url);
                    return {
                        main: (params.get('type') || '').replace(/__$/, ''),
                        sub: params.get('page') || ''
                    };
                } else if (url.includes('-')) {
                    const [m, s] = url.split('-');
                    return { main: m, sub: s || '' };
                } else {
                    return { main: url, sub: '' };
                }
            })();
        const config = window._headerV2_buttonManager?.buttonConfig;
        if (!config) return false;
        const mainButton = config.mainButtons.find(btn => btn.url === main || btn.jsonFile === main);
        if (!mainButton) return false;
        if (sub) {
            return mainButton.subButtons && mainButton.subButtons.some(subBtn => subBtn.url === sub || subBtn.jsonFile === sub);
        }
        return true;
    },

    async getDefaultRoute() {
        const config = window._headerV2_buttonManager?.buttonConfig;
        if (!config) return '';
        const defaultMainButton = config.mainButtons.find(btn => btn.isDefault);
        if (!defaultMainButton) return '';
        const mainRoute = defaultMainButton.url || defaultMainButton.jsonFile;
        if (!defaultMainButton.subButtons) return this.normalizeUrl(mainRoute);
        const defaultSubButton = defaultMainButton.subButtons.find(btn => btn.isDefault);
        if (!defaultSubButton) return this.normalizeUrl(mainRoute);
        const subRoute = defaultSubButton.url || defaultSubButton.jsonFile;
        return this.normalizeUrl({ type: mainRoute, page: subRoute });
    },

    async changeURL(url, force = false) {
        try {
            if (!url) return;
            const normalizedUrl = this.normalizeUrl(url);
            if (force || window.location.search !== normalizedUrl) {
                window.history.pushState({
                    url: normalizedUrl,
                    scrollPosition: this.state.lastScrollPosition
                }, '', normalizedUrl);
                this.state.previousUrl = normalizedUrl;
                window.dispatchEvent(new CustomEvent('urlChanged', {
                    detail: {
                        url: normalizedUrl,
                        mainRoute: this.state.currentMainRoute,
                        subRoute: this.state.currentSubRoute
                    }
                }));
            }
        } catch (error) {
            window._headerV2_utils.showNotification('เปลี่ยน URL ไม่สำเร็จ', 'error');
        }
    },

    async updateButtonStates(url) {
        const elements = window._headerV2_elements;
        const { main, sub } = url ?
            (url.startsWith('?') ? (() => {
                    const params = new URLSearchParams(url);
                    return {
                        main: (params.get('type') || '').replace(/__$/, ''),
                        sub: params.get('page') || ''
                    };
                })() :
                (url.includes('-') ? (() => {
                    const [m, s] = url.split('-');
                    return { main: m, sub: s || '' };
                })() : { main: url, sub: '' })
            ) : this.parseUrl();

        elements.navList.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-url') === main) btn.classList.add('active');
        });
        elements.subButtonsContainer.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-url') === `${main}-${sub}`) btn.classList.add('active');
        });
        this.scrollActiveButtonsIntoView();
    },

async navigateTo(route, options = {}) {
    if (this.state.isNavigating) return;
    try {
        this.state.isNavigating = true;
        this.state.lastScrollPosition = window.pageYOffset;
        
        // --- Normalize route ---
        let normalizedRoute = typeof route === 'object' ? this.normalizeUrl(route) : route;
        if (typeof route === 'string' && route.startsWith('?')) normalizedRoute = this.normalizeUrl(route);
        
        // --- Validate route ---
        let isValidUrl = false;
        try { isValidUrl = await this.validateUrl(normalizedRoute); } catch {}
        if (!isValidUrl) normalizedRoute = await this.getDefaultRoute();
        
        // --- Extract main/sub ---
        const { main, sub } = typeof normalizedRoute === 'object' ?
            normalizedRoute :
            normalizedRoute.startsWith('?') ?
            (() => {
                const params = new URLSearchParams(normalizedRoute);
                return { main: (params.get('type') || '').replace(/__$/, ''), sub: params.get('page') || '' };
            })() :
            normalizedRoute.includes('-') ?
            (() => {
                const [m, s] = normalizedRoute.split('-');
                return { main: m, sub: s || '' };
            })() :
            { main: normalizedRoute, sub: '' };
        
        this.state.currentMainRoute = main;
        this.state.currentSubRoute = sub || '';
        const lang = localStorage.getItem('selectedLang') || 'en';
        
        // --- Update URL if not skipped ---
        if (!options.skipUrlUpdate) await this.changeURL({ type: main, page: sub });
        
        // --- Lookup config ---
        const config = window._headerV2_buttonManager?.buttonConfig;
        if (!config) throw new Error('buttonConfig not found');
        const mainButton = config.mainButtons.find(btn => btn.url === main || btn.jsonFile === main);
        if (!mainButton) throw new Error('mainButton not found');
        let subButton = null;
        if (mainButton.subButtons?.length) {
            subButton = mainButton.subButtons.find(btn => btn.url === sub || btn.jsonFile === sub);
            if (!subButton) {
                subButton = mainButton.subButtons.find(btn => btn.isDefault) || mainButton.subButtons[0];
                this.state.currentSubRoute = subButton.url || subButton.jsonFile;
            }
        }
        
        // --- Update active main button ---
        window._headerV2_elements.navList.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
        const mainNavBtn = window._headerV2_elements.navList.querySelector(`button[data-url="${main}"]`);
        if (mainNavBtn) mainNavBtn.classList.add('active');
        window._headerV2_buttonManager.state.currentMainButton = mainNavBtn;
        window._headerV2_buttonManager.state.currentMainButtonUrl = main;
        
        // --- Render sub-buttons robustly ---
        const subButtonsContainer = window._headerV2_elements.subButtonsContainer;
        const hasSubButtons = mainButton.subButtons?.length > 0;
        const isPopState = !!options.isPopState;
        // ต้อง renderSubButtons ใหม่ถ้า main เปลี่ยน หรือ container ว่างตอน popstate
        const needsRenderSubButtons = hasSubButtons && ((!isPopState) || (isPopState && subButtonsContainer.childNodes.length === 0));
        
        if (hasSubButtons) {
            if (needsRenderSubButtons) {
                subButtonsContainer.innerHTML = "";
                try {
                    await window._headerV2_buttonManager.renderSubButtons(mainButton.subButtons, main, lang);
                } catch (e) {
                    window._headerV2_utils.showNotification('เกิดข้อผิดพลาดในการโหลดปุ่มย่อย', 'error');
                }
            }
            // Update active sub button
            subButtonsContainer.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            if (subButton) {
                const subNavBtn = subButtonsContainer.querySelector(`button[data-url="${main}-${subButton.url || subButton.jsonFile}"]`);
                if (subNavBtn) subNavBtn.classList.add('active');
                window._headerV2_buttonManager.state.currentSubButton = subNavBtn;
            }
            await window._headerV2_contentManager.clearContent();
            if (subButton && subButton.jsonFile) {
                try {
                    const subData = await window._headerV2_dataManager.fetchWithRetry(subButton.jsonFile);
                    await window._headerV2_contentManager.renderContent(subData);
                } catch (e) {
                    window._headerV2_utils.showNotification('เกิดข้อผิดพลาดในการโหลดเนื้อหาย่อย', 'error');
                }
            }
        } else {
            // ไม่มีปุ่มย่อย ล้าง container ปุ่มย่อยเสมอ
            subButtonsContainer.innerHTML = "";
            subButtonsContainer.classList.remove('fade-in', 'fade-out');
            window._headerV2_buttonManager.state.currentSubButton = null;
            await window._headerV2_contentManager.clearContent();
            if (mainButton?.jsonFile) {
                try {
                    const mainData = await window._headerV2_dataManager.fetchWithRetry(mainButton.jsonFile);
                    await window._headerV2_contentManager.renderContent(mainData);
                } catch (e) {
                    window._headerV2_utils.showNotification('เกิดข้อผิดพลาดในการโหลดเนื้อหาหลัก', 'error');
                }
            }
        }
        
        // --- Update all button states ---
        await this.updateButtonStates(this.normalizeUrl({ type: main, page: sub }));
        
        if (!options.maintainScroll) {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    } catch (error) {
        window._headerV2_contentLoadingManager.hide();
        window._headerV2_utils.showNotification('เกิดข้อผิดพลาดในการนำทาง', 'error');
        console.error('navigateTo error', error);
    } finally {
        window._headerV2_contentLoadingManager.hide();
        this.state.isNavigating = false;
    }
},

    async loadMainAndSubParallel(mainButton, subButton) {
        try {
            const jobs = [];
            if (mainButton?.jsonFile) jobs.push(window._headerV2_dataManager.fetchWithRetry(mainButton.jsonFile));
            if (subButton?.jsonFile) jobs.push(window._headerV2_dataManager.fetchWithRetry(subButton.jsonFile));
            const results = await Promise.all(jobs);
            if (results.length === 2) {
                await window._headerV2_contentManager.renderContent([...results[0], ...results[1]]);
            } else if (results.length === 1) {
                await window._headerV2_contentManager.renderContent(results[0]);
            }
        } catch (error) {
            window._headerV2_utils.showNotification('โหลดเนื้อหาหลัก/ย่อยไม่สำเร็จ', 'error');
        }
    },

    scrollActiveButtonsIntoView() {
        try {
            ['nav ul', '#sub-buttons-container'].forEach(selector => {
                const container = document.querySelector(selector);
                if (!container) return;
                const activeButton = container.querySelector('button.active');
                if (!activeButton) return;
                requestAnimationFrame(() => {
                    try {
                        const containerBounds = container.getBoundingClientRect();
                        const buttonBounds = activeButton.getBoundingClientRect();
                        const scrollLeft = container.scrollLeft + (buttonBounds.left - containerBounds.left) - 20;
                        container.scrollTo({
                            left: Math.max(0, scrollLeft),
                            behavior: 'smooth'
                        });
                    } catch {}
                });
            });
        } catch {}
    }
};

// ... (โค้ดส่วนอื่นคงเดิม) ...

// --- SubNavManager (ปรับปรุง: ไม่ลบ DOM, ซ่อน/แสดง sub-nav container เท่านั้น, สร้างใหม่เสมอถ้าไม่มี) ---
window._headerV2_subNavManager = {
    ensureSubNavContainer() {
        let subNav = document.getElementById('sub-nav');
        if (!subNav) {
            subNav = document.createElement('div');
            subNav.id = 'sub-nav';
            subNav.className = 'hi';
            const header = document.querySelector('header');
            if (header && header.nextSibling) {
                header.parentNode.insertBefore(subNav, header.nextSibling);
            } else {
                document.body.insertBefore(subNav, document.body.firstChild);
            }
        }
        let hj = subNav.querySelector('.hj');
        if (!hj) {
            hj = document.createElement('div');
            hj.className = 'hj';
            subNav.appendChild(hj);
        }
        let subButtonsContainer = hj.querySelector('#sub-buttons-container');
        if (!subButtonsContainer) {
            subButtonsContainer = document.createElement('div');
            subButtonsContainer.id = 'sub-buttons-container';
            hj.appendChild(subButtonsContainer);
        }
        window._headerV2_elements.subNav = subNav;
        window._headerV2_elements.subNavInner = hj;
        window._headerV2_elements.subButtonsContainer = subButtonsContainer;
        return subButtonsContainer;
    },

    hideSubNav() {
        const subNav = document.getElementById('sub-nav');
        if (subNav) {
            subNav.style.display = 'none';
            if (window._headerV2_elements.subButtonsContainer)
                window._headerV2_elements.subButtonsContainer.innerHTML = '';
        }
    },

    showSubNav() {
        let subNav = document.getElementById('sub-nav');
        if (!subNav) {
            this.ensureSubNavContainer();
            subNav = document.getElementById('sub-nav');
        }
        if (subNav) {
            subNav.style.display = '';
        }
    },

    clearSubButtons() {
        const container = this.ensureSubNavContainer();
        container.innerHTML = '';
    }
};

// --- ButtonManager (ปรับปรุง: ใช้ซิงค์กับ sub-nav manager อย่างถูกต้อง, ไม่ลบ DOM, แสดง/ซ่อนเท่านั้น) ---
window._headerV2_buttonManager = {
    buttonConfig: null,
    state: {
        buttonMap: new Map(),
        currentMainButton: null,
        currentSubButton: null,
        currentMainButtonUrl: null,
    },

    async loadConfig() {
        if (this.buttonConfig) {
            await this.renderMainButtons();
            return;
        }
        const cached = window._headerV2_dataManager.getCached('buttonConfig');
        if (cached) {
            this.buttonConfig = cached;
            await this.renderMainButtons();
            return;
        }
        const response = await window._headerV2_dataManager.fetchWithRetry(window._headerV2_dataManager.constants.BUTTONS_CONFIG_PATH);
        this.buttonConfig = response;
        window._headerV2_dataManager.setCache('buttonConfig', response);
        await this.renderMainButtons();
        await window._headerV2_navigationManager.updateButtonStates();
    },

    async renderMainButtons() {
        const lang = localStorage.getItem('selectedLang') || 'en';
        const { mainButtons } = this.buttonConfig;
        const navList = window._headerV2_elements.navList;
        navList.innerHTML = '';
        this.state.buttonMap = new Map();
        let defaultButton = null;

        for (const button of mainButtons) {
            const label = button[`${lang}_label`];
            if (!label) continue;
            const li = document.createElement('li');
            const mainButton = document.createElement('button');
            mainButton.textContent = label;
            mainButton.className = 'main-button';
            const buttonUrl = button.url || button.jsonFile;
            mainButton.setAttribute('data-url', buttonUrl);
            if (button.className) mainButton.classList.add(button.className);
            this.state.buttonMap.set(buttonUrl, { button: mainButton, config: button, element: mainButton });
            if (button.isDefault) defaultButton = { button: mainButton, config: button };

            mainButton.addEventListener('click', async (event) => {
                event.preventDefault();
                window._headerV2_elements.navList.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                mainButton.classList.add('active');
                this.state.currentMainButton = mainButton;
                this.state.currentMainButtonUrl = buttonUrl;

                await window._headerV2_contentManager.clearContent();

                // ซิงค์ sub-nav ตามปุ่มย่อย
                if (button.subButtons && button.subButtons.length > 0) {
                    window._headerV2_subNavManager.showSubNav();
                    await this.renderSubButtons(button.subButtons, buttonUrl, lang);
                } else {
                    window._headerV2_subNavManager.hideSubNav();
                }

                const skipUrlUpdate = !!button.subButtons;
                if (!button.subButtons && button.url) {
                    await window._headerV2_navigationManager.navigateTo(button.url, { skipUrlUpdate });
                }
                if (button.jsonFile) {
                    try {
                        const data = await window._headerV2_dataManager.fetchWithRetry(button.jsonFile);
                        await window._headerV2_contentManager.renderContent(data);
                    } catch {
                        window._headerV2_utils.showNotification('โหลดเนื้อหาไม่สำเร็จ', 'error');
                    }
                }
                window._headerV2_navigationManager.state.currentMainRoute = buttonUrl;
            });

            li.appendChild(mainButton);
            navList.appendChild(li);
        }

        let initialUrl = window.location.search;
        await this.handleInitialUrl(initialUrl, this.state.buttonMap, defaultButton);
    },

    async handleInitialUrl(url, buttonMap, defaultButton) {
        try {
            if (!url) url = window.location.search;
            if (!url || url === '?') {
                if (defaultButton) await this.triggerMainButtonClick(defaultButton.button);
                return;
            }
            let mainRoute = '', subRoute = '';
            if (url.startsWith('?')) {
                const params = new URLSearchParams(url);
                mainRoute = (params.get('type') || '').replace(/__$/, '');
                subRoute = params.get('page') || '';
            } else if (url.includes('-')) {
                [mainRoute, subRoute] = url.split('-');
            } else {
                mainRoute = url;
            }
            const mainButtonData = buttonMap.get(mainRoute);
            if (!mainButtonData) {
                if (defaultButton) await this.triggerMainButtonClick(defaultButton.button);
                return;
            }
            const { button: mainButton, config: mainConfig } = mainButtonData;
            try {
                const isValidUrl = await window._headerV2_navigationManager.validateUrl(url);
                if (!isValidUrl) throw new Error('URL ไม่ถูกต้อง');
                window._headerV2_navigationManager.state.currentMainRoute = mainRoute;
                window._headerV2_navigationManager.state.currentSubRoute = subRoute || '';
                this.state.currentMainButton = mainButton;
                await this.activateMainButton(mainButton, mainConfig);
                if (mainConfig.subButtons && mainConfig.subButtons.length > 0) {
                    if (subRoute) {
                        await this.handleInitialSubRoute(mainConfig, mainRoute, subRoute);
                    } else {
                        await this.handleDefaultSubButton(mainConfig, mainRoute);
                    }
                    window._headerV2_subNavManager.showSubNav();
                } else {
                    window._headerV2_subNavManager.hideSubNav();
                }
                window._headerV2_navigationManager.scrollActiveButtonsIntoView();
            } catch {
                if (defaultButton) await this.triggerMainButtonClick(defaultButton.button);
            }
        } catch {
            if (defaultButton) await this.triggerMainButtonClick(defaultButton.button);
        }
    },

    async activateMainButton(mainButton, mainConfig) {
        const navList = window._headerV2_elements.navList;
        navList.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
        mainButton.classList.add('active');
        this.state.currentMainButton = mainButton;
        await window._headerV2_contentManager.clearContent();
        if (mainConfig.subButtons && mainConfig.subButtons.length > 0) {
            window._headerV2_subNavManager.showSubNav();
            await this.renderSubButtons(mainConfig.subButtons, mainConfig.url || mainConfig.jsonFile, localStorage.getItem('selectedLang') || 'en');
        } else {
            window._headerV2_subNavManager.hideSubNav();
        }
        if (mainConfig.jsonFile) {
            const mainData = await window._headerV2_dataManager.fetchWithRetry(mainConfig.jsonFile);
            await window._headerV2_contentManager.renderContent(mainData);
        }
    },

    async handleInitialSubRoute(mainConfig, mainRoute, subRoute) {
        await new Promise(resolve => setTimeout(resolve, 100));
        const lang = localStorage.getItem('selectedLang') || 'en';
        if (mainConfig.subButtons && mainConfig.subButtons.length > 0) {
            window._headerV2_subNavManager.showSubNav();
            await this.renderSubButtons(mainConfig.subButtons, mainRoute, lang);
            const subButton = window._headerV2_elements.subButtonsContainer.querySelector(`button[data-url="${mainRoute}-${subRoute}"]`);
            const subButtonConfig = mainConfig.subButtons.find(btn => btn.url === subRoute || btn.jsonFile === subRoute);
            if (subButton && subButtonConfig) {
                window._headerV2_elements.subButtonsContainer.querySelectorAll('.button-sub').forEach(btn => btn.classList.remove('active'));
                subButton.classList.add('active');
                this.state.currentSubButton = subButton;
                if (subButtonConfig.jsonFile) {
                    await window._headerV2_contentManager.clearContent();
                    const subData = await window._headerV2_dataManager.fetchWithRetry(subButtonConfig.jsonFile);
                    await window._headerV2_contentManager.renderContent(subData);
                }
                this.scrollActiveSubButtonIntoView(subButton);
            }
        } else {
            window._headerV2_subNavManager.hideSubNav();
        }
    },

    async handleDefaultSubButton(mainConfig, mainRoute) {
        if (mainConfig.subButtons && mainConfig.subButtons.length > 0) {
            window._headerV2_subNavManager.showSubNav();
            const defaultSubButton = mainConfig.subButtons.find(btn => btn.isDefault);
            if (defaultSubButton) {
                const fullUrl = `${mainRoute}-${defaultSubButton.url || defaultSubButton.jsonFile}`;
                await window._headerV2_navigationManager.navigateTo(fullUrl, { skipUrlUpdate: false });
            }
        } else {
            window._headerV2_subNavManager.hideSubNav();
        }
    },

    async triggerMainButtonClick(button, options = {}) {
        if (!button) throw new Error('ไม่พบปุ่มหลักที่จะคลิก');
        const buttonUrl = button.getAttribute('data-url');
        const mainConfig = this.findMainButtonConfig(buttonUrl);
        await window._headerV2_contentManager.clearContent();
        if (mainConfig?.subButtons && mainConfig.subButtons.length > 0) {
            window._headerV2_subNavManager.showSubNav();
            await this.renderSubButtons(mainConfig.subButtons, mainConfig.url || mainConfig.jsonFile, localStorage.getItem('selectedLang') || 'en');
        } else {
            window._headerV2_subNavManager.hideSubNav();
        }
        this.state.currentMainButton = button;
        this.state.currentMainButtonUrl = buttonUrl;
        if (mainConfig?.jsonFile) {
            const data = await window._headerV2_dataManager.fetchWithRetry(mainConfig.jsonFile);
            await window._headerV2_contentManager.renderContent(data);
        }
        this.updateButtonState(button, false);
    },

    async triggerSubButtonClick(button) {
        if (!button) throw new Error('ไม่พบปุ่มย่อยที่จะคลิก');
        await window._headerV2_contentManager.clearContent();
        const buttonUrl = button.getAttribute('data-url');
        const [mainRoute, subRoute] = buttonUrl.split('-');
        const mainConfig = this.findMainButtonConfig(mainRoute);
        const subConfig = mainConfig?.subButtons?.find(btn => btn.url === subRoute || btn.jsonFile === subRoute);
        this.state.currentSubButton = button;
        if (subConfig?.jsonFile) {
            const data = await window._headerV2_dataManager.fetchWithRetry(subConfig.jsonFile);
            await window._headerV2_contentManager.renderContent(data);
        }
        this.updateButtonState(button, true);
        await window._headerV2_navigationManager.changeURL(buttonUrl);
    },

    async renderSubButtons(subButtons, mainButtonUrl, lang) {
        if (!subButtons || subButtons.length === 0) {
            window._headerV2_subNavManager.hideSubNav();
            return;
        }
        window._headerV2_subNavManager.showSubNav();
        const container = window._headerV2_subNavManager.ensureSubNavContainer();
        container.innerHTML = '';
        let defaultSubButton = null;
        const currentUrl = window.location.search;
        let activeSubUrl = '';
        if (currentUrl.startsWith('?')) {
            const params = new URLSearchParams(currentUrl);
            const main = (params.get('type') || '').replace(/__$/, '');
            const sub = params.get('page') || '';
            if (main && sub) activeSubUrl = `${main}-${sub}`;
        }
        subButtons.forEach(button => {
            const label = button[`${lang}_label`];
            if (!label) return;
            const subButton = document.createElement('button');
            subButton.className = 'button-sub sub-button';
            if (button.className) subButton.classList.add(button.className);
            subButton.textContent = label;
            const fullUrl = button.url ?
                `${mainButtonUrl}-${button.url}` :
                `${mainButtonUrl}-${button.jsonFile}`;
            subButton.setAttribute('data-url', fullUrl);
            if (button.isDefault) defaultSubButton = subButton;

            subButton.addEventListener('click', async () => {
                this.updateButtonState(subButton, true);
                await window._headerV2_contentManager.clearContent();
                if (button.jsonFile) {
                    try {
                        const data = await window._headerV2_dataManager.fetchWithRetry(button.jsonFile);
                        await window._headerV2_contentManager.renderContent(data);
                    } catch {
                        window._headerV2_utils.showNotification('โหลดเนื้อหาย่อยไม่สำเร็จ', 'error');
                    }
                }
                await window._headerV2_navigationManager.changeURL(fullUrl);
            });
            container.appendChild(subButton);
            if (fullUrl === activeSubUrl) this.updateButtonState(subButton, true);
        });
        const needsDefault = !activeSubUrl ||
            !container.querySelector('.button-sub.active');
        if (needsDefault && defaultSubButton) await this.triggerSubButtonClick(defaultSubButton);
        container.classList.remove('fade-out');
        container.classList.add('fade-in');
    },

    updateButtonState(button, isSubButton) {
        const buttonGroup = isSubButton ? window._headerV2_elements.subButtonsContainer : window._headerV2_elements.navList;
        if (buttonGroup) buttonGroup.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        if (isSubButton) {
            this.state.currentSubButton = button;
            this.scrollActiveSubButtonIntoView(button);
        } else {
            this.state.currentMainButton = button;
        }
    },

    findMainButtonConfig(url) {
        return this.buttonConfig?.mainButtons?.find(btn => btn.url === url || btn.jsonFile === url);
    },

    findSubButtonConfig(fullUrl) {
        const [mainRoute, subRoute] = fullUrl.split('-');
        const mainButton = this.findMainButtonConfig(mainRoute);
        return mainButton?.subButtons?.find(btn => btn.url === subRoute || btn.jsonFile === subRoute);
    },

    scrollActiveSubButtonIntoView(activeButton) {
        if (!activeButton) return;
        const container = window._headerV2_elements.subButtonsContainer;
        if (!container) return;
        const containerLeft = container.getBoundingClientRect().left;
        const buttonLeft = activeButton.getBoundingClientRect().left;
        const scrollLeft = container.scrollLeft;
        const targetScroll = scrollLeft + (buttonLeft - containerLeft) - 20;
        if (Math.abs(container.scrollLeft - targetScroll) > 1) {
            container.scrollTo({
                left: targetScroll,
                behavior: 'smooth'
            });
        }
    },

    updateButtonsLanguage(newLang) {
        try {
            const { mainButtons } = this.buttonConfig;
            const navList = window._headerV2_elements.navList;
            navList.querySelectorAll('button').forEach((button, index) => {
                const config = mainButtons[index];
                if (config && config[`${newLang}_label`]) button.textContent = config[`${newLang}_label`];
            });
            if (this.state.currentMainButton) {
                const mainConfig = this.findMainButtonConfig(
                    this.state.currentMainButton.getAttribute('data-url')
                );
                if (mainConfig?.subButtons && mainConfig.subButtons.length > 0) {
                    window._headerV2_subNavManager.showSubNav();
                    this.renderSubButtons(
                        mainConfig.subButtons,
                        mainConfig.url || mainConfig.jsonFile,
                        newLang
                    );
                } else {
                    window._headerV2_subNavManager.hideSubNav();
                }
            } else {
                window._headerV2_subNavManager.hideSubNav();
            }
        } catch {
            window._headerV2_utils.showNotification('อัพเดทภาษาของปุ่มไม่สำเร็จ', 'error');
        }
    }
};

// ส่วนที่ 9: ScrollManager (Sticky sub-nav, scroll event, observer)

window._headerV2_scrollManager = {
    state: {
        lastScrollY: 0,
        ticking: false,
        subNavOffsetTop: 0,
        subNavHeight: 0,
        isSubNavFixed: false
    },
    constants: {
        SUB_NAV_TOP_SPACING: 0,
        ANIMATION_DURATION: 300,
        Z_INDEX: { SUB_NAV: 999 }
    },

    createStickyStyles() {
        const styleSheet = document.createElement('style');
        styleSheet.id = 'sticky-styles';
        styleSheet.textContent = `
        #sub-nav { position: sticky; top: ${this.constants.SUB_NAV_TOP_SPACING}px; left: 0; right: 0; z-index: ${this.constants.Z_INDEX.SUB_NAV}; transition: background ${this.constants.ANIMATION_DURATION}ms ease, box-shadow ${this.constants.ANIMATION_DURATION}ms ease, border-bottom ${this.constants.ANIMATION_DURATION}ms ease; will-change: background, box-shadow, border-bottom; border-radius: 0 0 20px 20px; transform: translateZ(0);}
        #sub-nav.fixed { box-shadow: 0 0 15px rgba(58, 60, 79, 0.15); background: rgba(240, 252, 255, 1); border-bottom: 1px solid rgba(19, 180, 127, 0.3); }
        #sub-nav.fixed #sub-buttons-container { padding: 5px !important; }
        `;
        document.head.appendChild(styleSheet);
    },

    handleSubNav() {
        const subNav = document.getElementById('sub-nav');
        if (!subNav) return;
        if (!this.state.subNavOffsetTop) {
            this.state.subNavOffsetTop = subNav.offsetTop;
            this.state.subNavHeight = subNav.offsetHeight;
        }
        const currentScroll = window.pageYOffset;
        const triggerPoint = this.state.subNavOffsetTop - this.constants.SUB_NAV_TOP_SPACING;
        if (currentScroll >= triggerPoint && !this.state.isSubNavFixed) {
            requestAnimationFrame(() => {
                subNav.classList.add('fixed');
                setTimeout(() => { subNav.classList.add('animate'); }, 10);
                this.state.isSubNavFixed = true;
            });
        } else if (currentScroll < triggerPoint && this.state.isSubNavFixed) {
            requestAnimationFrame(() => {
                subNav.classList.add('unfixing'); subNav.classList.add('animate');
                setTimeout(() => {
                    subNav.classList.remove('fixed', 'unfixing', 'animate');
                    this.state.isSubNavFixed = false;
                }, this.constants.ANIMATION_DURATION);
            });
        }
    },

    setupEventListeners() {
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            if (!this.state.ticking) {
                window.requestAnimationFrame(() => {
                    this.handleSubNav();
                    this.state.ticking = false;
                });
                this.state.ticking = true;
            }
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                this.state.lastScrollY = window.pageYOffset;
            }, 0);
        }, { passive: true });
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) this.handleSubNav();
        });
    },

    setupResizeObserver() {
        const resizeObserver = new ResizeObserver(entries => {
            entries.forEach(entry => {
                if (entry.target.id === 'sub-nav') {
                    this.state.subNavHeight = entry.contentRect.height;
                    this.state.subNavOffsetTop = entry.target.offsetTop;
                    this.handleSubNav();
                }
            });
        });
        const subNav = document.getElementById('sub-nav');
        if (subNav) resizeObserver.observe(subNav);
    },

    setupMutationObserver() {
        const mutationObserver = new MutationObserver(() => {
            const subNav = document.getElementById('sub-nav');
            if (subNav && !this.state.subNavOffsetTop) {
                this.state.subNavOffsetTop = subNav.offsetTop;
                this.state.subNavHeight = subNav.offsetHeight;
                this.handleSubNav();
            }
        });
        mutationObserver.observe(document.body, { childList: true, subtree: true });
    },

    handleInitialScroll() {
        if (window.pageYOffset > 0) this.handleSubNav();
    },

    init() {
        this.createStickyStyles();
        this.setupEventListeners();
        this.setupResizeObserver();
        this.setupMutationObserver();
        this.handleInitialScroll();
    }
};

// ส่วนที่ 10: PerformanceOptimizer (lazy loading image, prefetch, error boundary)

window._headerV2_performanceOptimizer = {
    setupLazyLoading() {
        if ('loading' in HTMLImageElement.prototype) {
            document.querySelectorAll('img').forEach(img => { img.loading = 'lazy'; });
        } else {
            // IntersectionObserver fallback
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                        }
                        observer.unobserve(img);
                    }
                });
            });
            document.querySelectorAll('img[data-src]').forEach(img => imageObserver.observe(img));
        }
    },
    
    setupPrefetching() {
        const prefetchLinks = new Set();
        document.querySelectorAll('a[href], button[data-url]').forEach(element => {
            const url = element.href || element.dataset.url;
            if (url && !prefetchLinks.has(url)) {
                const link = document.createElement('link');
                link.rel = 'prefetch';
                link.href = url;
                link.as = url.endsWith('.json') ? 'fetch' : 'document';
                document.head.appendChild(link);
                prefetchLinks.add(url);
            }
        });
    },
    
    setupErrorBoundary() {
        window.addEventListener('error', event => {
            window._headerV2_utils.showNotification('เกิดข้อผิดพลาดที่ไม่คาดคิด กรุณาลองใหม่อีกครั้ง', 'error');
        });
        
        window.addEventListener('unhandledrejection', event => {
            window._headerV2_utils.showNotification('เกิดข้อผิดพลาดในการเชื่อมต่อ กรุณาตรวจสอบอินเทอร์เน็ต', 'error');
        });
    },
    
    init() {
        this.setupLazyLoading();
        this.setupPrefetching();
        this.setupErrorBoundary();
    }
};

// ส่วนที่ 11: Main Startup/Initialize Function (เรียกใช้ทุก manager, event, ลบ overlay เมื่อ content พร้อม)

// ... ส่วนอื่นๆ คงเดิม ...

async function headerV2_initializeApp() {
    const appState = {
        isInitialized: false,
        lastError: null,
        startTime: Date.now(),
        eventRegistered: false
    };
    
    function safeNotify(msg, type = 'error') {
        if (window._headerV2_utils && typeof window._headerV2_utils.showNotification === 'function') {
            window._headerV2_utils.showNotification(msg, type);
        } else {
            console.warn('Notification:', msg);
        }
    }
    
    function verifyCoreElements() {
        const elements = window._headerV2_elements;
        if (!elements) throw new Error('Missing _headerV2_elements');
        if (!elements.header) throw new Error('Missing header element');
        if (!elements.navList) throw new Error('Missing navList');
        if (!elements.subButtonsContainer) throw new Error('Missing subButtonsContainer');
        if (!elements.contentLoading) throw new Error('Missing contentLoading');
    }
    
    function verifyManagers() {
        if (!window._headerV2_scrollManager) throw new Error('Missing scrollManager');
        if (!window._headerV2_performanceOptimizer) throw new Error('Missing performanceOptimizer');
        if (!window._headerV2_buttonManager) throw new Error('Missing buttonManager');
        if (!window._headerV2_contentManager) throw new Error('Missing contentManager');
        if (!window._headerV2_navigationManager) throw new Error('Missing navigationManager');
        if (!window._headerV2_dataManager) throw new Error('Missing dataManager');
    }
    
    try {
        // --- 1. ตรวจสอบโครงสร้างพื้นฐาน ---
        verifyCoreElements();
        verifyManagers();
        
        // --- 2. Setup Error Boundary ---
        window._headerV2_performanceOptimizer.setupErrorBoundary();
        
        // --- 3. Setup ScrollManager ---
        window._headerV2_scrollManager.init();
        
        // --- 4. Setup PerformanceOptimizer ---
        window._headerV2_performanceOptimizer.init();
        
        // --- 5. Event Registration (1 รอบ) ---
        if (!appState.eventRegistered) {
            // Network events
            window.addEventListener('online', () => {
                safeNotify('การเชื่อมต่อกลับมาแล้ว', 'success');
                if (appState.lastError) window._headerV2_buttonManager.loadConfig();
            }, { passive: true });
            
            window.addEventListener('offline', () => {
                safeNotify('ขาดการเชื่อมต่ออินเทอร์เน็ต', 'warning');
            }, { passive: true });
            
            // Popstate event
            window.addEventListener('popstate', async () => {
                try {
                    const url = window.location.search;
                    const navMgr = window._headerV2_navigationManager;
                    if (!navMgr) throw new Error('navigationManager missing');
                    if (!url || url === '?') {
                        const defaultRoute = await navMgr.getDefaultRoute();
                        await navMgr.navigateTo(defaultRoute, { skipUrlUpdate: true, isPopState: true });
                    } else {
                        await navMgr.navigateTo(url, { skipUrlUpdate: true, isPopState: true });
                    }
                } catch (e) {
                    safeNotify('เกิดข้อผิดพลาดในการนำทางย้อนกลับ', 'error');
                    console.error('popstate error', e);
                }
            }, { passive: true });
            
            // Language change
            window.addEventListener('languageChange', (event) => {
                const newLang = event.detail?.language || 'en';
                try {
                    if (window._headerV2_buttonManager.updateButtonsLanguage)
                        window._headerV2_buttonManager.updateButtonsLanguage(newLang);
                    if (window._headerV2_contentManager.updateCardsLanguage)
                        window._headerV2_contentManager.updateCardsLanguage(newLang);
                } catch (e) {
                    safeNotify('เกิดข้อผิดพลาดการเปลี่ยนภาษา', 'error');
                }
            }, { passive: true });
            
            // Resize event (debounced)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    try {
                        if (window._headerV2_navigationManager.scrollActiveButtonsIntoView)
                            window._headerV2_navigationManager.scrollActiveButtonsIntoView();
                    } catch (e) {
                        safeNotify('เกิดข้อผิดพลาด resize', 'error');
                    }
                }, 150);
            }, { passive: true });
            
            appState.eventRegistered = true;
        }
        
        // --- 6. Load button config & initial render ---
        try {
            await window._headerV2_buttonManager.loadConfig();
        } catch (e) {
            safeNotify('โหลดข้อมูลปุ่มไม่สำเร็จ', 'error');
            throw e;
        }
        
        // --- 7. Initial navigation (เช็ค route ปัจจุบัน) ---
        try {
            const navMgr = window._headerV2_navigationManager;
            const url = window.location.search;
            if (!url || url === '?') {
                const defaultRoute = await navMgr.getDefaultRoute();
                await navMgr.navigateTo(defaultRoute, { skipUrlUpdate: true });
            } else {
                await navMgr.navigateTo(url, { skipUrlUpdate: true });
            }
        } catch (e) {
            safeNotify('เกิดข้อผิดพลาดในการนำทางเริ่มต้น', 'error');
        }
        
        // --- 8. Remove loading overlay เมื่อพร้อมใช้งานจริง ---
        if (typeof window.__removeInstantLoadingOverlay === "function" && window.__instantLoadingOverlayShown) {
            window.__removeInstantLoadingOverlay();
            window.__instantLoadingOverlayShown = false;
        }
        
        appState.isInitialized = true;
    } catch (error) {
        appState.lastError = error;
        safeNotify('เกิดข้อผิดพลาดในการโหลดแอพพลิเคชัน กรุณารีเฟรชหน้าเว็บอีกครั้ง', 'error');
        try {
            window._headerV2_performanceOptimizer.setupErrorBoundary();
        } catch {}
        console.error('headerV2_initializeApp error', error);
    }
}

// เรียก initialize
headerV2_initializeApp();

/**
 * unifiedCopyToClipboard (เวอร์ชั่นแม่นยำและรวดเร็ว)
 * - ถ้ามี api code จะอ่าน database แล้วส่งข้อมูลครบถ้วน (แสดงชื่อในวงเล็บ)
 * - ถ้าไม่มี api code จะค้นหาข้อมูลที่คล้ายกันใน database ด้วยการเปรียบเทียบแบบ normalize และแบบ exact ก่อน
 *   - มีการ index ฐานข้อมูลล่วงหน้าเพื่อความเร็ว (สร้าง Map สำหรับ text, emoji, symbol, api)
 *   - ถ้าเจอ node แบบ exact จะใช้ทันที
 *   - ถ้าไม่เจอ exact จะค้นหาคล้ายกันแบบ Lowercase และ Trim
 *   - ถ้าไม่เจอเลย จะถือว่าเป็นอักษรพิเศษและแสดงตัวอักษรที่คัดลอก
 */

window.unifiedCopyToClipboard = async function(copyInfo = {}) {
    const lang = localStorage.getItem('selectedLang') || 'en';
    try {
        if (!copyInfo || !copyInfo.text) throw new Error('No content to copy');
        await navigator.clipboard.writeText(copyInfo.text);

        let notificationParams = {
            text: copyInfo.text,
            name: "",
            typeId: "emoji",
            lang
        };

        // โหลดฐานข้อมูลและสร้าง index ในหน่วยความจำเพื่อความเร็ว
        const db = await window._headerV2_dataManager.loadApiDatabase();

        // สร้าง Map สำหรับ text/emoji/api เพื่อค้นหาอย่างรวดเร็ว
        if (!window._headerV2_dataManager._copyIndex) {
            const textMap = new Map();
            const emojiMap = new Map();
            const apiMap = new Map();
            const symbolMap = new Map();

            function buildIndex(obj, parentTypeId) {
                if (Array.isArray(obj)) {
                    obj.forEach(item => buildIndex(item, parentTypeId));
                } else if (typeof obj === 'object' && obj !== null) {
                    let typeId = parentTypeId;
                    if (obj.id && obj.category && Array.isArray(obj.category)) {
                        typeId = obj.id;
                    }
                    if (obj.text) {
                        textMap.set(obj.text, obj);
                        const normalized = obj.text.trim().toLowerCase();
                        if (normalized.length === 1) emojiMap.set(normalized, obj);
                        if (normalized.length > 1) symbolMap.set(normalized, obj);
                    }
                    if (obj.api) apiMap.set(obj.api, obj);
                    if (obj.name) {
                        const nameNorm = (obj.name[lang] || obj.name.en || "").trim().toLowerCase();
                        if (nameNorm) symbolMap.set(nameNorm, obj);
                    }
                    for (const key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            buildIndex(obj[key], typeId);
                        }
                    }
                }
            }

            buildIndex(db?.type || db, "emoji");
            window._headerV2_dataManager._copyIndex = { textMap, emojiMap, apiMap, symbolMap };
        }

        const { textMap, emojiMap, apiMap, symbolMap } = window._headerV2_dataManager._copyIndex;

        // Helper: หา typeId และ name จาก code
        function findTypeIdAndName(obj, code, parentTypeId) {
            if (Array.isArray(obj)) {
                for (const item of obj) {
                    const result = findTypeIdAndName(item, code, parentTypeId);
                    if (result) return result;
                }
            } else if (typeof obj === 'object' && obj !== null) {
                if (obj.api === code) {
                    return {
                        typeId: parentTypeId,
                        name: obj.name?.[lang] || obj.name?.en || obj.api || ""
                    };
                }
                let newParentTypeId = parentTypeId;
                if (obj.id && obj.category && Array.isArray(obj.category)) {
                    newParentTypeId = obj.id;
                }
                for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        const result = findTypeIdAndName(obj[key], code, newParentTypeId);
                        if (result) return result;
                    }
                }
            }
            return null;
        }

        // ขั้นตอนหลัก
        if (copyInfo.api) {
            // มี api code แบบเร็ว
            const apiNode = apiMap.get(copyInfo.api) || null;
            let typeId = "emoji";
            let name = "";
            const typeResult = findTypeIdAndName(db?.type || db, copyInfo.api, "emoji");
            if (typeResult) {
                typeId = typeResult.typeId || "emoji";
                name = typeResult.name;
            } else if (apiNode) {
                name = apiNode.name?.[lang] || apiNode.name?.en || apiNode.api;
            }
            notificationParams = {
                text: apiNode?.text || copyInfo.text,
                name: name ? `${name}` : apiNode?.api || copyInfo.api,
                typeId,
                lang
            };
        } else {
            // ไม่มี api code
            // 1. exact match: emoji/symbol/text
            let node = textMap.get(copyInfo.text) || emojiMap.get(copyInfo.text.trim().toLowerCase()) || null;

            // 2. ถ้าไม่เจอ ลอง normalize (trim, lowercase)
            if (!node) {
                const norm = copyInfo.text.trim().toLowerCase();
                node = textMap.get(norm) || emojiMap.get(norm) || symbolMap.get(norm) || null;
            }

            // 3. ถ้าไม่เจอ exact/normalized ให้ลองค้นหาแบบคล้ายกัน (เช่น emoji/symbol ที่ประกอบด้วย text นี้)
            if (!node) {
                for (let [key, value] of textMap) {
                    if (key.trim().toLowerCase() === copyInfo.text.trim().toLowerCase()) {
                        node = value;
                        break;
                    }
                }
                if (!node) {
                    for (let [key, value] of emojiMap) {
                        if (key === copyInfo.text.trim().toLowerCase()) {
                            node = value;
                            break;
                        }
                    }
                }
            }

            if (node) {
                // เจอในฐานข้อมูล
                let typeId = "emoji";
                let name = "";
                let text = node.text || copyInfo.text;
                function getTypeFromParent(obj, targetNode, parentTypeId) {
                    if (Array.isArray(obj)) {
                        for (const item of obj) {
                            const result = getTypeFromParent(item, targetNode, parentTypeId);
                            if (result) return result;
                        }
                    } else if (typeof obj === 'object' && obj !== null) {
                        if (obj === targetNode) return parentTypeId;
                        let newParentTypeId = parentTypeId;
                        if (obj.id && obj.category && Array.isArray(obj.category)) {
                            newParentTypeId = obj.id;
                        }
                        for (const key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                const result = getTypeFromParent(obj[key], targetNode, newParentTypeId);
                                if (result) return result;
                            }
                        }
                    }
                    return null;
                }
                typeId = getTypeFromParent(db?.type || db, node, "emoji") || "emoji";
                name = node.name?.[lang] || node.name?.en || "";
                notificationParams = {
                    text,
                    name: name ? `${name}` : "",
                    typeId,
                    lang
                };
            } else {
                // ไม่เจอเลย ถือว่าเป็นอักษรพิเศษ
                notificationParams = {
                    text: copyInfo.text,
                    name: copyInfo.text || "",
                    typeId: "special-characters",
                    lang
                };
            }
        }

        // เรียกระบบแจ้งเตือน premium ที่พัฒนาไว้ (window.showCopyNotification)
        if (typeof window.showCopyNotification === "function") {
            window.showCopyNotification(notificationParams);
        } else {
            window._headerV2_utils.showNotification(notificationParams.text, "success", { duration: 2200 });
        }

    } catch (error) {
        window._headerV2_utils.showNotification(error.message || 'Copy failed', 'error');
    }
};