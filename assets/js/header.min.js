// header.min.js
// ✅ ปรับปรุง: Parallel module loading, improved error handling, robust module base resolution and diagnostics
(function() {
    // Resolve module base reliably from the script tag that loaded this file.
    function detectModuleBase() {
        try {
            // Try to find the script element that references header.min.js
            const scripts = document.getElementsByTagName('script');
            for (let i = 0; i < scripts.length; i++) {
                const s = scripts[i];
                if (s.src && s.src.indexOf('header.min.js') !== -1) {
                    return s.src.replace(/\/[^\/]*$/, '/header-modules/');
                }
            }
        } catch (e) {}
        // Fallback absolute path (project convention)
        return '/assets/js/header-modules/';
    }
    
    const MODULE_BASE = detectModuleBase();
    
    const MODULES = [
        'overlay.js',
        'utils.js',
        'dataManager.js',
        'contentLoadingManager.js',
        'contentManager.js',
        'managers.js',
        'unifiedCopyToClipboard.js',
        'init.js'
    ];
    
    async function loadAll() {
        try {
            // Parallel module loading (relative to resolved MODULE_BASE)
            const imports = MODULES.map(m => import(MODULE_BASE + m));
            const mods = await Promise.all(imports);
            
            // Find and execute init
            const initMod = mods.find(m => m && typeof m.init === 'function');
            const init = initMod || mods[mods.length - 1];
            if (init && typeof init.init === 'function') {
                await init.init();
            } else if (typeof window.headerV2_initializeApp === 'function') {
                await window.headerV2_initializeApp();
            }
        } catch (err) {
            console.error('header.min.js bootstrap error', err);
            
            // Diagnostic: attempt to fetch each module to show status/snippet (helps find HTML 404)
            try {
                const diag = await Promise.all(MODULES.map(async (m) => {
                    const url = MODULE_BASE + m;
                    try {
                        const resp = await fetch(url, { cache: 'no-store' });
                        const text = await resp.text();
                        return {
                            url,
                            status: resp.status,
                            ok: resp.ok,
                            contentSnippet: (typeof text === 'string') ? text.slice(0, 400) : ''
                        };
                    } catch (fetchErr) {
                        return { url, fetchError: String(fetchErr) };
                    }
                }));
                console.error('Module diagnostics:', diag);
            } catch (diagErr) {
                console.error('Diagnostics failed', diagErr);
            }
            
            try {
                if (window._headerV2_utils && window._headerV2_utils.showNotification) {
                    window._headerV2_utils.showNotification('โหลด header modules ไม่สำเร็จ', 'error');
                }
            } catch {}
        } finally {
            try {
                if (typeof window.__removeInstantLoadingOverlay === 'function' && window.__instantLoadingOverlayShown) {
                    window.__removeInstantLoadingOverlay();
                    window.__instantLoadingOverlayShown = false;
                }
            } catch {}
        }
    }
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadAll);
    } else {
        loadAll();
    }
})();