/**
 * header.js - Enhanced version (แก้ไขปัญหาการนำทางและ URL)
 */
 
// === [NEW CODE] Immediately show loading overlay to cover UI before anything else ===
// === [IMPROVED DESIGN] Immediate loading overlay - styled like ContentLoadingManager spinner ===
(function immediateLoadingOverlay() {
    // Overlay container
    const overlay = document.createElement('div');
    overlay.id = 'instant-loading-overlay';
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100vw';
    overlay.style.height = '100vh';
    overlay.style.background = 'rgba(255,255,255,0.94)';
    overlay.style.zIndex = '2147483647';
    overlay.style.display = 'flex';
    overlay.style.flexDirection = 'column';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';
    overlay.style.transition = 'opacity 0.36s cubic-bezier(.7,0,.7,1)';
    overlay.style.opacity = '1';
    
    // Spinner styles (match ContentLoadingManager)
    const style = document.createElement('style');
    style.textContent = `
        #instant-loading-overlay .content-loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            animation: content-loading-fade-in 0.3s ease-in;
        }
        #instant-loading-overlay .spinner-svg {
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #instant-loading-overlay .loading-message {
            font-size: 1.22rem;
            color: #2196f3;
            text-align: center;
            margin-top: 10px;
            font-weight: 500;
            letter-spacing: 0.04em;
            opacity: 0.92;
        }
        @keyframes content-loading-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes content-loading-fade-out {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        @keyframes instant-spinner-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        #instant-loading-overlay .spinner-svg-fg {
            stroke: #4285f4;
            stroke-width: 6;
            stroke-linecap: round;
            stroke-dasharray: 90 125;
            animation: instant-spinner-rotate 1s linear infinite;
        }
        #instant-loading-overlay .spinner-svg-bg {
            stroke: #eee;
            stroke-width: 6;
        }
    `;
    document.head.appendChild(style);
    
    // Overlay inner HTML (match ContentLoadingManager)
    overlay.innerHTML = `
        <div class="content-loading-spinner">
            <div class="spinner-svg" aria-label="loading">
                <svg width="48" height="48" viewBox="0 0 48 48" focusable="false">
                    <circle
                        class="spinner-svg-bg"
                        cx="24" cy="24" r="20"
                        fill="none"
                    />
                    <circle
                        class="spinner-svg-fg"
                        cx="24" cy="24" r="20"
                        fill="none"
                    />
                </svg>
            </div>
            <div class="loading-message">
                ${(localStorage.getItem('selectedLang') || 'en') === 'th'
                    ? 'กำลังโหลดเนื้อหา...'
                    : 'Loading content...'}
            </div>
        </div>
    `;
    document.body.appendChild(overlay);
    
    // Overlay removal logic: only allow to remove once, after first main content load
    let overlayRemoved = false;
    window.__removeInstantLoadingOverlay = function() {
        if (overlayRemoved) return;
        overlayRemoved = true;
        if (overlay) {
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.36s cubic-bezier(.7,0,.7,1)';
            setTimeout(() => {
                if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
                if (style.parentNode) style.parentNode.removeChild(style);
            }, 400);
        }
    };
    // Prevent overlay from ever displaying again without page reload
    window.__instantLoadingOverlayShown = true;
})();
// === [END NEW CODE] ===
 
document.addEventListener('DOMContentLoaded', () => {
    // ประกาศตัวแปรสำหรับใช้ทั้งไฟล์
    const state = {
        isRendering: false,
        debounceTimer: null,
        buttonConfig: null,
        cache: new Map(),
        navigationState: {
            isNavigating: false,
            currentMainRoute: '',
            currentSubRoute: '',
            isInitialLoad: true,
            previousUrl: ''
        }
    };

    // Element selectors
    const elements = {
        header: document.querySelector('header'),
        navButtons: document.querySelectorAll('nav ul li button'),
        logo: document.querySelector('.logo'),
        navList: document.getElementById('nav-list'),
        subButtonsContainer: document.getElementById('sub-buttons-container')
    };

    // Constants
    const CONSTANTS = {
        ANIMATION_DURATION: 300,
        SCROLL_THRESHOLD: 1.27,
        CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
        FETCH_TIMEOUT: 5000,
        RETRY_DELAY: 2000,
        MAX_RETRIES: 3
    };

// ระบบจัดการข้อผิดพลาดที่ปรับปรุงใหม่
class ErrorManager {
  constructor() {
    this.errorStates = new Map();
    this.timeouts = new Map();
  }

  // ตรวจสอบความถูกต้องของข้อผิดพลาด
  isValidError(error) {
    return error && (
      error instanceof Error ||
      error.message ||
      typeof error === 'string'
    );
  }

  // ตรวจสอบว่าเป็นข้อผิดพลาดเดิมหรือไม่
  isDuplicateError(errorKey, message) {
    const existingError = this.errorStates.get(errorKey);
    return existingError && existingError.message === message;
  }

  // จัดการแสดงข้อผิดพลาด
  showError(errorKey, error, options = {}) {
    if (!this.isValidError(error)) return;

    const message = error.message || error.toString();
    
    // ถ้าเป็นข้อผิดพลาดเดิม ไม่ต้องแสดงซ้ำ
    if (this.isDuplicateError(errorKey, message)) return;

    // เคลียร์ timeout เดิมถ้ามี
    if (this.timeouts.has(errorKey)) {
      clearTimeout(this.timeouts.get(errorKey));
    }

    // บันทึกสถานะข้อผิดพลาด
    this.errorStates.set(errorKey, {
      message,
      timestamp: Date.now(),
      type: options.type || 'error'
    });

    // แสดงข้อผิดพลาด
    utils.showNotification(message, options.type || 'error', {
      duration: options.duration || 3000,
      position: options.position || 'top',
      dismissible: options.dismissible !== false
    });

    // ตั้งเวลาลบสถานะข้อผิดพลาด
    const timeout = setTimeout(() => {
      this.errorStates.delete(errorKey);
      this.timeouts.delete(errorKey);
    }, options.duration || 3000);

    this.timeouts.set(errorKey, timeout);
  }

  // เคลียร์ข้อผิดพลาดทั้งหมด
  clearErrors() {
    this.errorStates.clear();
    this.timeouts.forEach(clearTimeout);
    this.timeouts.clear();
  }
}

// สร้าง instance เดียวสำหรับใช้ทั้งระบบ
const errorManager = new ErrorManager();

const utils = {
    // ค่าคงที่สำหรับการตั้งค่าต่างๆ
    CONSTANTS: {
        ANIMATION_DURATION: 300, // ระยะเวลาของ animation (ms)
        NOTIFICATION_DURATION: 3000, // ระยะเวลาแสดง notification (ms)
        DEBOUNCE_DELAY: 250, // ระยะเวลาหน่วง debounce (ms)
        THROTTLE_DELAY: 100, // ระยะเวลาหน่วง throttle (ms)
        MAX_CACHE_SIZE: 100, // ขนาดสูงสุดของ cache
        MAX_RETRIES: 3, // จำนวนครั้งสูงสุดในการลองใหม่
        ERROR_TIMEOUT: 5000 // ระยะเวลาแสดงข้อผิดพลาด (ms)
    },

    // ระบบ Cache
    cache: new Map(),

    // เก็บ notification ที่กำลังแสดงอยู่
    activeNotifications: new Set(),

    // ระบบจัดการข้อผิดพลาด
    errorHandling: {
        errors: new Map(),
        errorCount: 0,
        lastErrorTime: 0
    },

    /**
     * แสดง notification
     * @param {string} message - ข้อความที่จะแสดง
     * @param {string} type - ประเภท (success, error, warning, info)
     * @param {Object} options - ตัวเลือกเพิ่มเติม
     */
// แก้ไขฟังก์ชัน showNotification ในส่วนของ utils:
showNotification(message, type = 'info', options = {}) {
 const lang = localStorage.getItem('selectedLang') || 'en';
 
 // ข้อความในแต่ละภาษา
 const messages = {
  th: {
   success: '✨ สำเร็จ!',
   error: '❌ ข้อผิดพลาด',
   warning: '⚠️ คำเตือน',
   info: 'ℹ️ ข้อมูล',
   loading: '⌛ กำลังโหลด'
  },
  en: {
   success: '✨ Success!',
   error: '❌ Error',
   warning: '⚠️ Warning',
   info: 'ℹ️ Information',
   loading: '⌛ Loading'
  }
  // สามารถเพิ่มภาษาอื่นๆ ได้ตามต้องการ
 };
 
 try {
  // ลบ notification เก่าถ้ามีการระบุ key เดียวกัน
  if (options.key) {
   const existingNotification = document.querySelector(`.notification[data-key="${options.key}"]`);
   if (existingNotification) {
    existingNotification.style.animation = 'fadeOut 0.2s ease forwards';
    setTimeout(() => existingNotification.remove(), 200);
   }
  }
  
  // สร้าง notification ใหม่
  const notification = document.createElement('div');
  notification.className = `notification notification-${type}`;
  if (options.key) {
   notification.setAttribute('data-key', options.key);
  }
  notification.setAttribute('data-timestamp', Date.now());
  
  // สร้าง container สำหรับ animation
  const animContainer = document.createElement('div');
  animContainer.className = 'notification-anim-container';
  
  // สร้างไอคอน
  const icon = document.createElement('div');
  icon.className = 'notification-icon';
  icon.innerHTML = type === 'success' ? '✓' :
   type === 'error' ? '✕' :
   type === 'warning' ? '⚠' :
   type === 'loading' ? '⌛' : 'ℹ';
  
  // สร้างส่วนข้อความ
  const messageContainer = document.createElement('div');
  messageContainer.className = 'notification-message-container';
  messageContainer.innerHTML = `
            <div class="notification-title">${messages[lang][type]}</div>
            <div class="notification-content">${message}</div>
        `;
  
  // สร้างปุ่มปิดถ้า dismissible
  if (options.dismissible !== false) {
   const closeButton = document.createElement('button');
   closeButton.className = 'notification-close';
   closeButton.innerHTML = '×';
   closeButton.onclick = () => {
    notification.style.animation = 'slideOut 0.3s ease forwards';
    setTimeout(() => notification.remove(), 300);
   };
   animContainer.appendChild(closeButton);
  }
  
  animContainer.appendChild(icon);
  animContainer.appendChild(messageContainer);
  notification.appendChild(animContainer);
  
  // เพิ่ม styles ถ้ายังไม่มี
  if (!document.querySelector('#notification-styles')) {
   const style = document.createElement('style');
   style.id = 'notification-styles';
   style.textContent = `
                .notification {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 16px;
                    border-radius: 12px;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-20px);
                    animation: slideIn 0.3s ease forwards;
                    max-width: 400px;
                    backdrop-filter: blur(10px);
                    color: white;
                }

                .notification-success {
                    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
                }

                .notification-error {
                    background: linear-gradient(135deg, #f44336 0%, #e53935 100%);
                }

                .notification-warning {
                    background: linear-gradient(135deg, #ff9800 0%, #fb8c00 100%);
                }

                .notification-info {
                    background: linear-gradient(135deg, #2196f3 0%, #1e88e5 100%);
                }

                .notification-loading {
                    background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%);
                }

                .notification-anim-container {
                    display: flex;
                    align-items: center;
                    gap: 12px;
                }

                .notification-icon {
                    background: rgba(255,255,255,0.2);
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 18px;
                    animation: scaleIn 0.3s ease forwards;
                }

                .notification-message-container {
                    flex: 1;
                }

                .notification-title {
                    font-size: 16px;
                    font-weight: 600;
                    margin-bottom: 4px;
                }

                .notification-content {
                    font-size: 14px;
                    opacity: 0.9;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .notification-close {
                    background: none;
                    border: none;
                    color: white;
                    font-size: 20px;
                    cursor: pointer;
                    padding: 0;
                    width: 24px;
                    height: 24px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    opacity: 0.8;
                    transition: opacity 0.2s;
                }

                .notification-close:hover {
                    opacity: 1;
                }

                @keyframes slideIn {
                    from {
                        opacity: 0;
                        transform: translateY(-20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0);
                    }
                }

                @keyframes scaleIn {
                    from {
                        transform: scale(0);
                    }
                    to {
                        transform: scale(1);
                    }
                }

                @keyframes fadeOut {
                    from {
                        opacity: 1;
                        transform: translateY(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateY(-10px);
                    }
                }

                @keyframes slideOut {
                    from {
                        opacity: 1;
                        transform: translateY(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateY(-20px);
                    }
                }

                .notification-loading .notification-icon {
                    animation: spin 1s linear infinite;
                }

                @keyframes spin {
                    from {
                        transform: rotate(0deg);
                    }
                    to {
                        transform: rotate(360deg);
                    }
                }
            `;
   document.head.appendChild(style);
  }
  
  document.body.appendChild(notification);
  
  // ตั้งเวลาลบ notification ถ้าไม่ใช่ loading และมีการกำหนด duration
  if (type !== 'loading' && options.duration !== Infinity) {
   setTimeout(() => {
    if (document.body.contains(notification)) {
     notification.style.animation = 'slideOut 0.3s ease forwards';
     setTimeout(() => {
      if (document.body.contains(notification)) {
       notification.remove();
      }
     }, 300);
    }
   }, options.duration || 3000);
  }
  
  return notification;
 } catch (error) {
  console.error('Error showing notification:', error);
 }
},

    /**
     * ลบ notification
     */
    removeNotification(notification, key) {
        if (!document.body.contains(notification)) return;

        notification.style.opacity = '0';
        notification.style.transform = 'translateY(-20px)';

        setTimeout(() => {
            if (document.body.contains(notification)) {
                document.body.removeChild(notification);
                this.activeNotifications.delete(key);
            }
        }, 300);
    },

    /**
     * สร้างเนื้อหา notification
     */
    createNotificationContent(message, type, showIcon) {
        const content = document.createElement('div');
        content.className = 'notification-content';

        if (showIcon) {
            const icon = this.createIcon(type);
            content.appendChild(icon);
        }

        const messageElement = document.createElement('span');
        messageElement.className = 'notification-message';
        messageElement.textContent = message;
        content.appendChild(messageElement);

        return content;
    },

    /**
     * สร้างปุ่มปิด notification
     */
    createCloseButton(onClose) {
        const closeButton = document.createElement('button');
        closeButton.className = 'notification-close';
        closeButton.innerHTML = '×';
        closeButton.onclick = onClose;
        return closeButton;
    },

    /**
     * สร้าง progress bar
     */
    createProgressBar(duration) {
        const progress = document.createElement('div');
        progress.className = 'notification-progress';
        progress.style.animation = `notification-progress ${duration}ms linear`;
        return progress;
    },

    /**
     * สร้างไอคอน
     */
    createIcon(type) {
        const icon = document.createElement('span');
        icon.className = 'notification-icon';
        
        const iconContent = {
            success: '✓',
            error: '!',
            warning: '⚠',
            info: 'ℹ',
            loading: '+'
        };

        icon.textContent = iconContent[type] || 'ℹ';
        if (type === 'loading') {
            icon.style.animation = 'spin 1s linear infinite';
        }
        
        return icon;
    },

    /**
     * กำหนดตำแหน่ง notification
     */
    setNotificationPosition(notification, position) {
        const positions = {
            'top-right': { top: '20px', right: '20px' },
            'top-left': { top: '20px', left: '20px' },
            'bottom-right': { bottom: '20px', right: '20px' },
            'bottom-left': { bottom: '20px', left: '20px' },
            'top-center': { top: '20px', left: '50%', transform: 'translateX(-50%)' },
            'bottom-center': { bottom: '20px', left: '50%', transform: 'translateX(-50%)' }
        };

        const pos = positions[position] || positions['top-right'];
        Object.assign(notification.style, pos);
    },

    /**
     * จัดการ animation ของ notification
     */
    animateNotification(notification, duration) {
        requestAnimationFrame(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(-20px)';
            
            requestAnimationFrame(() => {
                notification.style.transition = `all ${duration}ms ease`;
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            });
        });
    },

    /**
     * Debounce function
     */
    debounce(func, wait = this.CONSTANTS.DEBOUNCE_DELAY) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    },

    /**
     * Throttle function
     */
    throttle(func, limit = this.CONSTANTS.THROTTLE_DELAY) {
        let inThrottle;
        return (...args) => {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    },

    /**
     * จัดการข้อผิดพลาด
     */
    handleError(error, context = '') {
        const now = Date.now();
        const errorKey = error.message || 'unknown';
        
        // เพิ่มจำนวนข้อผิดพลาด
        this.errorHandling.errorCount++;
        this.errorHandling.lastErrorTime = now;
        
        // บันทึกข้อผิดพลาด
        const currentErrors = this.errorHandling.errors.get(errorKey) || 0;
        this.errorHandling.errors.set(errorKey, currentErrors + 1);

        // แสดงข้อความแจ้งเตือน
        this.showNotification(
            `เกิดข้อผิดพลาด${context ? ' ใน' + context : ''}: ${error.message}`,
            'error',
            { duration: this.CONSTANTS.ERROR_TIMEOUT }
        );

        // ส่งข้อมูลไปยังระบบติดตามข้อผิดพลาด (ถ้ามี)
        if (this.errorHandling.errorCount > 5) {
            // แจ้งเตือนว่ามีข้อผิดพลาดมากเกินไป
            this.showNotification(
                'พบข้อผิดพลาดหลายครั้ง กรุณารีเฟรชหน้าเว็บ',
                'error',
                { duration: this.CONSTANTS.ERROR_TIMEOUT }
            );
        }
    },

    /**
     * เช็คการเชื่อมต่ออินเทอร์เน็ต
     */
    isOnline() {
        return navigator.onLine;
    },

    /**
     * จัดการ Cache
     */
    setCache(key, data, expiry = 5 * 60 * 1000) {
        if (this.cache.size >= this.CONSTANTS.MAX_CACHE_SIZE) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }

        this.cache.set(key, {
            data,
            expiry: Date.now() + expiry
        });
    },

    getCache(key) {
        const cached = this.cache.get(key);
        if (!cached) return null;

        if (Date.now() > cached.expiry) {
            this.cache.delete(key);
            return null;
        }

        return cached.data;
    },

    clearCache() {
        this.cache.clear();
    },

    /**
     * รีเซ็ตสถานะทั้งหมด
     */
    reset() {
        this.cache.clear();
        this.activeNotifications.clear();
        this.errorHandling.errors.clear();
        this.errorHandling.errorCount = 0;
        this.errorHandling.lastErrorTime = 0;
    }
};

// เพิ่ม CSS สำหรับ notifications
const style = document.createElement('style');
style.textContent = `
  .notification {
    position: fixed;
    padding: 12px;
    margin: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    z-index: 9999;
    background: white;
    min-width: 250px;
  }

  .notification-success { background-color: #4caf50; color: white; }
  .notification-error { background-color: #f44336; color: white; }
  .notification-warning { background-color: #ff9800; color: white; }
  .notification-info { background-color: #2196f3; color: white; }
  .notification-loading { background-color: #9e9e9e; color: white; }

  .notification-content {
    flex: 1;
    display: flex;
    align-items: center;
  }

  .notification-icon {
    margin-right: 8px;
    font-size: 18px;
  }

  .notification-message {
    flex: 1;
  }

  .notification-close {
    background: none;
    border: none;
    color: inherit;
    font-size: 20px;
    cursor: pointer;
    padding: 0 4px;
    margin-left: 8px;
  }

  .notification-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: rgba(255,255,255,0.3);
  }

  @keyframes notification-progress {
    from { width: 100%; }
    to { width: 0%; }
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
`;

document.head.appendChild(style);

// ... (rest of your code unchanged above) ...

/**
 * ฟังก์ชันคัดลอกแบบใหม่ (มาตรฐานเดียว ใช้ showCopyNotification)
 * - ถ้ามี api code จะอ่าน database แล้วส่งข้อมูลครบถ้วน (แสดงรหัส API ในวงเล็บหลังข้อมูล)
 * - ถ้าไม่มี api code จะส่ง text/type=symbol
 * - ปรับปรุงให้รองรับ typeId, name, ภาษา, และ animation แจ้งเตือนแบบ premium ที่พัฒนาไว้
 */
async function unifiedCopyToClipboard(copyInfo = {}) {
    const lang = localStorage.getItem('selectedLang') || 'en';
    try {
        if (!copyInfo || !copyInfo.text) throw new Error('No content to copy');
        await navigator.clipboard.writeText(copyInfo.text);

        // เตรียมค่าที่ส่งให้ showCopyNotification แบบละเอียดและมั่นใจว่า typeId ถูกต้อง
        let notificationParams = {
            text: copyInfo.text,
            name: "",
            typeId: "emoji", // default
            lang
        };

        if (copyInfo.api) {
            // Fetch database and search for the api node
            const db = await DataManager.fetchWithRetry('/assets/json/api-database.min.json');
            function findApiNode(obj, code) {
                if (Array.isArray(obj)) {
                    for (const item of obj) {
                        const found = findApiNode(item, code);
                        if (found) return found;
                    }
                } else if (typeof obj === 'object' && obj !== null) {
                    if (obj.api === code) return obj;
                    for (const key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            const found = findApiNode(obj[key], code);
                            if (found) return found;
                        }
                    }
                }
                return null;
            }
            const apiNode = findApiNode(db, copyInfo.api);

            if (apiNode) {
                // ดึง typeId จาก type.id ที่ครอบ apiNode
                let typeId = "emoji";
                let name = "";
                function findTypeIdAndName(obj, code, parentTypeId) {
                    if (Array.isArray(obj)) {
                        for (const item of obj) {
                            const result = findTypeIdAndName(item, code, parentTypeId);
                            if (result) return result;
                        }
                    } else if (typeof obj === 'object' && obj !== null) {
                        if (obj.api === code) {
                            return {
                                typeId: parentTypeId,
                                name: obj.name?.[lang] || obj.name?.en || obj.api || ""
                            };
                        }
                        // If this is a type node, set its id as parentTypeId
                        let newParentTypeId = parentTypeId;
                        if (obj.id && obj.category && Array.isArray(obj.category)) {
                            newParentTypeId = obj.id;
                        }
                        for (const key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                const result = findTypeIdAndName(obj[key], code, newParentTypeId);
                                if (result) return result;
                            }
                        }
                    }
                    return null;
                }
                const typeResult = findTypeIdAndName(db?.type || db, copyInfo.api, "emoji");
                if (typeResult) {
                    typeId = typeResult.typeId || "emoji";
                    name = typeResult.name;
                } else {
                    name = apiNode.name?.[lang] || apiNode.name?.en || apiNode.api;
                }

                notificationParams = {
                    text: apiNode.text,
                    name: name ? `${name} (${apiNode.api})` : apiNode.api,
                    typeId,
                    lang
                };
            } else {
                // ถ้าไม่เจอในฐานข้อมูล
                notificationParams = {
                    text: copyInfo.text,
                    name: copyInfo.api,
                    typeId: copyInfo.typeId || "symbol",
                    lang
                };
            }
        } else {
            notificationParams = {
                text: copyInfo.text,
                name: copyInfo.name || "",
                typeId: copyInfo.typeId || copyInfo.type || "symbol",
                lang
            };
        }

        // เรียกระบบแจ้งเตือน premium ที่พัฒนาไว้ (ต้องแน่ใจว่า window.showCopyNotification เป็นเวอร์ชันใหม่)
        if (typeof window.showCopyNotification === "function") {
            window.showCopyNotification(notificationParams);
        } else {
            // fallback (ไม่ควรเกิด)
            utils.showNotification(notificationParams.text, "success", { duration: 2200 });
        }

    } catch (error) {
        utils.showNotification(error.message || 'Copy failed', 'error');
    }
}

// ... (rest of your code unchanged below) ...

const NavigationManager = {
    // สถานะการนำทาง
    state: {
        isNavigating: false,
        currentMainRoute: '',
        currentSubRoute: '',
        isInitialLoad: true,
        previousUrl: '',
        lastScrollPosition: 0
    },

    history: [],
    maxHistory: 50,
    hasRecordedInitialHistory: false,

    // สร้าง/แยก/เทียบ URL รูปแบบใหม่
    normalizeUrl(url) {
        if (!url) return '';
        if (typeof url === 'object') {
            return `?type=${(url.type || '').toLowerCase()}__&page=${(url.page || '').toLowerCase()}`;
        }
        if (url.startsWith('?')) return url;
        if (url.includes('-')) {
            const [main, sub] = url.split('-');
            return `?type=${main}__&page=${sub || ''}`;
        }
        return `?type=${url}__`;
    },

    parseUrl() {
        const params = new URLSearchParams(window.location.search);
        const type = params.get('type');
        const page = params.get('page');
        return {
            main: type ? type.replace(/__$/, '') : '',
            sub: page || ''
        };
    },

    compareUrls(url1, url2) {
        return this.normalizeUrl(url1) === this.normalizeUrl(url2);
    },

    async validateUrl(url) {
        const { main, sub } = typeof url === 'object' ? url :
            (() => {
                if (url.startsWith('?')) {
                    const params = new URLSearchParams(url);
                    return {
                        main: (params.get('type') || '').replace(/__$/, ''),
                        sub: params.get('page') || ''
                    };
                } else if (url.includes('-')) {
                    const [m, s] = url.split('-');
                    return { main: m, sub: s || '' };
                } else {
                    return { main: url, sub: '' };
                }
            })();

        if (!state.buttonConfig) {
            await ButtonManager.loadConfig();
        }
        const mainButton = state.buttonConfig.mainButtons.find(
            btn => btn.url === main || btn.jsonFile === main
        );
        if (!mainButton) return false;
        if (sub) {
            return await this.validateSubRoute(mainButton, sub);
        }
        return true;
    },

    async validateSubRoute(mainButton, subRoute) {
        if (!mainButton || !subRoute) return false;
        if (!mainButton.subButtons) return false;
        return mainButton.subButtons.some(
            sub => sub.url === subRoute || sub.jsonFile === subRoute
        );
    },

    async getDefaultRoute() {
        if (!state.buttonConfig) {
            await ButtonManager.loadConfig();
        }
        const defaultMainButton = state.buttonConfig.mainButtons.find(btn => btn.isDefault);
        if (!defaultMainButton) return '';
        const mainRoute = defaultMainButton.url || defaultMainButton.jsonFile;
        if (!defaultMainButton.subButtons) return this.normalizeUrl(mainRoute);
        const defaultSubButton = defaultMainButton.subButtons.find(btn => btn.isDefault);
        if (!defaultSubButton) return this.normalizeUrl(mainRoute);
        const subRoute = defaultSubButton.url || defaultSubButton.jsonFile;
        return this.normalizeUrl({ type: mainRoute, page: subRoute });
    },

    async changeURL(url, force = false) {
        try {
            if (!url) return;
            const normalizedUrl = this.normalizeUrl(url);
            if (force || window.location.search !== normalizedUrl) {
                window.history.pushState(
                    {
                        url: normalizedUrl,
                        scrollPosition: this.state.lastScrollPosition
                    },
                    '',
                    normalizedUrl
                );
                this.state.previousUrl = normalizedUrl;
                window.dispatchEvent(new CustomEvent('urlChanged', {
                    detail: {
                        url: normalizedUrl,
                        mainRoute: this.state.currentMainRoute,
                        subRoute: this.state.currentSubRoute
                    }
                }));
            }
        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการเปลี่ยน URL:', error);
            throw new Error('ไม่สามารถเปลี่ยน URL ได้');
        }
    },

    async updateButtonStates(url) {
        const { main, sub } = url ? (
            url.startsWith('?') ? (() => {
                const params = new URLSearchParams(url);
                return {
                    main: (params.get('type') || '').replace(/__$/, ''),
                    sub: params.get('page') || ''
                };
            })() : (
                url.includes('-') ? (() => {
                    const [m, s] = url.split('-');
                    return { main: m, sub: s || '' };
                })() : { main: url, sub: '' }
            )
        ) : this.parseUrl();

        document.querySelectorAll('nav ul li button').forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-url') === main) {
                btn.classList.add('active');
            }
        });
        document.querySelectorAll('#sub-buttons-container button').forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-url') === `${main}-${sub}`) {
                btn.classList.add('active');
            }
        });
        this.scrollActiveButtonsIntoView();
    },

    async navigateTo(route, options = {}) {
        // รองรับ string ที่เป็น URL search (?type=...&page=...)
        let normalizedRoute = route;
        if (typeof route === 'string' && route.startsWith('?')) {
            normalizedRoute = this.normalizeUrl(route);
        }
        if (typeof route === 'object') {
            normalizedRoute = this.normalizeUrl(route);
        }

        if (this.state.isNavigating) {
            console.log('กำลังนำทางอยู่ กรุณารอสักครู่...');
            return;
        }
        try {
            this.state.isNavigating = true;
            this.state.lastScrollPosition = window.pageYOffset;

            // ตรวจสอบความถูกต้องของ URL
            let isValidUrl = false;
            try {
                isValidUrl = await this.validateUrl(normalizedRoute);
            } catch (e) {
                console.error("การตรวจสอบ URL ล้มเหลว:", e);
            }
            if (!isValidUrl) {
                // ถ้า URL ไม่มีใน config ให้ไป default route
                console.warn('URL ไม่ถูกต้อง จะใช้ default route แทน');
                try {
                    normalizedRoute = await this.getDefaultRoute();
                } catch (e) {
                    console.error("ไม่สามารถดึง default route ได้:", e);
                    throw new Error('ไม่สามารถดึง default route ได้');
                }
            }

            // แยก main/sub จาก normalizedRoute
            const { main, sub } = typeof normalizedRoute === 'object'
                ? normalizedRoute
                : normalizedRoute.startsWith('?')
                    ? (() => {
                        const params = new URLSearchParams(normalizedRoute);
                        return {
                            main: (params.get('type') || '').replace(/__$/, ''),
                            sub: params.get('page') || ''
                        };
                    })()
                    : normalizedRoute.includes('-')
                        ? (() => {
                            const [m, s] = normalizedRoute.split('-');
                            return { main: m, sub: s || '' };
                        })()
                        : { main: normalizedRoute, sub: '' };

            const previousMainRoute = this.state.currentMainRoute;
            const previousSubRoute = this.state.currentSubRoute;
            this.state.currentMainRoute = main;
            this.state.currentSubRoute = sub || '';

            // อัปเดท URL ถ้าไม่ได้ข้าม
            if (!options.skipUrlUpdate) {
                try {
                    await this.changeURL({ type: main, page: sub });
                } catch (urlError) {
                    console.error("การเปลี่ยน URL ล้มเหลว:", urlError);
                    utils.showNotification('ไม่สามารถเปลี่ยน URL ได้', 'error');
                }
            }

            // หา main button
            const mainButton = state.buttonConfig.mainButtons.find(btn =>
                btn.url === main || btn.jsonFile === main
            );
            if (!mainButton) {
                console.error(`ไม่พบปุ่มหลักสำหรับ route: ${main}`);
                throw new Error(`ไม่พบปุ่มหลักสำหรับ route: ${main}`);
            }

            // ตรวจสอบว่ามี subButtons หรือไม่
            let subButton = null;
            if (mainButton.subButtons && mainButton.subButtons.length > 0) {
                subButton = mainButton.subButtons.find(
                    btn => btn.url === sub || btn.jsonFile === sub
                );
                if (!subButton) {
                    subButton = mainButton.subButtons.find(btn => btn.isDefault) || mainButton.subButtons[0];
                    this.state.currentSubRoute = subButton.url || subButton.jsonFile;
                }
                elements.subButtonsContainer.innerHTML = "";
                await ButtonManager.renderSubButtons(
                    mainButton.subButtons,
                    main,
                    localStorage.getItem('selectedLang') || 'en'
                );
            } else {
                elements.subButtonsContainer.innerHTML = "";
            }

            await this.loadMainAndSubParallel(mainButton, subButton);

            try {
                await this.updateButtonStates(this.normalizeUrl({ type: main, page: sub }));
            } catch (updateStateError) {
                console.error("การอัพเดทสถานะของปุ่มล้มเหลว:", updateStateError);
            }

            if (!options.maintainScroll) {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        } catch (error) {
            ContentLoadingManager.hide();
            console.error('เกิดข้อผิดพลาดในการนำทาง:', error);
            utils.showNotification('เกิดข้อผิดพลาดในการนำทาง', 'error');
            throw error;
        } finally {
            ContentLoadingManager.hide();
            this.state.isNavigating = false;
        }
    },

    async loadMainAndSubParallel(mainButton, subButton) {
        try {
            const jobs = [];
            if (mainButton?.jsonFile) {
                jobs.push(DataManager.fetchWithRetry(mainButton.jsonFile));
            }
            if (subButton?.jsonFile) {
                jobs.push(DataManager.fetchWithRetry(subButton.jsonFile));
            }
            const results = await Promise.all(jobs);
            if (results.length === 2) {
                await ContentManager.renderContent([...results[0], ...results[1]]);
            } else if (results.length === 1) {
                await ContentManager.renderContent(results[0]);
            }
        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการโหลดเนื้อหา main/sub:', error);
        }
    },

    handleRefresh() {
        const urlObj = this.parseUrl();
        if (urlObj.main) {
            this.navigateTo({ type: urlObj.main, page: urlObj.sub }, { skipUrlUpdate: true });
        } else {
            this.navigateTo(this.getDefaultRoute());
        }
    },

    validateElements() {
        const required = ['header', 'navButtons', 'logo', 'navList', 'subButtonsContainer'];
        const missing = required.filter(key => !elements[key]);
        if (missing.length > 0) {
            console.warn('ไม่พบ elements ที่จำเป็น:', missing.join(', '));
            return false;
        }
        return true;
    },

    scrollActiveButtonsIntoView() {
        try {
            ['nav ul', '#sub-buttons-container'].forEach(selector => {
                const container = document.querySelector(selector);
                if (!container) return;
                const activeButton = container.querySelector('button.active');
                if (!activeButton) return;
                requestAnimationFrame(() => {
                    try {
                        const containerBounds = container.getBoundingClientRect();
                        const buttonBounds = activeButton.getBoundingClientRect();
                        const scrollLeft = container.scrollLeft +
                            (buttonBounds.left - containerBounds.left) - 20;
                        container.scrollTo({
                            left: Math.max(0, scrollLeft),
                            behavior: 'smooth'
                        });
                    } catch (error) {
                        console.warn('เกิดข้อผิดพลาดในการเลื่อนปุ่ม:', error);
                    }
                });
            });
        } catch (error) {
            console.warn('เกิดข้อผิดพลาดในฟังก์ชัน scrollActiveButtonsIntoView:', error);
        }
    },

    reset() {
        this.state = {
            isNavigating: false,
            currentMainRoute: '',
            currentSubRoute: '',
            isInitialLoad: true,
            previousUrl: '',
            lastScrollPosition: 0
        };
        this.history = [];
        this.hasRecordedInitialHistory = false;
    }
};

// แก้ไขเป็น:
window.addEventListener('resize', () => {
 NavigationManager.scrollActiveButtonsIntoView();
});

// เพิ่ม Event Listener สำหรับการโหลดหน้าเว็บครั้งแรก
document.addEventListener('DOMContentLoaded', () => {
 NavigationManager.updateButtonStates();
});

/** --- ปรับปรุง ContentLoadingManager: ไม่มี CSS ฝังใน JS เลย --- */
const ContentLoadingManager = {
    spinnerElement: null,
    LOADING_CONTAINER_ID: 'content-loading',
    
    createSpinner(message = '') {
        if (this.spinnerElement && document.body.contains(this.spinnerElement)) {
            this.updateMessage(message);
            return this.spinnerElement;
        }
        const spinner = document.createElement('div');
        spinner.className = 'content-loading-spinner content-loading-fade-in'; // เพิ่มคลาส fade-in เริ่มต้น
        
        spinner.innerHTML = `
            <div class="spinner-svg" aria-label="loading">
                <svg width="48" height="48" viewBox="0 0 48 48" focusable="false">
                    <circle
                        class="spinner-svg-bg"
                        cx="24" cy="24" r="20"
                        fill="none"
                        stroke="#eee"
                        stroke-width="6"
                    />
                    <circle
                        class="spinner-svg-fg"
                        cx="24" cy="24" r="20"
                        fill="none"
                        stroke="#4285f4"
                        stroke-width="6"
                        stroke-linecap="round"
                        stroke-dasharray="90 125"
                        stroke-dashoffset="0"
                    />
                </svg>
            </div>
            <div class="loading-message">${message || this.getDefaultMessage()}</div>
        `;
        this.spinnerElement = spinner;
        return spinner;
    },
    
    show(message = '') {
        const container = document.getElementById(this.LOADING_CONTAINER_ID);
        if (!container) return;
        this.hide();
        
        const spinner = this.createSpinner(message);
        // ลบ class fade-out เผื่อมีค้างอยู่
        spinner.classList.remove('content-loading-fade-out');
        spinner.classList.add('content-loading-fade-in');
        container.appendChild(spinner);
    },
    
    hide() {
        if (this.spinnerElement && this.spinnerElement.parentNode) {
            // เพิ่ม class fade-out และรอ animation จบก่อนลบ
            this.spinnerElement.classList.remove('content-loading-fade-in');
            this.spinnerElement.classList.add('content-loading-fade-out');
            const spinnerToRemove = this.spinnerElement;
            // รอ animationend หรือ fallback ที่ 400ms
            const removeSpinner = () => {
                if (spinnerToRemove.parentNode) spinnerToRemove.parentNode.removeChild(spinnerToRemove);
                if (this.spinnerElement === spinnerToRemove) this.spinnerElement = null;
            };
            spinnerToRemove.addEventListener('animationend', removeSpinner, { once: true });
            setTimeout(removeSpinner, 400);
        } else {
            this.spinnerElement = null;
        }
    },
    
    updateMessage(message = '') {
        if (this.spinnerElement) {
            const msg = this.spinnerElement.querySelector('.loading-message');
            if (msg) msg.textContent = message || this.getDefaultMessage();
        }
    },
    
    getDefaultMessage() {
        const lang = localStorage.getItem('selectedLang') || 'en';
        return lang === 'th' ? 'กำลังโหลดเนื้อหา...' : 'Loading content...';
    }
};

const ContentManager = {
    /**
     * ล้างเนื้อหาใน container หลัก (id="content-loading") และซ่อน spinner
     */
    async clearContent() {
        const container = document.getElementById(ContentLoadingManager.LOADING_CONTAINER_ID);
        if (container) {
            container.innerHTML = '';
        }
        ContentLoadingManager.hide();
    },

    /**
     * Render ข้อมูลเนื้อหา (array) ลง container หลัก พร้อมแสดง spinner ระหว่างโหลด
     * @param {Array} data - array ของเนื้อหาที่ต้อง render
     */
    async renderContent(data) {
        if (!Array.isArray(data)) {
            throw new AppError('ข้อมูลที่ได้รับไม่ใช่อาร์เรย์', 'render');
        }
        const container = document.getElementById(ContentLoadingManager.LOADING_CONTAINER_ID);
        if (!container) return;
        await this.clearContent();
        ContentLoadingManager.show();
        state.isRendering = true;
        try {
            await new Promise(resolve => setTimeout(resolve, 50));
            await Promise.all(
                data.map(async item => {
                    const element = document.createElement('div');
                    element.id = item.id;
                    container.appendChild(element);
                    const innerContainer = this.createContainer(item);

                    // 1. group แบบ categoryId (สร้างหมวดหมู่เป็นกรุ๊ปใหม่)
                    if (item.group?.categoryId) {
                        await this.renderGroupItems(innerContainer, item.group);
                    }
                    // 2. categoryId ตรงใน item (ไม่รองรับหลายหมวดใน group)
                    else if (item.categoryId) {
                        await this.renderGroupItems(innerContainer, { categoryId: item.categoryId, type: item.type || "button" });
                    }
                    // 3. เนื้อหาเดี่ยวปกติ
                    else {
                        await this.renderSingleItem(innerContainer, item);
                    }
                    element.appendChild(innerContainer);
                })
            );
        } finally {
            ContentLoadingManager.hide();
            state.isRendering = false;
        }
    },

    /**
     * สร้าง container สำหรับแต่ละเนื้อหา
     */
    createContainer(item) {
        const container = document.createElement('div');
        container.className =
            item.group?.type === 'button' || item.type === 'button'
                ? 'button-content-container'
                : 'card-content-container';

        if (item.group?.containerClass) {
            container.classList.add(item.group.containerClass);
        }
        return container;
    },

    /**
     * Render กลุ่มเนื้อหา (group) สำหรับ categoryId เท่านั้น
     * group: { categoryId: "xxx_category", type: "button" }
     */
    async renderGroupItems(container, group) {
        if (!group.categoryId) throw new Error("Group ต้องระบุ categoryId");

        // ดึงข้อมูล category group
        const { id, name, data, header } = await DataManager.fetchCategoryGroup(group.categoryId);

        // header อัตโนมัติ
        const headerElement = this.createGroupHeader(header);
        container.appendChild(headerElement);

        // type รองรับเฉพาะ button (แต่ field type ต้องมีเพื่ออนาคต)
        if (group.type !== "button") throw new Error("ขณะนี้รองรับเฉพาะ type: 'button' ใน group");

        // render ทุก item เป็น button
        const buttons = await Promise.all(data.map(item => this.createButton(item)));
        buttons.forEach(btn => btn && container.appendChild(btn));
    },

    /**
     * สร้าง Group Header
     */
    createGroupHeader(headerConfig) {
        const headerContainer = document.createElement('div');
        headerContainer.className = 'group-header';
        const currentLang = localStorage.getItem('selectedLang') || 'en';

        if (typeof headerConfig === 'string') {
            return this.createSimpleHeader(headerConfig, headerContainer);
        }
        if (headerConfig.className) {
            headerContainer.classList.add(headerConfig.className);
        }
        this.createHeaderComponents(headerContainer, headerConfig, currentLang);
        this.addLanguageChangeListener(headerContainer, headerConfig);
        return headerContainer;
    },

    createSimpleHeader(text, container) {
        const headerText = document.createElement('h2');
        headerText.className = 'group-header-text';
        headerText.textContent = text;
        container.appendChild(headerText);
        return container;
    },

    createHeaderComponents(container, config, currentLang) {
        if (config.icon) {
            container.appendChild(this.createHeaderIcon(config.icon));
        }
        const headerContent = document.createElement('div');
        headerContent.className = 'header-content';
        const title = this.createHeaderTitle(config, currentLang);
        headerContent.appendChild(title);
        if (config.description) {
            const desc = this.createHeaderDescription(config.description, currentLang);
            headerContent.appendChild(desc);
        }
        container.appendChild(headerContent);
        if (config.actions) {
            container.appendChild(this.createHeaderActions(config.actions, currentLang));
        }
    },

    createHeaderTitle(config, currentLang) {
        const title = document.createElement('h2');
        title.className = 'group-header-text';
        if (typeof config.title === 'object') {
            Object.entries(config.title).forEach(([lang, text]) => {
                title.dataset[`title${lang.toUpperCase()}`] = text;
            });
            title.textContent = config.title[currentLang] || config.title.en;
        } else {
            title.textContent = config.title;
        }
        return title;
    },

    createHeaderDescription(description, currentLang) {
        const desc = document.createElement('p');
        desc.className = 'group-header-description';
        if (typeof description === 'object') {
            Object.entries(description).forEach(([lang, text]) => {
                desc.dataset[`desc${lang.toUpperCase()}`] = text;
            });
            desc.textContent = description[currentLang] || description.en;
        } else {
            desc.textContent = description;
        }
        return desc;
    },

    addLanguageChangeListener(container, config) {
        window.addEventListener('languageChange', event => {
            const newLang = event.detail.language;
            this.updateHeaderLanguage(container, config, newLang);
        });
    },

    updateHeaderLanguage(container, config, newLang) {
        const titleElement = container.querySelector('.group-header-text');
        if (titleElement && config.title) {
            if (typeof config.title === 'object') {
                titleElement.textContent =
                    config.title[newLang] || config.title.en || titleElement.textContent;
            }
        }
        const descElement = container.querySelector('.group-header-description');
        if (descElement && config.description) {
            if (typeof config.description === 'object') {
                descElement.textContent =
                    config.description[newLang] ||
                    config.description.en ||
                    descElement.textContent;
            }
        }
    },

    /**
     * Render เนื้อหาเดี่ยว (button/card)
     */
    async renderSingleItem(container, item) {
        // รองรับ item.categoryId ในเนื้อหาเดี่ยว (จะใช้ group logic ไปเลย)
        if (item.categoryId) {
            await this.renderGroupItems(container, { categoryId: item.categoryId, type: item.type || "button" });
            return;
        }
        const element =
            item.type === 'button'
                ? await this.createButton(item)
                : await this.createCard(item);
        if (element) container.appendChild(element);
    },

    /**
     * สร้างปุ่ม (button) ที่สามารถ copy ข้อความได้
     */
    async createButton(config) {
        const button = document.createElement('button');
        button.className = 'button-content';
        let finalContent = '';
        let apiCode = config.api || null;
        let type = config.type || null;
        try {
            if (apiCode) {
                const db = await DataManager.fetchWithRetry('/assets/json/api-database.min.json');
                function findApiNode(obj, code) {
                    if (Array.isArray(obj)) {
                        for (const item of obj) {
                            const found = findApiNode(item, code);
                            if (found) return found;
                        }
                    } else if (typeof obj === 'object' && obj !== null) {
                        if (obj.api === code) return obj;
                        for (const key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                const found = findApiNode(obj[key], code);
                                if (found) return found;
                            }
                        }
                    }
                    return null;
                }
                const apiNode = findApiNode(db, apiCode);
                if (apiNode) {
                    finalContent = apiNode.text;
                    type = type || (apiNode.api ? 'emoji' : 'symbol');
                } else {
                    finalContent = apiCode;
                }
            } else if (config.content) {
                finalContent = config.content;
                type = 'symbol';
            } else if (config.text) {
                finalContent = config.text;
                type = 'symbol';
            } else {
                throw new Error('ต้องระบุ api, content หรือ text สำหรับ button content type');
            }
            button.textContent = finalContent;
        } catch (error) {
            console.error('Error creating button:', error);
            button.textContent = 'Error';
        }
        const wrapper = document.createElement('div');
        wrapper.appendChild(button);
        button.addEventListener('click', async () => {
            await unifiedCopyToClipboard({
                text: finalContent,
                api: apiCode,
                type,
                name: apiCode ? `${apiCode}` : ''
            });
        });
        return this.animateElement(wrapper);
    },

    /**
     * สร้างการ์ดเนื้อหา (card) สำหรับอนาคต
     */
    async createCard(cardConfig) {
        const lang = localStorage.getItem('selectedLang') || 'en';
        const card = document.createElement('div');
        card.className = 'card';

        if (cardConfig.image) {
            const img = document.createElement('img');
            img.className = 'card-image';
            img.src = cardConfig.image;
            img.loading = 'lazy';
            img.alt =
                cardConfig.imageAlt?.[lang] ||
                cardConfig.imageAlt?.en ||
                '';
            card.appendChild(img);
        }

        const contentDiv = document.createElement('div');
        contentDiv.className = 'card-content';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'card-title';
        if (typeof cardConfig.title === 'object') {
            Object.entries(cardConfig.title).forEach(([langCode, text]) => {
                titleDiv.dataset[`title${langCode.toUpperCase()}`] = text;
            });
            titleDiv.textContent = cardConfig.title[lang] || cardConfig.title.en;
        } else if (cardConfig.name && typeof cardConfig.name === 'object') {
            titleDiv.textContent = cardConfig.name[lang] || cardConfig.name.en;
        } else {
            titleDiv.textContent = cardConfig.title || cardConfig.name || '';
        }
        contentDiv.appendChild(titleDiv);

        const descDiv = document.createElement('div');
        descDiv.className = 'card-description';
        if (typeof cardConfig.description === 'object') {
            Object.entries(cardConfig.description).forEach(([langCode, text]) => {
                descDiv.dataset[`desc${langCode.toUpperCase()}`] = text;
            });
            descDiv.textContent = cardConfig.description[lang] || cardConfig.description.en;
        } else if (cardConfig.name && typeof cardConfig.name === 'object') {
            descDiv.textContent = cardConfig.name[lang] || cardConfig.name.en;
        } else {
            descDiv.textContent = cardConfig.description || '';
        }
        contentDiv.appendChild(descDiv);

        card.appendChild(contentDiv);

        if (cardConfig.link) {
            card.addEventListener('click', () => {
                window.open(cardConfig.link, '_blank', 'noopener');
            });
        }

        if (cardConfig.className) {
            card.classList.add(cardConfig.className);
        }

        return this.animateElement(card);
    },

    /**
     * อัพเดทการ์ดเมื่อเปลี่ยนภาษา
     */
    updateCardsLanguage(lang) {
        document.querySelectorAll('.card').forEach(card => {
            const titleElement = card.querySelector('.card-title');
            if (titleElement) {
                const newTitle = titleElement.dataset[`title${lang.toUpperCase()}`];
                if (newTitle) {
                    titleElement.textContent = newTitle;
                }
            }
            const descElement = card.querySelector('.card-description');
            if (descElement) {
                const newDesc = descElement.dataset[`desc${lang.toUpperCase()}`];
                if (newDesc) {
                    descElement.textContent = newDesc;
                }
            }
            const imgElement = card.querySelector('.card-image');
            if (imgElement) {
                const newAlt = imgElement.dataset[`alt${lang.toUpperCase()}`];
                if (newAlt) {
                    imgElement.alt = newAlt;
                }
            }
        });
    },

    /**
     * ใส่ animation ให้ element
     */
    async animateElement(element) {
        return new Promise(resolve => {
            requestAnimationFrame(() => {
                const handleAnimationEnd = () => {
                    element.removeEventListener('animationend', handleAnimationEnd);
                    resolve(element);
                };
                element.addEventListener('animationend', handleAnimationEnd);
                element.classList.add('fade-in');
                setTimeout(() => handleAnimationEnd(), CONSTANTS.ANIMATION_DURATION);
            });
        });
    }
};

const DataManager = {
    constants: {
        FETCH_TIMEOUT: 8000,
        RETRY_DELAY: 2000,
        MAX_RETRIES: 3,
        CACHE_DURATION: 5 * 60 * 1000,
        BATCH_SIZE: 10,
        MAX_CACHE_SIZE: 100,
        API_DATABASE_PATH: '/assets/json/api-database.min.json'
    },

    messages: {
        th: {
            loading: 'กำลังโหลดข้อมูล...',
            retrying: 'กำลังลองใหม่... (ครั้งที่ {attempt}/{max})',
            error: 'เกิดข้อผิดพลาดในการโหลดข้อมูล',
            offline: 'ไม่มีการเชื่อมต่ออินเทอร์เน็ต กรุณาตรวจสอบการเชื่อมต่อ',
            timeout: 'การโหลดข้อมูลใช้เวลานานเกินไป',
            cacheCleared: 'ล้างแคชเรียบร้อย',
            batchLoading: 'กำลังโหลด {current}/{total}',
            batchError: 'เกิดข้อผิดพลาดในการโหลดบางส่วน แต่จะดำเนินการต่อ',
            invalidData: 'ข้อมูลไม่ถูกต้อง',
            networkError: 'เกิดข้อผิดพลาดในการเชื่อมต่อ',
            apiNotFound: 'ไม่พบข้อมูลสำหรับ API code: {code}',
            apiDatabaseError: 'เกิดข้อผิดพลาดในการโหลดฐานข้อมูล API',
            invalidApiData: 'ข้อมูล API ไม่ถูกต้อง',
            categoryNotFound: 'ไม่พบ category id: {id}'
        },
        en: {
            loading: 'Loading data...',
            retrying: 'Retrying... (Attempt {attempt}/{max})',
            error: 'Error loading data',
            offline: 'No internet connection. Please check your connection.',
            timeout: 'Request timeout',
            cacheCleared: 'Cache cleared successfully',
            batchLoading: 'Loading {current}/{total}',
            batchError: 'Error loading some items, but continuing',
            invalidData: 'Invalid data received',
            networkError: 'Network connection error',
            apiNotFound: 'API code not found: {code}',
            apiDatabaseError: 'Error loading API database',
            invalidApiData: 'Invalid API data',
            categoryNotFound: 'Category id not found: {id}'
        }
    },

    cache: new Map(),
    apiCache: null,
    apiCacheTimestamp: 0,
    loadingStates: new Map(),

    getMessage(key, params = {}) {
        const currentLang = localStorage.getItem('selectedLang') || 'en';
        let message = this.messages[currentLang]?.[key] || this.messages['en'][key];
        Object.entries(params).forEach(([k, v]) => {
            message = message.replace(`{${k}}`, v);
        });
        return message;
    },

    isOnline() { return navigator.onLine; },

    isCacheExpired(timestamp) {
        return Date.now() - timestamp > this.constants.CACHE_DURATION;
    },

    getCached(key) {
        const cached = this.cache.get(key);
        if (!cached) return null;
        if (this.isCacheExpired(cached.timestamp)) {
            this.cache.delete(key);
            return null;
        }
        return cached.data;
    },

    setCache(key, data) {
        if (this.cache.size >= this.constants.MAX_CACHE_SIZE) {
            let oldestKey = null;
            let oldestTime = Date.now();
            for (const [k, v] of this.cache.entries()) {
                if (v.timestamp < oldestTime) {
                    oldestKey = k;
                    oldestTime = v.timestamp;
                }
            }
            if (oldestKey) this.cache.delete(oldestKey);
        }
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    },

    clearCache() {
        this.cache.clear();
        this.apiCache = null;
        this.apiCacheTimestamp = 0;
        utils.showNotification(
            this.getMessage('cacheCleared'),
            'success',
            { duration: 3000 }
        );
    },

    clearExpiredCache() {
        for (const [key, value] of this.cache.entries()) {
            if (this.isCacheExpired(value.timestamp)) {
                this.cache.delete(key);
            }
        }
        if (this.apiCache && this.isCacheExpired(this.apiCacheTimestamp)) {
            this.apiCache = null;
            this.apiCacheTimestamp = 0;
        }
    },

    buildUrl(baseUrl, params = {}) {
        try {
            const url = new URL(baseUrl, window.location.origin);
            Object.entries(params).forEach(([key, value]) => {
                if (value !== undefined && value !== null) {
                    url.searchParams.append(key, value);
                }
            });
            return url.toString();
        } catch (error) {
            throw new Error(`ไม่สามารถสร้าง URL ได้: ${error.message}`);
        }
    },

    /**
     * ดึงข้อมูลขนาดใหญ่ เร็วสุดด้วย stream + Web Worker + concurrent fetch
     */
    async fetchWithRetry(url, options = {}) {
        const key = `${url}-${JSON.stringify(options)}`;
        const cachedData = this.getCached(key);
        if (cachedData) return cachedData;

        let lastError;
        for (let attempt = 1; attempt <= this.constants.MAX_RETRIES; attempt++) {
            try {
                if (!this.isOnline()) throw new Error(this.getMessage('offline'));

                const controller = new AbortController();
                const fetchPromise = fetch(url, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    signal: controller.signal
                });

                if ('keepalive' in Request.prototype) {
                    fetch(url, { method: 'HEAD', keepalive: true }).catch(() => {});
                }

                const timeoutId = setTimeout(() => controller.abort(), this.constants.FETCH_TIMEOUT);

                const response = await fetchPromise;
                clearTimeout(timeoutId);

                if (!response.ok) throw new Error(`${this.getMessage('error')}: ${response.status} ${response.statusText}`);

                // ใช้ Stream Reader ถ้า browser รองรับ (เร็วกว่า response.json() มากใน big file)
                if (response.body && window.TextDecoder) {
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder('utf-8');
                    let jsonText = '';
                    let done, value;
                    do {
                        ({ value, done } = await reader.read());
                        if (value) jsonText += decoder.decode(value, { stream: !done });
                    } while (!done);

                    let data;
                    if (jsonText.length > 2 * 1024 * 1024) {
                        data = await this.parseLargeJSONInWorker(jsonText);
                    } else {
                        data = JSON.parse(jsonText);
                    }
                    if (options.cache !== false) this.setCache(key, data);
                    return data;
                } else {
                    const data = await response.json();
                    if (options.cache !== false) this.setCache(key, data);
                    return data;
                }
            } catch (error) {
                lastError = error;
                if (attempt < this.constants.MAX_RETRIES) {
                    await new Promise(resolve => setTimeout(resolve, this.constants.RETRY_DELAY));
                }
            }
        }
        errorManager.showError(key, lastError, {
            duration: 5000,
            type: 'error',
            dismissible: true,
            position: 'top-right'
        });
        throw lastError;
    },

    /**
     * Parse JSON ขนาดใหญ่ด้วย Web Worker (off-main-thread)
     */
    parseLargeJSONInWorker(jsonText) {
        return new Promise((resolve, reject) => {
            const workerCode = `
                self.onmessage = function(e) {
                    try {
                        const result = JSON.parse(e.data);
                        self.postMessage({ result });
                    } catch (err) {
                        self.postMessage({ error: err.message });
                    }
                }
            `;
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const worker = new Worker(URL.createObjectURL(blob));
            worker.onmessage = function(e) {
                if (e.data.error) {
                    reject(new Error(e.data.error));
                } else {
                    resolve(e.data.result);
                }
                worker.terminate();
            };
            worker.onerror = function(err) {
                reject(err);
                worker.terminate();
            };
            worker.postMessage(jsonText);
        });
    },

    async loadApiDatabase() {
        if (this.apiCache && !this.isCacheExpired(this.apiCacheTimestamp)) {
            return this.apiCache;
        }
        try {
            const data = await this.fetchWithRetry(this.constants.API_DATABASE_PATH);
            if (!data || !Array.isArray(data.items)) {
                throw new Error(this.getMessage('invalidApiData'));
            }
            this.apiCache = data.items;
            this.apiCacheTimestamp = Date.now();
            return data.items;
        } catch (error) {
            throw new Error(this.getMessage('apiDatabaseError'));
        }
    },

    /**
     * ดึงข้อมูล api content ตามคีย์ api แบบไม่สนใจโครงสร้างอื่น
     */
    async fetchApiContent(apiCode) {
        try {
            const response = await this.fetchWithRetry('/assets/json/api-database.min.json');
            function findApiValue(obj, targetApi) {
                if (Array.isArray(obj)) {
                    for (const item of obj) {
                        const found = findApiValue(item, targetApi);
                        if (found) return found;
                    }
                } else if (typeof obj === 'object' && obj !== null) {
                    if (obj.api === targetApi) {
                        return obj.text || obj;
                    }
                    for (const key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            const found = findApiValue(obj[key], targetApi);
                            if (found) return found;
                        }
                    }
                }
                return null;
            }
            const content = findApiValue(response, apiCode);
            if (!content) {
                throw new Error(this.getMessage('apiNotFound', { code: apiCode }));
            }
            return content;
        } catch (error) {
            throw new Error(`ไม่สามารถดึงข้อมูล API ได้: ${error.message}`);
        }
    },

    /**
     * ดึงข้อมูลหมวดหมู่ (category) ด้วย categoryId เช่น smileys_emotion_category
     * คืนค่าข้อมูล { id, name, data, header }
     */
    async fetchCategoryGroup(categoryId) {
        const idRaw = categoryId.replace(/_category$/, '');
        const db = await this.fetchWithRetry('/assets/json/api-database.min.json');
        let found = null;
        let typeName = "";
        let typeId = "";

        // หาใน type array (emoji, special-characters, ...)
        if (Array.isArray(db?.type)) {
            for (const typeObj of db.type) {
                typeId = typeObj.id;
                typeName = typeObj.name;
                if (Array.isArray(typeObj.category)) {
                    for (const cat of typeObj.category) {
                        if (cat.id === idRaw) {
                            found = cat;
                            break;
                        }
                    }
                }
                if (found) break;
            }
        }

        // รองรับ special-characters
        if (!found && Array.isArray(db)) {
            for (const typeObj of db) {
                typeId = typeObj.id;
                typeName = typeObj.name;
                if (Array.isArray(typeObj.category)) {
                    for (const cat of typeObj.category) {
                        if (cat.id === idRaw) {
                            found = cat;
                            break;
                        }
                    }
                }
                if (found) break;
            }
        }

        if (!found) throw new Error(`Category not found: ${categoryId}`);

        // เตรียม header อัตโนมัติ
        const currentLang = localStorage.getItem('selectedLang') || 'en';
        const header = {
            title: found.name?.[currentLang] || found.name?.en || found.id,
            description: typeName?.[currentLang] || typeName?.en || "",
            typeId,
            categoryId: found.id,
            className: "auto-category-header"
        };

        return {
            id: found.id,
            name: found.name,
            data: found.data,
            header
        };
    },

    async fetchBatched(urls, options = {}) {
        const results = [];
        const batches = [];
        for (let i = 0; i < urls.length; i += this.constants.BATCH_SIZE) {
            batches.push(urls.slice(i, i + this.constants.BATCH_SIZE));
        }
        let completed = 0;
        const total = urls.length;
        for (const batch of batches) {
            try {
                const batchResults = await Promise.all(
                    batch.map(async url => {
                        const result = await this.fetchWithRetry(url, {
                            ...options,
                            loadingMessage: this.getMessage('batchLoading', {
                                current: ++completed,
                                total
                            })
                        });
                        return result;
                    })
                );
                results.push(...batchResults);
            } catch (error) {
                utils.showNotification(
                    this.getMessage('batchError'),
                    'warning'
                );
            }
        }
        return results;
    },

    init() {
        setInterval(() => {
            this.clearExpiredCache();
        }, this.constants.CACHE_DURATION);

        window.addEventListener('online', () => {
            utils.showNotification(
                this.getMessage('online'),
                'success'
            );
        });

        window.addEventListener('offline', () => {
            utils.showNotification(
                this.getMessage('offline'),
                'warning'
            );
        });

        window.addEventListener('languageChange', () => {
            this.loadingStates.forEach((state, key) => {
                if (state.loading) {
                    LoadingManager.updateMessage(key, this.getMessage('loading'));
                }
            });
        });
    },

    reset() {
        this.clearCache();
        this.loadingStates.clear();
        if (window.LoadingManager && LoadingManager.clearAll) LoadingManager.clearAll();
    }
};

/**
 * ScrollManager - จัดการการเลื่อนหน้าและการล็อคองค์ประกอบต่างๆ
 * Last updated: 2025-04-25 16:34:52
 * Author: Jeffy2600III
 */
const ScrollManager = {
    // สถานะการทำงาน
    state: {
        lastScrollY: 0,
        ticking: false,
        subNavOffsetTop: 0,
        subNavHeight: 0,
        isSubNavFixed: false,
        lastUpdate: '2025-04-25 16:34:52',
        currentUser: 'Jeffy2600III'
    },
    
    // ค่าคงที่สำหรับการตั้งค่า
    constants: {
        SCROLL_THRESHOLD: 0,
        DEBOUNCE_DELAY: 0,
        SUB_NAV_TOP_SPACING: 0,
        ANIMATION_DURATION: 0,
        Z_INDEX: {
            SUB_NAV: 999
        }
    },
    
    init() {
        this.createStickyStyles();
        this.setupEventListeners();
        this.setupResizeObserver();
        this.setupMutationObserver();
        this.handleInitialScroll();
    },
    
createStickyStyles() {
    const styleSheet = document.createElement('style');
    styleSheet.id = 'sticky-styles';
    styleSheet.textContent = `
    /* Sub-nav base styles */
    #sub-nav {
      position: sticky;
      top: ${this.constants.SUB_NAV_TOP_SPACING}px;
      left: 0;
      right: 0;
      z-index: ${this.constants.Z_INDEX.SUB_NAV};
      transition: background ${this.constants.ANIMATION_DURATION}ms ease,
                  box-shadow ${this.constants.ANIMATION_DURATION}ms ease,
                  border-bottom ${this.constants.ANIMATION_DURATION}ms ease;
      will-change: background, box-shadow, border-bottom;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      overflow: hidden;
      border-radius: 0 0 20px 20px;
      transform: translateZ(0); /* Boost GPU compositing */
    }

    /* Fixed state */
    #sub-nav.fixed {
      box-shadow: 0 0 15px rgba(58, 60, 79, 0.15);
      background: rgba(240, 252, 255, 1);
      border-bottom: 1px solid rgba(19, 180, 127, 0.3);
    }

    /* Content transitions */
    #sub-buttons-container,
    .hi,
    .hj {
      transition: padding ${this.constants.ANIMATION_DURATION}ms ease,
                  border ${this.constants.ANIMATION_DURATION}ms ease,
                  background ${this.constants.ANIMATION_DURATION}ms ease;
      will-change: padding, border, background;
      position: relative;
      z-index: 1;
    }

    /* Fixed state content adjustments */
    #sub-nav.fixed #sub-buttons-container {
      padding: 5px !important;
    }

    #sub-nav.fixed .hi {
      padding: 0 !important;
    }

    #sub-nav.fixed .hj {
      border: 0.5px solid rgba(0, 0, 0, 0);
      background: rgba(255, 255, 255, 0);
    }
  `;
    document.head.appendChild(styleSheet);
},
    
    handleSubNav() {
        const subNav = document.getElementById('sub-nav');
        if (!subNav) return;
        
        // Update position values if needed
        if (!this.state.subNavOffsetTop) {
            this.state.subNavOffsetTop = subNav.offsetTop;
            this.state.subNavHeight = subNav.offsetHeight;
        }
        
        const currentScroll = window.pageYOffset;
        const triggerPoint = this.state.subNavOffsetTop - this.constants.SUB_NAV_TOP_SPACING;
        
        if (currentScroll >= triggerPoint && !this.state.isSubNavFixed) {
            // Start fixing
            requestAnimationFrame(() => {
                subNav.classList.add('fixed');
                // Add animation class after a short delay
                setTimeout(() => {
                    subNav.classList.add('animate');
                }, 10);
                this.state.isSubNavFixed = true;
            });
        } else if (currentScroll < triggerPoint && this.state.isSubNavFixed) {
            // Start unfixing
            requestAnimationFrame(() => {
                subNav.classList.add('unfixing');
                subNav.classList.add('animate');
                
                // Remove classes after animation completes
                setTimeout(() => {
                    subNav.classList.remove('fixed', 'unfixing', 'animate');
                    this.state.isSubNavFixed = false;
                }, this.constants.ANIMATION_DURATION);
            });
        }
    },
    
    setupEventListeners() {
        // Scroll handler with debounce
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            if (!this.state.ticking) {
                window.requestAnimationFrame(() => {
                    this.handleSubNav();
                    this.state.ticking = false;
                });
                this.state.ticking = true;
            }
            
            // Update last scroll position
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                this.state.lastScrollY = window.pageYOffset;
            }, this.constants.DEBOUNCE_DELAY);
        }, { passive: true });
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                this.handleSubNav();
            }
        });
    },
    
    setupResizeObserver() {
        const resizeObserver = new ResizeObserver(entries => {
            entries.forEach(entry => {
                if (entry.target.id === 'sub-nav') {
                    this.state.subNavHeight = entry.contentRect.height;
                    this.state.subNavOffsetTop = entry.target.offsetTop;
                    this.handleSubNav();
                }
            });
        });
        
        const subNav = document.getElementById('sub-nav');
        if (subNav) {
            resizeObserver.observe(subNav);
        }
    },
    
    setupMutationObserver() {
        const mutationObserver = new MutationObserver(() => {
            const subNav = document.getElementById('sub-nav');
            if (subNav && !this.state.subNavOffsetTop) {
                this.state.subNavOffsetTop = subNav.offsetTop;
                this.state.subNavHeight = subNav.offsetHeight;
                this.handleSubNav();
            }
        });
        
        mutationObserver.observe(document.body, {
            childList: true,
            subtree: true
        });
    },
    
    handleInitialScroll() {
        // Handle initial scroll position
        if (window.pageYOffset > 0) {
            this.handleSubNav();
        }
    },
    
    reset() {
        // Remove styles
        const styleSheet = document.getElementById('sticky-styles');
        if (styleSheet) {
            styleSheet.remove();
        }
        
        // Reset sub-nav
        const subNav = document.getElementById('sub-nav');
        if (subNav) {
            subNav.classList.remove('fixed', 'unfixing', 'animate');
            
            // Reset content elements
            const subButtonsContainer = document.getElementById('sub-buttons-container');
            const hiElements = subNav.getElementsByClassName('hi');
            const hjElements = subNav.getElementsByClassName('hj');
            
            if (subButtonsContainer) {
                subButtonsContainer.style.padding = '';
                subButtonsContainer.style.transition = '';
            }
            
            Array.from(hiElements).forEach(el => {
                el.style.padding = '';
                el.style.transition = '';
            });
            
            Array.from(hjElements).forEach(el => {
                el.style.border = '';
                el.style.transition = '';
            });
        }
        
        // Reset state
        this.state = {
            lastScrollY: 0,
            ticking: false,
            subNavOffsetTop: 0,
            subNavHeight: 0,
            isSubNavFixed: false,
            lastUpdate: '2025-04-25 16:34:52',
            currentUser: 'Jeffy2600III'
        };
    }
};

const ButtonManager = {
    // สถานะภายใน
    state: {
        buttonMap: new Map(),
        currentMainButton: null,
        currentSubButton: null,
        isInitialized: false,
        cache: new Map(),
        lastUpdate: '2025-04-17 00:08:27',
        currentUser: 'Jeffy2600-4'
    },

    // โหลดการตั้งค่าปุ่ม
    async loadConfig() {
        try {
            if (state.buttonConfig) {
                await this.renderMainButtons();
                return;
            }

            const cached = DataManager.getCached('buttonConfig');
            if (cached) {
                state.buttonConfig = cached;
                await this.renderMainButtons();
                return;
            }

            const response = await DataManager.fetchWithRetry('/assets/json/buttons.min.json');
            state.buttonConfig = response;
            DataManager.setCache('buttonConfig', response);

            await this.renderMainButtons();
            await NavigationManager.updateButtonStates();

        } catch (error) {
            console.error('Error loading button config:', error);
            utils.showNotification('ไม่สามารถโหลดการตั้งค่าปุ่มได้', 'error');
            throw new AppError('ไม่สามารถโหลดการตั้งค่าปุ่มได้', 'config', error);
        }
    },

    // เรนเดอร์ปุ่มหลัก
    async renderMainButtons() {
        const lang = localStorage.getItem('selectedLang') || 'en';
        const { mainButtons } = state.buttonConfig;
        const { navList } = elements;

        // เคลียร์ปุ่มเดิม
        navList.innerHTML = '';
        this.state.buttonMap = new Map();

        // สร้างและเรนเดอร์ปุ่มใหม่
        let defaultButton = null;

        for (const button of mainButtons) {
            const label = button[`${lang}_label`];
            if (!label) continue;

            const li = document.createElement('li');
            const mainButton = document.createElement('button');
            
            // ตั้งค่าปุ่ม
            mainButton.textContent = label;
            mainButton.className = 'main-button';
            const buttonUrl = button.url || button.jsonFile;
            mainButton.setAttribute('data-url', buttonUrl);
            
            if (button.className) {
                mainButton.classList.add(button.className);
            }

            // เก็บข้อมูลปุ่ม
            this.state.buttonMap.set(buttonUrl, {
                button: mainButton,
                config: button,
                element: mainButton
            });

            if (button.isDefault) {
                defaultButton = {
                    button: mainButton,
                    config: button
                };
            }

            // เพิ่ม event listener
            mainButton.addEventListener('click', async (event) => {
                try {
                    event.preventDefault();
                    
                    NavigationManager.state.previousMainRoute = NavigationManager.state.currentMainRoute;

                    await ContentManager.clearContent();

                    const skipUrlUpdate = !!button.subButtons;
                    if (!button.subButtons && button.url) {
                        await NavigationManager.navigateTo(button.url, { skipUrlUpdate });
                    }

                    if (button.jsonFile) {
                        try {
                            const data = await DataManager.fetchWithRetry(button.jsonFile);
                            await ContentManager.renderContent(data);
                        } catch (error) {
                            console.error('Error loading content:', error);
                            utils.showNotification('ไม่สามารถโหลดเนื้อหาได้', 'error');
                            return;
                        }
                    }

                    NavigationManager.state.currentMainRoute = buttonUrl;
                    this.state.currentMainButton = mainButton;

                    if (button.subButtons) {
                        await this.renderSubButtons(button.subButtons, buttonUrl, lang);
                    }

                } catch (error) {
                    console.error('Error handling button click:', error);
                    utils.showNotification(error.message, 'error');
                }
            });

            li.appendChild(mainButton);
            navList.appendChild(li);
        }

        // --- ปรับปรุง: handleInitialUrl ใช้ window.location.search แทน hash ---
        let initialUrl = window.location.search;
        await this.handleInitialUrl(initialUrl, this.state.buttonMap, defaultButton);
    },

    // --- ปรับปรุง: handleInitialUrl รองรับ URL query string ---
    async handleInitialUrl(url, buttonMap, defaultButton) {
        try {
            if (!url) url = window.location.search;
            if (!url || url === '?') {
                if (defaultButton) {
                    await this.triggerButtonClick(defaultButton.button);
                }
                return;
            }

            // แยก main/sub จาก URL รูปแบบใหม่
            let mainRoute = '', subRoute = '';
            if (url.startsWith('?')) {
                const params = new URLSearchParams(url);
                mainRoute = (params.get('type') || '').replace(/__$/, '');
                subRoute = params.get('page') || '';
            } else if (url.includes('-')) {
                [mainRoute, subRoute] = url.split('-');
            } else {
                mainRoute = url;
            }

            const mainButtonData = buttonMap.get(mainRoute);

            if (!mainButtonData) {
                if (defaultButton) {
                    await this.triggerButtonClick(defaultButton.button);
                }
                return;
            }

            const { button: mainButton, config: mainConfig } = mainButtonData;

            try {
                const isValidUrl = await NavigationManager.validateUrl(url);
                if (!isValidUrl) throw new Error('URL ไม่ถูกต้อง');

                NavigationManager.state.currentMainRoute = mainRoute;
                NavigationManager.state.currentSubRoute = subRoute || '';
                this.state.currentMainButton = mainButton;

                await this.activateMainButton(mainButton, mainConfig);

                if (subRoute && mainConfig.subButtons) {
                    await this.handleInitialSubRoute(mainConfig, mainRoute, subRoute);
                } else if (!subRoute && mainConfig.subButtons) {
                    await this.handleDefaultSubButton(mainConfig, mainRoute);
                }
                await NavigationManager.scrollActiveButtonsIntoView();

            } catch (error) {
                if (defaultButton) {
                    await this.triggerButtonClick(defaultButton.button);
                }
            }
        } catch (error) {
            if (defaultButton) {
                await this.triggerButtonClick(defaultButton.button);
            }
        }
    },

    async activateMainButton(mainButton, mainConfig) {
        try {
            elements.navList.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });

            mainButton.classList.add('active');
            this.state.currentMainButton = mainButton;

            if (mainConfig.jsonFile) {
                await ContentManager.clearContent();
                const mainData = await DataManager.fetchWithRetry(mainConfig.jsonFile);
                await ContentManager.renderContent(mainData);
            }

        } catch (error) {
            console.error('Error activating main button:', error);
            throw error;
        }
    },

    async handleInitialSubRoute(mainConfig, mainRoute, subRoute) {
        try {
            await new Promise(resolve => setTimeout(resolve, 100));
            const lang = localStorage.getItem('selectedLang') || 'en';
            await this.renderSubButtons(mainConfig.subButtons, mainRoute, lang);

            const subButton = document.querySelector(`button[data-url="${mainRoute}-${subRoute}"]`);
            const subButtonConfig = mainConfig.subButtons.find(
                btn => btn.url === subRoute || btn.jsonFile === subRoute
            );

            if (subButton && subButtonConfig) {
                elements.subButtonsContainer.querySelectorAll('.button-sub').forEach(btn => {
                    btn.classList.remove('active');
                });
                subButton.classList.add('active');
                this.state.currentSubButton = subButton;

                if (subButtonConfig.jsonFile) {
                    await ContentManager.clearContent();
                    const subData = await DataManager.fetchWithRetry(subButtonConfig.jsonFile);
                    await ContentManager.renderContent(subData);
                }

                this.scrollActiveSubButtonIntoView(subButton);
            }

        } catch (error) {
            console.error('Error handling initial sub-route:', error);
            throw error;
        }
    },

    async handleDefaultSubButton(mainConfig, mainRoute) {
        try {
            const defaultSubButton = mainConfig.subButtons.find(btn => btn.isDefault);
            if (defaultSubButton) {
                const fullUrl = `${mainRoute}-${defaultSubButton.url || defaultSubButton.jsonFile}`;
                await NavigationManager.navigateTo(fullUrl, { skipUrlUpdate: false });
            }
        } catch (error) {
            console.error('Error handling default sub-button:', error);
            throw error;
        }
    },

    async triggerButtonClick(button, options = {}) {
        if (!button) {
            throw new Error('ไม่พบปุ่มที่จะคลิก');
        }

        try {
            const buttonUrl = button.getAttribute('data-url');
            const isSubButton = button.classList.contains('sub-button');
            const buttonConfig = isSubButton ? 
                this.findSubButtonConfig(buttonUrl) :
                this.findMainButtonConfig(buttonUrl);

            await this.handleButtonClick(button, buttonConfig, isSubButton);
            
            if (isSubButton) {
                this.state.currentSubButton = button;
            } else {
                this.state.currentMainButton = button;
            }
            
            this.updateButtonState(button, isSubButton);

        } catch (error) {
            console.error('Error triggering button click:', error);
            throw new Error(`เกิดข้อผิดพลาดในการคลิกปุ่ม: ${error.message}`);
        }
    },

    async handleButtonClick(button, buttonConfig, isSubButton) {
        try {
            await ContentManager.clearContent();

            if (buttonConfig?.jsonFile) {
                const data = await DataManager.fetchWithRetry(buttonConfig.jsonFile);
                await ContentManager.renderContent(data);
            }

            const clickEvent = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window
            });
            button.dispatchEvent(clickEvent);

        } catch (error) {
            console.error('Error handling button click:', error);
            utils.showNotification('ไม่สามารถโหลดเนื้อหาได้', 'error');
            throw error;
        }
    },

    findMainButtonConfig(url) {
        return state.buttonConfig?.mainButtons?.find(
            btn => btn.url === url || btn.jsonFile === url
        );
    },

    findSubButtonConfig(fullUrl) {
        const [mainRoute, subRoute] = fullUrl.split('-');
        const mainButton = this.findMainButtonConfig(mainRoute);
        
        return mainButton?.subButtons?.find(
            btn => btn.url === subRoute || btn.jsonFile === subRoute
        );
    },

    updateButtonState(button, isSubButton) {
        try {
            const buttonGroup = isSubButton ? 
                elements.subButtonsContainer :
                elements.navList;
            
            if (!buttonGroup) {
                console.warn('ไม่พบ button group element');
                return;
            }

            buttonGroup.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });

            if (button && button instanceof HTMLElement) {
                button.classList.add('active');
                
                if (isSubButton) {
                    this.state.currentSubButton = button;
                    this.scrollActiveSubButtonIntoView(button);
                } else {
                    this.state.currentMainButton = button;
                }
            }

        } catch (error) {
            console.error('Error updating button state:', error);
        }
    },

    async renderSubButtons(subButtons, mainButtonUrl, lang) {
        const { subButtonsContainer } = elements;

        subButtonsContainer.innerHTML = '';
        subButtonsContainer.classList.add('fade-out');

        await new Promise(resolve => setTimeout(resolve, 100));

        let defaultSubButton = null;
        const currentUrl = window.location.search;
        let activeSubUrl = '';
        if (currentUrl.startsWith('?')) {
            const params = new URLSearchParams(currentUrl);
            const main = (params.get('type') || '').replace(/__$/, '');
            const sub = params.get('page') || '';
            if (main && sub) activeSubUrl = `${main}-${sub}`;
        }

        subButtons.forEach(button => {
            const label = button[`${lang}_label`];
            if (!label) return;

            const subButton = document.createElement('button');
            subButton.className = 'button-sub sub-button';
            if (button.className) {
                subButton.classList.add(button.className);
            }
            subButton.textContent = label;

            const fullUrl = button.url ?
                `${mainButtonUrl}-${button.url}` :
                `${mainButtonUrl}-${button.jsonFile}`;

            subButton.setAttribute('data-url', fullUrl);

            if (button.isDefault) {
                defaultSubButton = subButton;
            }

            subButton.addEventListener('click', async () => {
                try {
                    this.updateButtonState(subButton, true);

                    await Promise.all([
                        NavigationManager.navigateTo(fullUrl),
                        button.jsonFile ? (async () => {
                            const data = await DataManager.fetchWithRetry(button.jsonFile);
                            await ContentManager.renderContent(data);
                        })() : Promise.resolve()
                    ]);

                } catch (error) {
                    console.error('Error handling sub-button click:', error);
                    utils.showNotification(error.message, 'error');
                }
            });

            subButtonsContainer.appendChild(subButton);

            if (fullUrl === activeSubUrl) {
                this.updateButtonState(subButton, true);
            }
        });

        const needsDefault = !activeSubUrl ||
            !subButtonsContainer.querySelector('.button-sub.active');

        if (needsDefault && defaultSubButton) {
            await this.triggerButtonClick(defaultSubButton);
        }

        subButtonsContainer.classList.remove('fade-out');
        subButtonsContainer.classList.add('fade-in');
    },

    scrollActiveSubButtonIntoView(activeButton) {
        if (!activeButton || !elements.subButtonsContainer) return;

        requestAnimationFrame(() => {
            const container = elements.subButtonsContainer;
            const containerLeft = container.getBoundingClientRect().left;
            const buttonLeft = activeButton.getBoundingClientRect().left;
            const scrollLeft = container.scrollLeft;

            const targetScroll = scrollLeft + (buttonLeft - containerLeft) - 20;

            if (Math.abs(container.scrollLeft - targetScroll) > 1) {
                container.scrollTo({
                    left: targetScroll,
                    behavior: 'smooth'
                });
            }
        });
    },

    updateButtonsLanguage(newLang) {
        try {
            const { mainButtons } = state.buttonConfig;
            const { navList, subButtonsContainer } = elements;

            navList.querySelectorAll('button').forEach((button, index) => {
                const config = mainButtons[index];
                if (config && config[`${newLang}_label`]) {
                    button.textContent = config[`${newLang}_label`];
                }
            });

            if (this.state.currentMainButton) {
                const mainConfig = this.findMainButtonConfig(
                    this.state.currentMainButton.getAttribute('data-url')
                );

                if (mainConfig?.subButtons) {
                    this.renderSubButtons(
                        mainConfig.subButtons,
                        mainConfig.url || mainConfig.jsonFile,
                        newLang
                    );
                }
            }

        } catch (error) {
            console.error('Error updating buttons language:', error);
            utils.showNotification('ไม่สามารถอัพเดทภาษาของปุ่มได้', 'error');
        }
    },

    reset() {
        this.state = {
            buttonMap: new Map(),
            currentMainButton: null,
            currentSubButton: null,
            isInitialized: false,
            cache: new Map(),
            lastUpdate: '2025-04-17 00:08:27',
            currentUser: 'Jeffy2600-4'
        };
        
        elements.navList?.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active');
        });
        elements.subButtonsContainer?.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active');
        });
    }
};

    // Performance Optimizations
    const PerformanceOptimizer = {
     init() {
      this.setupLazyLoading();
      this.setupPrefetching();
      this.setupErrorBoundary();
     },
     
     setupLazyLoading() {
      if ('loading' in HTMLImageElement.prototype) {
       document.querySelectorAll('img').forEach(img => {
        img.loading = 'lazy';
       });
      } else {
       this.setupIntersectionObserver();
      }
     },
     
     setupIntersectionObserver() {
      const imageObserver = new IntersectionObserver((entries, observer) => {
       entries.forEach(entry => {
        if (entry.isIntersecting) {
         const img = entry.target;
         if (img.dataset.src) {
          img.src = img.dataset.src;
          img.removeAttribute('data-src');
         }
         observer.unobserve(img);
        }
       });
      });
      
      document.querySelectorAll('img[data-src]').forEach(img => {
       imageObserver.observe(img);
      });
     },
     
     setupPrefetching() {
      const prefetchLinks = new Set();
      
      document.querySelectorAll('a[href], button[data-url]').forEach(element => {
       const url = element.href || element.dataset.url;
       if (url && !prefetchLinks.has(url)) {
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = url;
        link.as = url.endsWith('.json') ? 'fetch' : 'document';
        document.head.appendChild(link);
        prefetchLinks.add(url);
       }
      });
     },
     
     setupErrorBoundary() {
      window.addEventListener('error', event => {
       console.error('Global error:', event.error);
       utils.showNotification(
        'เกิดข้อผิดพลาดที่ไม่คาดคิด กรุณาลองใหม่อีกครั้ง',
        'error'
       );
      });
      
      window.addEventListener('unhandledrejection', event => {
       console.error('Unhandled promise rejection:', event.reason);
       utils.showNotification(
        'เกิดข้อผิดพลาดในการเชื่อมต่อ กรุณาตรวจสอบการเชื่อมต่ออินเทอร์เน็ต',
        'error'
       );
      });
     }
    };
    
const initializeApp = async () => {
    // สถานะการทำงานของแอพ
    const appState = {
        isInitialized: false,
        lastError: null,
        startTime: Date.now(),
        currentUser: 'Jeffy2600III'
    };
    
    try {
        // 1. ตรวจสอบ elements ที่จำเป็นก่อนเริ่มต้น
        if (!NavigationManager.validateElements()) {
            throw new Error('ไม่พบ elements ที่จำเป็นบางส่วน กรุณาตรวจสอบโครงสร้าง HTML');
        }
        
        // 2. เริ่มต้นระบบจัดการข้อผิดพลาด
        const setupErrorHandling = () => {
            window.addEventListener('error', (event) => {
                console.error('เกิดข้อผิดพลาดทั่วไป:', event.error);
                appState.lastError = event.error;
                utils.showNotification('เกิดข้อผิดพลาดบางอย่าง กรุณารีเฟรชหน้าเว็บ', 'error', { duration: 5000 });
            });
            
            window.addEventListener('unhandledrejection', (event) => {
                console.error('พบ Promise ที่ไม่ได้จัดการข้อผิดพลาด:', event.reason);
                appState.lastError = event.reason;
                utils.showNotification('เกิดข้อผิดพลาดในการเชื่อมต่อ กรุณาลองใหม่อีกครั้ง', 'error', { duration: 5000 });
            });
        };
        
        // 3. เริ่มต้นระบบจัดการการเลื่อน
        ScrollManager.init();
        
        // 4. เพิ่มประสิทธิภาพ
        PerformanceOptimizer.init();
        
        // 5. ตั้งค่า Event Listeners สำหรับปุ่มนำทาง
        const setupNavigationButtons = () => {
            elements.navButtons.forEach(button => {
                button.addEventListener('click', async (event) => {
                    event.preventDefault();
                    const route = button.getAttribute('data-url');
                    if (route) {
                        try {
                            await NavigationManager.navigateTo(route);
                        } catch (error) {
                            utils.showNotification('เกิดข้อผิดพลาดในการนำทาง กรุณาลองใหม่', 'error');
                            console.error('ข้อผิดพลาดการนำทาง:', error);
                        }
                    }
                });
            });
        };
        
        // 6. ตั้งค่าการติดตามสถานะเครือข่าย
        const setupNetworkMonitoring = () => {
            window.addEventListener('online', () => {
                utils.showNotification('การเชื่อมต่อกลับมาแล้ว', 'success');
                if (appState.lastError) {
                    ButtonManager.loadConfig();
                }
            });
            
            window.addEventListener('offline', () => {
                utils.showNotification('ขาดการเชื่อมต่ออินเทอร์เน็ต', 'warning');
            });
        };
        
        // 7. ตั้งค่าการจัดการ URL (ปรับปรุงใหม่: ใช้ URL query string ไม่ใช่ hash)
        const setupUrlHandling = () => {
            // popstate: กรณีผู้ใช้กดปุ่ม back/forward
            window.addEventListener('popstate', async () => {
                try {
                    let url = window.location.search;
                    if (!url || url === '?') {
                        const defaultRoute = await NavigationManager.getDefaultRoute();
                        await NavigationManager.navigateTo(defaultRoute, { skipUrlUpdate: true });
                        return;
                    }
                    await NavigationManager.navigateTo(url, { skipUrlUpdate: true });
                } catch (error) {
                    utils.showNotification('เกิดข้อผิดพลาดในการนำทางย้อนกลับ กรุณาลองใหม่', 'error');
                }
            });
            
            // โหลดหน้าตาม URL เมื่อรีเฟรชหรือเปิดหน้าใหม่
            document.addEventListener('DOMContentLoaded', async () => {
                try {
                    let url = window.location.search;
                    if (!url || url === '?') {
                        const defaultRoute = await NavigationManager.getDefaultRoute();
                        await NavigationManager.navigateTo(defaultRoute, { skipUrlUpdate: false });
                    } else {
                        await NavigationManager.navigateTo(url, { skipUrlUpdate: true });
                    }
                } catch (error) {
                    utils.showNotification('เกิดข้อผิดพลาดในการโหลดเนื้อหาตาม URL กรุณาลองใหม่', 'error');
                }
            });
        };
        
        // 8. ตั้งค่าการจัดการการเปลี่ยนภาษา
        const setupLanguageHandling = () => {
            window.addEventListener('languageChange', (event) => {
                const newLang = event.detail.language;
                ButtonManager.updateButtonsLanguage(newLang);
                ContentManager.updateCardsLanguage(newLang);
            });
        };
        
        // 9. ตั้งค่าการจัดการการ resize หน้าจอ
        const setupResizeHandling = () => {
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    NavigationManager.scrollActiveButtonsIntoView();
                }, 150);
            });
        };
        
        // 10. เริ่มต้นระบบทั้งหมด
        setupErrorHandling();
        setupNavigationButtons();
        setupNetworkMonitoring();
        setupUrlHandling();
        setupLanguageHandling();
        setupResizeHandling();
        
        // 11. โหลดการตั้งค่าปุ่มเริ่มต้น
        await ButtonManager.loadConfig();
        
        // 12. ทำเครื่องหมายว่าแอพเริ่มต้นเรียบร้อยแล้ว
        appState.isInitialized = true;
        console.log('แอพพลิเคชันเริ่มต้นเรียบร้อยแล้ว:', {
            startupTime: Date.now() - appState.startTime + 'ms',
            currentUser: appState.currentUser
        });
        
    } catch (error) {
        // จัดการข้อผิดพลาดที่เกิดขึ้นระหว่างการเริ่มต้นแอพ
        console.error('เกิดข้อผิดพลาดในการเริ่มต้นแอพพลิเคชัน:', error);
        appState.lastError = error;
        utils.showNotification('เกิดข้อผิดพลาดในการโหลดแอพพลิเคชัน กรุณารีเฟรชหน้าเว็บ', 'error', { duration: 5000 });
        
        try {
            setupErrorHandling();
            setupNetworkMonitoring();
        } catch (recoveryError) {
            console.error('ไม่สามารถกู้คืนระบบพื้นฐานได้:', recoveryError);
        }
    } finally {
        // [NEW CODE] Remove the instant loading overlay ONLY ONCE after the first main content is ready
        if (window.__removeInstantLoadingOverlay && window.__instantLoadingOverlayShown) {
            window.__removeInstantLoadingOverlay();
            window.__instantLoadingOverlayShown = false;
        }
    }
};

// เริ่มต้นแอพพลิเคชันเมื่อ DOM พร้อม
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}
    });