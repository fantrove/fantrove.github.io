// Customized header.min.js — optimized to reduce main-thread and GPU usage
// Key improvements:
//  - Offloads heavy JSON parse/index to a Web Worker (/assets/js/header-index-worker.js)
//  - Chunked, "render-until-end-of-current-chunk" rendering (sentinel-driven) to minimize DOM ops and GPU usage
//  - Reduced fetch races and increased sensible fetch timeout
//  - Reused DOM elements and styles to reduce DOM operations
//  - Lazy-created learning worker and index worker only when necessary
//  - Reduced element pool size (memory footprint) and limited prefetching
//  - Safer observers, debounced/throttled notifications and events

// ---------- Part 1: Instant Loading Overlay ----------
(function showInstantLoadingOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'instant-loading-overlay';
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100vw';
    overlay.style.height = '100vh';
    overlay.style.background = 'rgba(255,255,255,0.94)';
    overlay.style.zIndex = '2147483647';
    overlay.style.display = 'flex';
    overlay.style.flexDirection = 'column';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';
    overlay.style.transition = 'opacity 0.36s cubic-bezier(.7,0,.7,1)';
    overlay.style.opacity = '1';
    
    const styleId = 'instant-loading-styles';
    let style = document.getElementById(styleId);
    if (!style) {
        style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            #instant-loading-overlay .content-loading-spinner {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                animation: content-loading-fade-in 0.3s ease-in;
            }
            #instant-loading-overlay .spinner-svg {
                margin-bottom: 16px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            #instant-loading-overlay .loading-message {
                font-size: 1.22rem;
                color: #2196f3;
                text-align: center;
                margin-top: 10px;
                font-weight: 500;
                letter-spacing: 0.04em;
                opacity: 0.92;
            }
            @keyframes content-loading-fade-in {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes instant-spinner-rotate {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            #instant-loading-overlay .spinner-svg-fg {
                stroke: #4285f4;
                stroke-width: 6;
                stroke-linecap: round;
                stroke-dasharray: 90 125;
                animation: instant-spinner-rotate 1s linear infinite;
            }
            #instant-loading-overlay .spinner-svg-bg {
                stroke: #eee;
                stroke-width: 6;
            }
        `;
        document.head.appendChild(style);
    }
    
    overlay.innerHTML = `
        <div class="content-loading-spinner">
            <div class="spinner-svg" aria-label="loading">
                <svg width="48" height="48" viewBox="0 0 48 48" focusable="false">
                    <circle
                        class="spinner-svg-bg"
                        cx="24" cy="24" r="20"
                        fill="none"
                    />
                    <circle
                        class="spinner-svg-fg"
                        cx="24" cy="24" r="20"
                        fill="none"
                    />
                </svg>
            </div>
            <div class="loading-message">
                ${(localStorage.getItem('selectedLang') || 'en') === 'th'
                    ? 'กำลังโหลดเนื้อหา...'
                    : 'Loading content...'}
            </div>
        </div>
    `;
    document.body.appendChild(overlay);
    
    let overlayRemoved = false;
    window.__removeInstantLoadingOverlay = function() {
        if (overlayRemoved) return;
        overlayRemoved = true;
        if (overlay) {
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';
            setTimeout(() => {
                if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
                if (style && style.parentNode) style.parentNode.removeChild(style);
            }, 400);
        }
    };
    window.__instantLoadingOverlayShown = true;
})();

// ---------- Part 2: Element & DOM Initialization ----------
function ensureElement(selector, tag = 'div', id = '') {
    let el = document.querySelector(selector);
    if (!el) {
        el = document.createElement(tag);
        if (id) el.id = id;
        document.body.appendChild(el);
    }
    return el;
}

const header = ensureElement('header', 'header');
const navList = ensureElement('#nav-list', 'ul', 'nav-list');
const subButtonsContainer = ensureElement('#sub-buttons-container', 'div', 'sub-buttons-container');
const contentLoading = ensureElement('#content-loading', 'div', 'content-loading');
const logo = ensureElement('.logo', 'div', 'logo');

window._headerV2_elements = {
    header,
    navList,
    subButtonsContainer,
    contentLoading,
    logo
};

// ---------- Part 3: Utils & Notification/Error System ----------
function showNotification(message, type = 'info', options = {}) {
    const lang = localStorage.getItem('selectedLang') || 'en';
    const messages = {
        th: {
            success: '✨ สำเร็จ!',
            error: '❌ ข้อผิดพลาด',
            warning: '⚠️ คำเตือน',
            info: 'ℹ️ ข้อมูล',
            loading: '⌛ กำลังโหลด'
        },
        en: {
            success: '✨ Success!',
            error: '❌ Error',
            warning: '⚠️ Warning',
            info: 'ℹ️ Information',
            loading: '⌛ Loading'
        }
    };
    try {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.setAttribute('data-timestamp', Date.now());
        
        const icon = document.createElement('div');
        icon.className = 'notification-icon';
        icon.innerHTML = type === 'success' ? '✓' :
            type === 'error' ? '✕' :
            type === 'warning' ? '⚠' :
            type === 'loading' ? '⌛' : 'ℹ';
        
        const messageContainer = document.createElement('div');
        messageContainer.className = 'notification-message-container';
        messageContainer.innerHTML = `
            <div class="notification-title">${messages[lang][type]}</div>
            <div class="notification-content">${message}</div>
        `;
        
        if (options.dismissible !== false) {
            const closeButton = document.createElement('button');
            closeButton.className = 'notification-close';
            closeButton.innerHTML = '×';
            closeButton.onclick = () => {
                notification.style.animation = 'slideOut 0.3s ease forwards';
                setTimeout(() => notification.remove(), 300);
            };
            notification.appendChild(closeButton);
        }
        
        notification.appendChild(icon);
        notification.appendChild(messageContainer);
        
        if (!document.querySelector('#notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
                .notification {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 16px;
                    border-radius: 12px;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-20px);
                    animation: slideIn 0.3s ease forwards;
                    max-width: 400px;
                    color: white;
                }
                .notification-success { background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); }
                .notification-error { background: linear-gradient(135deg, #f44336 0%, #e53935 100%); }
                .notification-warning { background: linear-gradient(135deg, #ff9800 0%, #fb8c00 100%); }
                .notification-info { background: linear-gradient(135deg, #2196f3 0%, #1e88e5 100%); }
                .notification-loading { background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%); }
                .notification-icon { background: rgba(255,255,255,0.12); width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; }
                .notification-message-container { flex: 1; display: inline-block; margin-left: 8px; vertical-align: middle; }
                .notification-title { font-size: 15px; font-weight: 600; margin-bottom: 4px; }
                .notification-content { font-size: 14px; opacity: 0.94; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
                .notification-close { background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; opacity: 0.9; }
                .notification-close:hover { opacity: 1; }
                @keyframes slideIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
                @keyframes slideOut { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-20px); } }
                .notification-loading .notification-icon { animation: spin 1s linear infinite; }
                @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
            `;
            document.head.appendChild(style);
        }
        
        document.body.appendChild(notification);
        
        if (type !== 'loading' && options.duration !== Infinity) {
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease forwards';
                setTimeout(() => { notification.remove(); }, 300);
            }, options.duration || 3000);
        }
        return notification;
    } catch (error) {
        console.error('Error showing notification:', error);
    }
}

class ErrorManager {
    constructor() {
        this.errorStates = new Map();
        this.timeouts = new Map();
    }
    isValidError(error) {
        return error && (
            error instanceof Error ||
            error.message ||
            typeof error === 'string'
        );
    }
    isDuplicateError(errorKey, message) {
        const existingError = this.errorStates.get(errorKey);
        return existingError && existingError.message === message;
    }
    showError(errorKey, error, options = {}) {
        if (!this.isValidError(error)) return;
        const message = error.message || error.toString();
        if (this.isDuplicateError(errorKey, message)) return;
        if (this.timeouts.has(errorKey)) clearTimeout(this.timeouts.get(errorKey));
        this.errorStates.set(errorKey, { message, timestamp: Date.now(), type: options.type || 'error' });
        showNotification(message, options.type || 'error', {
            duration: options.duration || 3000,
            position: options.position || 'top',
            dismissible: options.dismissible !== false
        });
        const timeout = setTimeout(() => {
            this.errorStates.delete(errorKey);
            this.timeouts.delete(errorKey);
        }, options.duration || 3000);
        this.timeouts.set(errorKey, timeout);
    }
    clearErrors() {
        this.errorStates.clear();
        this.timeouts.forEach(clearTimeout);
        this.timeouts.clear();
    }
}
window._headerV2_errorManager = new ErrorManager();

window._headerV2_utils = {
    debounce(func, wait = 250) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    },
    throttle(func, limit = 100) {
        let inThrottle;
        return (...args) => {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    },
    isOnline() {
        return navigator.onLine;
    },
    showNotification,
    errorManager: window._headerV2_errorManager
};

// ---------- Part 4: DataManager (with Worker-backed index) ----------
window._headerV2_dataManager = {
    constants: {
        FETCH_TIMEOUT: 5000,
        RETRY_DELAY: 300,
        MAX_RETRIES: 1,
        CACHE_DURATION: 2 * 60 * 60 * 1000,
        API_DATABASE_PATH: '/assets/json/api-database.min.json',
        BUTTONS_CONFIG_PATH: '/assets/json/buttons.min.json'
    },
    cache: new Map(),
    apiCache: null,
    apiCacheTimestamp: 0,
    _dbPromise: null,
    _jsonDbIndex: null,
    _jsonDbIndexReady: false,
    _jsonDbIndexPromise: null,

    _indexWorker: null,
    _indexWorkerSupported: typeof Worker !== 'undefined' && typeof URL !== 'undefined',
    _initIndexWorker() {
        if (this._indexWorker) return;
        if (!this._indexWorkerSupported) return;
        try {
            this._indexWorker = new Worker('/assets/js/header-index-worker.js');
        } catch (err) {
            this._indexWorker = null;
        }
    },

    _openIndexedDB() {
        if (this._dbPromise) return this._dbPromise;
        this._dbPromise = new Promise((resolve, reject) => {
            try {
                const req = indexedDB.open('HeaderV2DB', 5);
                req.onupgradeneeded = e => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('json')) db.createObjectStore('json');
                };
                req.onsuccess = e => resolve(e.target.result);
                req.onerror = e => reject(e.target.error);
            } catch (err) {
                reject(err);
            }
        });
        return this._dbPromise;
    },

    async _getFromIndexedDB(key) {
        try {
            const db = await this._openIndexedDB();
            return await new Promise((resolve) => {
                const tx = db.transaction('json', 'readonly');
                const store = tx.objectStore('json');
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => resolve(null);
            });
        } catch { return null; }
    },

    async _setToIndexedDB(key, data) {
        try {
            const db = await this._openIndexedDB();
            await new Promise((resolve) => {
                const tx = db.transaction('json', 'readwrite');
                const store = tx.objectStore('json');
                const req = store.put(data, key);
                req.onsuccess = () => resolve();
                req.onerror = () => resolve();
            });
        } catch {}
    },

    getCached(key) {
        const cached = this.cache.get(key);
        if (!cached) return null;
        if (Date.now() > cached.expiry) {
            this.cache.delete(key);
            return null;
        }
        return cached.data;
    },
    setCache(key, data, expiry = this.constants.CACHE_DURATION) {
        this.cache.set(key, { data, expiry: Date.now() + expiry });
    },
    clearCache() {
        this.cache.clear();
        this.apiCache = null;
        this.apiCacheTimestamp = 0;
        this._jsonDbIndex = null;
        this._jsonDbIndexReady = false;
        this._jsonDbIndexPromise = null;
    },

    _warmupPromise: null,
    async _warmup() {
        if (this._warmupPromise) return this._warmupPromise;
        this._warmupPromise = new Promise(resolve => {
            const doWarmup = async () => {
                try {
                    if (!window._headerV2_utils.isOnline()) return resolve();
                    await this.fetchWithRetry(this.constants.BUTTONS_CONFIG_PATH).catch(()=>{});
                } finally {
                    resolve();
                }
            };
            if ('requestIdleCallback' in window) requestIdleCallback(doWarmup, { timeout: 2000 });
            else setTimeout(doWarmup, 1200);
        });
        return this._warmupPromise;
    },

    async fetchWithRetry(url, options = {}) {
        const key = `${url}-${JSON.stringify(options)}`;
        const cached = this.getCached(key);
        if (cached) return cached;

        try {
            const dbData = await this._getFromIndexedDB(key);
            if (dbData) {
                this.setCache(key, dbData);
                return dbData;
            }
        } catch (err) {}

        try {
            if (!window._headerV2_utils.isOnline()) throw new Error('Offline');
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.constants.FETCH_TIMEOUT);
            const response = await fetch(url, {
                ...options,
                headers: { 'Content-Type': 'application/json', ...options.headers },
                signal: controller.signal,
                cache: options.cache === 'reload' ? 'reload' : 'force-cache'
            });
            clearTimeout(timeoutId);
            if (!response.ok) throw new Error(`Fetch error: ${response.status} ${response.statusText}`);

            if (url === this.constants.API_DATABASE_PATH) {
                const text = await response.text();
                let data;
                try {
                    if (this._indexWorkerSupported) {
                        try {
                            data = JSON.parse(text);
                        } catch {
                            data = null;
                        }
                    } else {
                        data = JSON.parse(text);
                    }
                } catch (err) {
                    data = null;
                }
                if (data) {
                    if (options.cache !== false) {
                        this.setCache(key, data);
                        this._setToIndexedDB(key, data);
                    }
                    this._buildJsonDbIndex(data, text).catch(()=>{});
                    return data;
                } else {
                    if (options.cache !== false) {
                        const parsed = JSON.parse(text);
                        this.setCache(key, parsed);
                        this._setToIndexedDB(key, parsed);
                        this._buildJsonDbIndex(parsed, text).catch(()=>{});
                        return parsed;
                    }
                }
            } else {
                const data = await response.json();
                if (options.cache !== false) {
                    this.setCache(key, data);
                    this._setToIndexedDB(key, data);
                }
                return data;
            }
        } catch (err) {
            window._headerV2_utils.errorManager.showError(key, err, {
                duration: 1200,
                type: 'error',
                dismissible: true,
                position: 'top-right'
            });
            throw err;
        }
    },

    async _buildJsonDbIndex(db, rawText) {
        if (this._jsonDbIndexReady && this._jsonDbIndex) return this._jsonDbIndex;
        if (this._jsonDbIndexPromise) return this._jsonDbIndexPromise;

        this._jsonDbIndexPromise = new Promise((resolve) => {
            const tryWorker = () => {
                try {
                    this._initIndexWorker();
                    if (this._indexWorker && rawText) {
                        const onmsg = (e) => {
                            const { type, payload } = e.data || {};
                            if (type === 'indexReady') {
                                try {
                                    const apiMap = new Map(payload.apiEntries || []);
                                    const idMap = new Map(payload.idEntries || []);
                                    const textMap = new Map(payload.textEntries || []);
                                    const catToTypeMap = new Map(payload.catToTypeEntries || []);
                                    this._jsonDbIndex = { apiMap, idMap, textMap, catToTypeMap };
                                    this._jsonDbIndexReady = true;
                                    this._indexWorker.removeEventListener('message', onmsg);
                                    resolve(this._jsonDbIndex);
                                } catch (err) {
                                    this._indexWorker.removeEventListener('message', onmsg);
                                    fallbackIndex();
                                }
                            } else if (type === 'indexError') {
                                this._indexWorker.removeEventListener('message', onmsg);
                                fallbackIndex();
                            }
                        };
                        this._indexWorker.addEventListener('message', onmsg);
                        try {
                            this._indexWorker.postMessage({ type: 'parseAndIndex', payload: { text: rawText } });
                            setTimeout(() => {
                                if (!this._jsonDbIndexReady) fallbackIndex();
                            }, 6000);
                            return;
                        } catch (e) {
                            this._indexWorker.removeEventListener('message', onmsg);
                        }
                    }
                } catch (e) {}
                fallbackIndex();
            };

            const fallbackIndex = () => {
                const apiMap = new Map();
                const idMap = new Map();
                const textMap = new Map();
                const catToTypeMap = new Map();
                function walk(obj) {
                    if (Array.isArray(obj)) {
                        obj.forEach(item => walk(item));
                    } else if (typeof obj === 'object' && obj !== null) {
                        if (obj.api) apiMap.set(obj.api, obj);
                        if (obj.id) idMap.set(obj.id, obj);
                        if (obj.text) textMap.set(obj.text, obj);
                        if (obj.category && Array.isArray(obj.category) && obj.id) {
                            for (const cat of obj.category) {
                                catToTypeMap.set(cat.id, obj);
                            }
                        }
                        for (const key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                walk(obj[key]);
                            }
                        }
                    }
                }
                try {
                    walk(db?.type || db);
                } catch (err) {}
                this._jsonDbIndex = { apiMap, idMap, textMap, catToTypeMap };
                this._jsonDbIndexReady = true;
                resolve(this._jsonDbIndex);
            };

            if (rawText) {
                tryWorker();
            } else {
                fallbackIndex();
            }
        });

        await this._jsonDbIndexPromise;
        return this._jsonDbIndex;
    },

    async loadApiDatabase() {
        this._warmup();
        if (this.apiCache && Date.now() - this.apiCacheTimestamp < this.constants.CACHE_DURATION) {
            if (!this._jsonDbIndexReady) this._buildJsonDbIndex(this.apiCache).catch(()=>{});
            return this.apiCache;
        }
        try {
            const db = await this.fetchWithRetry(this.constants.API_DATABASE_PATH);
            this.apiCache = db;
            this.apiCacheTimestamp = Date.now();
            try {
                await this._buildJsonDbIndex(db);
            } catch {}
            return db;
        } catch (e) {
            if (this.apiCache) return this.apiCache;
            throw e;
        }
    },

    async fetchApiContent(apiCode) {
        const db = await this.loadApiDatabase();
        const idx = this._jsonDbIndexReady ? this._jsonDbIndex : (await this._buildJsonDbIndex(db));
        if (idx && idx.apiMap.has(apiCode)) {
            const node = idx.apiMap.get(apiCode);
            return node.text || node;
        }
        function findApiValue(obj, targetApi) {
            if (Array.isArray(obj)) {
                for (const item of obj) {
                    const found = findApiValue(item, targetApi);
                    if (found) return found;
                }
            } else if (typeof obj === 'object' && obj !== null) {
                if (obj.api === targetApi) return obj.text || obj;
                for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        const found = findApiValue(obj[key], targetApi);
                        if (found) return found;
                    }
                }
            }
            return null;
        }
        const content = findApiValue(db, apiCode);
        if (!content) throw new Error(`API code not found: ${apiCode}`);
        return content;
    },

    async fetchCategoryGroup(categoryId) {
        const idRaw = categoryId.replace(/_category$/, '');
        const db = await this.loadApiDatabase();
        const idx = this._jsonDbIndexReady ? this._jsonDbIndex : (await this._buildJsonDbIndex(db));
        let found = null, typeName = "", typeId = "";
        if (idx && idx.idMap.has(idRaw)) {
            found = idx.idMap.get(idRaw);
            const typeObj = idx.catToTypeMap.get(idRaw);
            if (typeObj) {
                typeId = typeObj.id;
                typeName = typeObj.name;
            }
        }
        if (!found && Array.isArray(db?.type)) {
            for (const typeObj of db.type) {
                typeId = typeObj.id;
                typeName = typeObj.name;
                if (Array.isArray(typeObj.category)) {
                    for (const cat of typeObj.category) {
                        if (cat.id === idRaw) { found = cat; break; }
                    }
                }
                if (found) break;
            }
        }
        if (!found && Array.isArray(db)) {
            for (const typeObj of db) {
                typeId = typeObj.id;
                typeName = typeObj.name;
                if (Array.isArray(typeObj.category)) {
                    for (const cat of typeObj.category) {
                        if (cat.id === idRaw) { found = cat; break; }
                    }
                }
                if (found) break;
            }
        }
        if (!found) throw new Error(`Category not found: ${categoryId}`);
        const currentLang = localStorage.getItem('selectedLang') || 'en';
        const header = {
            title: found.name?.[currentLang] || found.name?.en || found.id,
            description: typeName?.[currentLang] || typeName?.en || "",
            typeId,
            categoryId: found.id,
            className: "auto-category-header"
        };
        return { id: found.id, name: found.name, data: found.data, header };
    }
};

// ---------- Part 5: ContentLoadingManager ----------
window._headerV2_contentLoadingManager = {
    spinnerElement: null,
    LOADING_CONTAINER_ID: 'content-loading',
    
    createSpinner(message = '') {
        if (this.spinnerElement && document.body.contains(this.spinnerElement)) {
            this.updateMessage(message);
            return this.spinnerElement;
        }
        const spinner = document.createElement('div');
        spinner.className = 'content-loading-spinner content-loading-fade-in';
        spinner.id = 'headerv2-spinner';
        spinner.innerHTML = `
            <div class="spinner-svg" aria-label="loading">
                <svg width="48" height="48" viewBox="0 0 48 48" focusable="false">
                    <circle class="spinner-svg-bg" cx="24" cy="24" r="20" fill="none" stroke="#eee" stroke-width="6"/>
                    <circle class="spinner-svg-fg" cx="24" cy="24" r="20" fill="none" stroke="#4285f4" stroke-width="6" stroke-linecap="round" stroke-dasharray="90 125" stroke-dashoffset="0"/>
                </svg>
            </div>
            <div class="loading-message">${message || this.getDefaultMessage()}</div>
        `;
        this.spinnerElement = spinner;
        return spinner;
    },
    
    show(message = '') {
        const container = document.getElementById(this.LOADING_CONTAINER_ID);
        if (!container) return;
        this.hide();
        const spinner = this.createSpinner(message);
        spinner.classList.remove('content-loading-fade-out');
        spinner.classList.add('content-loading-fade-in');
        container.appendChild(spinner);
    },
    
    hide() {
        if (this.spinnerElement && this.spinnerElement.parentNode) {
            this.spinnerElement.classList.remove('content-loading-fade-in');
            this.spinnerElement.classList.add('content-loading-fade-out');
            const spinnerToRemove = this.spinnerElement;
            const removeSpinner = () => {
                if (spinnerToRemove.parentNode) spinnerToRemove.parentNode.removeChild(spinnerToRemove);
            };
            spinnerToRemove.addEventListener('animationend', removeSpinner, { once: true });
            setTimeout(removeSpinner, 400);
            this.spinnerElement = null;
        } else {
            this.spinnerElement = null;
        }
    },
    
    updateMessage(message = '') {
        if (this.spinnerElement) {
            const msg = this.spinnerElement.querySelector('.loading-message');
            if (msg) msg.textContent = message || this.getDefaultMessage();
        }
    },
    
    getDefaultMessage() {
        const lang = localStorage.getItem('selectedLang') || 'en';
        return lang === 'th' ? 'กำลังโหลดเนื้อหา...' : 'Loading content...';
    }
};

// ---------- Part 6: ContentManager (chunked sentinel-driven rendering) ----------
// Improved Content Manager (replace the existing window._headerV2_contentManager object with this block)
// - Robust cancellation using session IDs + AbortController
// - Defensive clearContent that fully cleans prior state (sentinel, observers, timeouts)
// - Sentinel-driven chunked rendering (render next chunk only when user reaches sentinel)
// - Adaptive batch sizing, element pooling, view tracking via IntersectionObserver
// - Safe guards to avoid race conditions when switching content rapidly (clicks/navigation)

window._headerV2_contentManager = {
    // State & pools
    _renderSession: 0,
    _abortController: null,
    _virtualNodes: [],
    _items: [],
    _renderedSet: new Set(),
    _viewObserver: null,
    _sentinelObserver: null,
    _cleanupRender: null,
    _scheduleId: null,
    _isUnmounted: false,

    _elementPool: [],
    _poolMax: 20,

    // Performance sampling (adaptive batch)
    _frameSamples: [],
    _avgFrameTime: 16,
    _baseBatch: 6,
    _minBatch: 3,
    _maxBatch: 18,

    // Learning worker (lazy)
    _learningWorker: null,
    _learningData: { views: {}, clicks: {} },
    _learningEnabled: true,
    _lastScores: {},

    // Sentinel id / flags
    _SENTINEL_ID: 'headerv2-render-sentinel',
    _isRenderingNextBatch: false,
    _throttledScrollCheck: null,

    // -------------------------
    // Utilities
    // -------------------------
    _acquireFromPool() {
        const node = this._elementPool.pop() || document.createElement('div');
        node.className = '';
        node.style.opacity = '';
        node.style.transition = '';
        return node;
    },
    _releaseToPool(node) {
        if (!node) return;
        try {
            node.innerHTML = '';
            node.className = '';
            node.style.cssText = '';
            node.removeAttribute('id');
        } catch {}
        if (this._elementPool.length < this._poolMax) this._elementPool.push(node);
    },

    _recordFrameSample(durationMs) {
        this._frameSamples.push(durationMs);
        if (this._frameSamples.length > 30) this._frameSamples.shift();
        const alpha = 0.18;
        if (!this._avgFrameTime) this._avgFrameTime = durationMs;
        else this._avgFrameTime = (alpha * durationMs) + ((1 - alpha) * this._avgFrameTime);
    },

    _computeAdaptiveBatchSize() {
        const target = 14;
        const ratio = Math.max(0.25, Math.min(4, target / (this._avgFrameTime || 16)));
        let batch = Math.round(this._baseBatch * ratio);
        batch = Math.max(this._minBatch, Math.min(this._maxBatch, batch));
        return batch;
    },

    _initLearningWorkerIfNeeded(itemsCount = 0) {
        if (!this._learningEnabled || this._learningWorker) return;
        if (itemsCount < 30) return; // threshold to avoid overhead for small lists
        try {
            const workerCode = `
                const state = { views: {}, clicks: {} };
                function score(id) {
                    const v = state.views[id] || 0;
                    const c = state.clicks[id] || 0;
                    return Math.log(1 + v) + (3 * Math.log(1 + c));
                }
                onmessage = function(e) {
                    const { type, payload } = e.data || {};
                    if (type === 'record') {
                        const { kind, id } = payload;
                        if (!id) return;
                        if (kind === 'view') state.views[id] = (state.views[id] || 0) + 1;
                        if (kind === 'click') state.clicks[id] = (state.clicks[id] || 0) + 1;
                    } else if (type === 'getScores') {
                        const items = payload.items || [];
                        const result = {};
                        for (const id of items) result[id] = score(id) || 0;
                        postMessage({ type: 'scores', payload: result });
                    } else if (type === 'hydrate') {
                        const { views, clicks } = payload || {};
                        if (views) Object.assign(state.views, views);
                        if (clicks) Object.assign(state.clicks, clicks);
                    }
                };
            `;
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            this._learningWorker = new Worker(url);
            this._learningWorker.onmessage = (e) => {
                const { type, payload } = e.data || {};
                if (type === 'scores') this._lastScores = payload || {};
            };
            this._learningWorker.postMessage({ type: 'hydrate', payload: this._learningData });
        } catch (err) {
            this._learningWorker = null;
        }
    },

    _recordEvent(kind, id) {
        if (!id) return;
        try {
            if (this._learningWorker) {
                this._learningWorker.postMessage({ type: 'record', payload: { kind, id } });
            } else {
                const bucket = kind === 'click' ? 'clicks' : 'views';
                this._learningData[bucket][id] = (this._learningData[bucket][id] || 0) + 1;
            }
        } catch {}
    },

    _getPriorityScoresFor(ids) {
        return new Promise((resolve) => {
            const fallback = {};
            for (const id of ids) {
                const v = (this._learningData.views && this._learningData.views[id]) || 0;
                const c = (this._learningData.clicks && this._learningData.clicks[id]) || 0;
                fallback[id] = Math.log(1 + v) + (3 * Math.log(1 + c));
            }
            if (this._learningWorker) {
                const timer = setTimeout(() => resolve(fallback), 80);
                const onmsg = (e) => {
                    if (e.data && e.data.type === 'scores') {
                        clearTimeout(timer);
                        this._learningWorker.removeEventListener('message', onmsg);
                        resolve(e.data.payload || fallback);
                    }
                };
                this._learningWorker.addEventListener('message', onmsg);
                this._learningWorker.postMessage({ type: 'getScores', payload: { items: ids } });
            } else resolve(fallback);
        });
    },

    // -------------------------
    // Clear / Cancel
    // -------------------------
    async clearContent() {
        // Increment renderSession to mark prior sessions stale
        this._renderSession = (this._renderSession || 0) + 1;
        const currentSession = this._renderSession;

        // Abort any ongoing async operations
        try {
            if (this._abortController) {
                try { this._abortController.abort(); } catch {}
                this._abortController = null;
            }
        } catch {}

        // Mark unmounted so running loops can exit
        this._isUnmounted = true;
        this._isRenderingNextBatch = false;

        // Remove sentinel if present
        try {
            const sentinel = document.getElementById(this._SENTINEL_ID);
            if (sentinel && sentinel.parentNode) sentinel.parentNode.removeChild(sentinel);
        } catch {}

        // Hide spinner immediately
        try { window._headerV2_contentLoadingManager.hide(); } catch {}

        // Disconnect observers
        if (this._viewObserver) {
            try { this._viewObserver.disconnect(); } catch {}
            this._viewObserver = null;
        }
        if (this._sentinelObserver) {
            try { this._sentinelObserver.disconnect(); } catch {}
            this._sentinelObserver = null;
        }

        // Cancel any scheduled idle callbacks/timeouts
        if (this._scheduleId) {
            try {
                if (typeof cancelIdleCallback === 'function') cancelIdleCallback(this._scheduleId);
                else clearTimeout(this._scheduleId);
            } catch {}
            this._scheduleId = null;
        }

        // Remove scroll fallback handler
        if (this._throttledScrollCheck) {
            try { window.removeEventListener('scroll', this._throttledScrollCheck); } catch {}
            this._throttledScrollCheck = null;
        }

        // Remove existing nodes and release to pool
        try {
            for (const node of this._virtualNodes) {
                try { if (node && node.parentNode) node.parentNode.removeChild(node); } catch {}
                try { this._releaseToPool(node); } catch {}
            }
        } catch {}

        // Reset collections
        this._virtualNodes.length = 0;
        this._items = [];
        this._renderedSet = new Set();

        // Reset perf stats
        this._frameSamples.length = 0;
        this._avgFrameTime = 16;

        // leave _isUnmounted = true; renderContent will set false when starting new session
        return currentSession;
    },

    // -------------------------
    // Core render logic (sentinel-driven chunking)
    // -------------------------
    async renderContent(data) {
        if (!Array.isArray(data)) throw new Error('Content data should be array');
        const container = document.getElementById(window._headerV2_contentLoadingManager.LOADING_CONTAINER_ID);
        if (!container) return;

        // Ensure a clean slate
        await this.clearContent();

        // New render session
        this._renderSession = (this._renderSession || 0) + 1;
        const session = this._renderSession;
        this._abortController = new AbortController();
        const signal = this._abortController.signal;
        this._isUnmounted = false;
        this._isRenderingNextBatch = false;

        // Prepare items and learning worker
        const items = data.slice();
        this._items = items;
        this._initLearningWorkerIfNeeded(items.length);

        // Style hint (lightweight)
        if (!document.getElementById('gpu-accel-style')) {
            const style = document.createElement('style');
            style.id = 'gpu-accel-style';
            style.textContent = `
                .fade-in, .fade-out, .card, .button-content { will-change: opacity; }
                .fade-in { opacity: 0; transition: opacity 44ms cubic-bezier(.7,0,.7,1) !important; }
                .fade-out { opacity: 0; transition: opacity 28ms cubic-bezier(.7,0,.7,1) !important; }
            `;
            document.head.appendChild(style);
        }

        // Setup view observer
        if ('IntersectionObserver' in window && !this._viewObserver) {
            this._viewObserver = new IntersectionObserver((entries) => {
                for (const entry of entries) {
                    if (signal.aborted) break;
                    if (entry.isIntersecting) {
                        const node = entry.target;
                        try { this._recordEvent('view', node.id); } catch {}
                    }
                }
            }, { root: null, rootMargin: '200px', threshold: 0.25 });
        }

        // Priority scoring (best-effort)
        const idList = items.map((it, idx) => it.id || `__idx_${idx}`);
        let priorityScores = {};
        try { priorityScores = await this._getPriorityScoresFor(idList); } catch {}
        const scored = idList.some(id => priorityScores && priorityScores[id] && priorityScores[id] > 0);
        if (scored) {
            items.sort((a, b) => {
                const idA = a.id || '';
                const idB = b.id || '';
                const sa = priorityScores[idA] || 0;
                const sb = priorityScores[idB] || 0;
                return sb - sa;
            });
        }

        // Helper: sentinel element
        const createSentinel = () => {
            let sentinel = document.getElementById(this._SENTINEL_ID);
            if (!sentinel) {
                sentinel = document.createElement('div');
                sentinel.id = this._SENTINEL_ID;
                sentinel.style.width = '1px';
                sentinel.style.height = '1px';
                sentinel.style.opacity = '0';
                sentinel.style.pointerEvents = 'none';
            }
            return sentinel;
        };

        // Render a batch starting at startIndex
        const renderBatch = async (startIndex, batchSize) => {
            if (signal.aborted || this._isUnmounted || session !== this._renderSession) return 0;
            const end = Math.min(items.length, startIndex + batchSize);
            if (startIndex >= end) return 0;
            const frag = document.createDocumentFragment();
            const t0 = performance.now();
            let created = 0;

            for (let i = startIndex; i < end; i++) {
                if (signal.aborted || this._isUnmounted || session !== this._renderSession) break;
                if (this._renderedSet.has(i)) continue;
                const item = items[i];
                const wrapper = this._acquireFromPool();
                wrapper.id = item.id || `content-item-${i}`;
                const inner = this.createContainer(item);
                try {
                    if (item.group?.categoryId) {
                        await this.renderGroupItems(inner, item.group);
                    } else if (item.categoryId) {
                        await this.renderGroupItems(inner, { categoryId: item.categoryId, type: item.type || "button" });
                    } else {
                        await this.renderSingleItem(inner, item);
                    }
                } catch (err) {
                    console.error('render item error', err);
                }
                wrapper.appendChild(inner);
                wrapper.classList.add('fade-in');
                wrapper.style.opacity = 0;
                frag.appendChild(wrapper);
                this._virtualNodes.push(wrapper);
                this._renderedSet.add(i);
                created++;
            }

            if (frag.childNodes.length > 0) {
                container.appendChild(frag);
                const appended = Array.from(container.children).slice(-created);
                appended.forEach(el => {
                    try { if (this._viewObserver) this._viewObserver.observe(el); } catch {}
                });
                requestAnimationFrame(() => {
                    for (const node of appended) node.style.opacity = 1;
                });
            }

            // Trim old nodes to limit DOM size
            const MAX_IN_DOM = 28;
            while (this._virtualNodes.length > MAX_IN_DOM) {
                const old = this._virtualNodes.shift();
                this._animateOutAndRemove(old, 28);
            }

            const dt = performance.now() - t0;
            this._recordFrameSample(dt);
            return created;
        };

        // Schedule helper
        const scheduleIdle = (fn) => {
            if ('requestIdleCallback' in window) requestIdleCallback(fn, { timeout: 200 });
            else setTimeout(fn, 16);
        };

        // Initial batch (render first chunk only)
        const initialBatch = Math.min(items.length, this._computeAdaptiveBatchSize());
        await renderBatch(0, initialBatch);
        let renderedCount = this._renderedSet.size;

        // If nothing to render, hide spinner and exit
        if (renderedCount >= items.length) {
            window._headerV2_contentLoadingManager.hide();
            return;
        }

        // Insert sentinel at end and observe it
        let sentinel = createSentinel();
        container.appendChild(sentinel);

        const onSentinelIntersect = (entries) => {
            if (signal.aborted || this._isUnmounted || session !== this._renderSession) return;
            for (const entry of entries) {
                if (entry.isIntersecting && !this._isRenderingNextBatch) {
                    this._isRenderingNextBatch = true;
                    scheduleIdle(async () => {
                        try {
                            if (signal.aborted || this._isUnmounted || session !== this._renderSession) return;
                            const nextBatch = this._computeAdaptiveBatchSize();
                            const created = await renderBatch(renderedCount, nextBatch);
                            renderedCount = this._renderedSet.size;
                            if (renderedCount < items.length) {
                                // move sentinel to end
                                try { if (sentinel.parentNode) sentinel.parentNode.removeChild(sentinel); } catch {}
                                container.appendChild(sentinel);
                            } else {
                                // done
                                try { if (sentinel.parentNode) sentinel.parentNode.removeChild(sentinel); } catch {}
                                if (this._sentinelObserver) { try { this._sentinelObserver.disconnect(); } catch {} this._sentinelObserver = null; }
                                window._headerV2_contentLoadingManager.hide();
                            }
                        } catch (err) {
                            console.error('Error rendering next batch', err);
                        } finally {
                            this._isRenderingNextBatch = false;
                        }
                    });
                }
            }
        };

        if ('IntersectionObserver' in window) {
            if (this._sentinelObserver) { try { this._sentinelObserver.disconnect(); } catch {} this._sentinelObserver = null; }
            this._sentinelObserver = new IntersectionObserver(onSentinelIntersect, { root: null, rootMargin: '400px', threshold: 0.1 });
            try { this._sentinelObserver.observe(sentinel); } catch {}
        } else {
            // Fallback: throttled scroll check
            this._throttledScrollCheck = this._throttledScrollCheck || (() => {
                if (this._isRenderingNextBatch || signal.aborted || this._isUnmounted || session !== this._renderSession) return;
                const rect = sentinel.getBoundingClientRect();
                if (rect.top < (window.innerHeight + 400)) {
                    this._isRenderingNextBatch = true;
                    scheduleIdle(async () => {
                        try {
                            if (signal.aborted || this._isUnmounted || session !== this._renderSession) return;
                            const nextBatch = this._computeAdaptiveBatchSize();
                            const created = await renderBatch(renderedCount, nextBatch);
                            renderedCount = this._renderedSet.size;
                            if (renderedCount >= items.length) {
                                window.removeEventListener('scroll', this._throttledScrollCheck);
                                window._headerV2_contentLoadingManager.hide();
                            }
                        } catch (err) {}
                        finally { this._isRenderingNextBatch = false; }
                    });
                }
            });
            window.addEventListener('scroll', this._throttledScrollCheck, { passive: true });
        }

        // Provide cleanup callback for external callers
        this._cleanupRender = () => {
            // Effectively cancel this session
            try { if (this._abortController) this._abortController.abort(); } catch {}
            this._isUnmounted = true;
            if (this._sentinelObserver) { try { this._sentinelObserver.disconnect(); } catch {} this._sentinelObserver = null; }
            if (this._viewObserver) { try { this._viewObserver.disconnect(); } catch {} this._viewObserver = null; }
            if (this._throttledScrollCheck) { try { window.removeEventListener('scroll', this._throttledScrollCheck); } catch {} this._throttledScrollCheck = null; }
            for (const node of this._virtualNodes) {
                if (node && node.parentNode) this._animateOutAndRemove(node, 28);
            }
            this._virtualNodes.length = 0;
            this._renderedSet.clear();
        };
    },

    // -------------------------
    // Helper renderers (unchanged semantics from original)
    // -------------------------
    createContainer(item) {
        const container = document.createElement('div');
        container.className =
            item.group?.type === 'button' || item.type === 'button'
                ? 'button-content-container'
                : 'card-content-container';
        if (item.group?.containerClass) container.classList.add(item.group.containerClass);
        return container;
    },

    async renderGroupItems(container, group) {
        if (!group.categoryId) throw new Error("Group ต้องระบุ categoryId");
        const { id, name, data, header } = await window._headerV2_dataManager.fetchCategoryGroup(group.categoryId);
        const fragment = document.createDocumentFragment();
        const headerElement = this.createGroupHeader(header);
        fragment.appendChild(headerElement);

        if (group.type !== "button") throw new Error("ขณะนี้รองรับเฉพาะ type: 'button' ใน group");
        for (const item of data) {
            const btn = await this.createButton(item);
            if (btn) fragment.appendChild(btn);
        }
        container.appendChild(fragment);
    },

    createGroupHeader(headerConfig) {
        const headerContainer = document.createElement('div');
        headerContainer.className = 'group-header';
        const currentLang = localStorage.getItem('selectedLang') || 'en';
        if (typeof headerConfig === 'string') {
            return this.createSimpleHeader(headerConfig, headerContainer);
        }
        if (headerConfig.className) {
            headerContainer.classList.add(headerConfig.className);
        }
        this.createHeaderComponents(headerContainer, headerConfig, currentLang);
        this.addLanguageChangeListener(headerContainer, headerConfig);
        return headerContainer;
    },

    createSimpleHeader(text, container) {
        const headerText = document.createElement('h2');
        headerText.className = 'group-header-text';
        headerText.textContent = text;
        container.appendChild(headerText);
        return container;
    },

    createHeaderComponents(container, config, currentLang) {
        if (config.icon) container.appendChild(this.createHeaderIcon(config.icon));
        const headerContent = document.createElement('div');
        headerContent.className = 'header-content';
        const title = this.createHeaderTitle(config, currentLang);
        headerContent.appendChild(title);
        if (config.description) {
            const desc = this.createHeaderDescription(config.description, currentLang);
            headerContent.appendChild(desc);
        }
        container.appendChild(headerContent);
        if (config.actions) container.appendChild(this.createHeaderActions(config.actions, currentLang));
    },

    createHeaderTitle(config, currentLang) {
        const title = document.createElement('h2');
        title.className = 'group-header-text';
        if (typeof config.title === 'object') {
            Object.entries(config.title).forEach(([lang, text]) => {
                title.dataset[`title${lang.toUpperCase()}`] = text;
            });
            title.textContent = config.title[currentLang] || config.title.en;
        } else {
            title.textContent = config.title;
        }
        return title;
    },

    createHeaderDescription(description, currentLang) {
        const desc = document.createElement('p');
        desc.className = 'group-header-description';
        if (typeof description === 'object') {
            Object.entries(description).forEach(([lang, text]) => {
                desc.dataset[`desc${lang.toUpperCase()}`] = text;
            });
            desc.textContent = description[currentLang] || description.en;
        } else {
            desc.textContent = description;
        }
        return desc;
    },

    addLanguageChangeListener(container, config) {
        if (!container._langListenerBound) {
            window.addEventListener('languageChange', event => {
                const newLang = event.detail.language;
                this.updateHeaderLanguage(container, config, newLang);
            });
            container._langListenerBound = true;
        }
    },

    updateHeaderLanguage(container, config, newLang) {
        const titleElement = container.querySelector('.group-header-text');
        if (titleElement && config.title) {
            if (typeof config.title === 'object') {
                titleElement.textContent =
                    config.title[newLang] || config.title.en || titleElement.textContent;
            }
        }
        const descElement = container.querySelector('.group-header-description');
        if (descElement && config.description) {
            if (typeof config.description === 'object') {
                descElement.textContent =
                    config.description[newLang] ||
                    config.description.en ||
                    descElement.textContent;
            }
        }
    },

    async renderSingleItem(container, item) {
        if (item.categoryId) {
            await this.renderGroupItems(container, { categoryId: item.categoryId, type: item.type || "button" });
            return;
        }
        const element =
            item.type === 'button'
                ? await this.createButton(item)
                : await this.createCard(item);
        if (element) container.appendChild(element);
    },

    // createButton/createCard should be compatible with previous versions
    async createButton(config) {
        const button = document.createElement('button');
        button.className = 'button-content';
        let finalContent = '';
        let apiCode = config.api || null;
        let type = config.type || null;
        try {
            if (apiCode) {
                const db = await window._headerV2_dataManager.loadApiDatabase();
                function findApiNode(obj, code) {
                    if (Array.isArray(obj)) {
                        for (const item of obj) {
                            const found = findApiNode(item, code);
                            if (found) return found;
                        }
                    } else if (typeof obj === 'object' && obj !== null) {
                        if (obj.api === code) return obj;
                        for (const key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                const found = findApiNode(obj[key], code);
                                if (found) return found;
                            }
                        }
                    }
                    return null;
                }
                const apiNode = findApiNode(db, apiCode);
                if (apiNode) {
                    finalContent = apiNode.text;
                    type = type || (apiNode.api ? 'emoji' : 'symbol');
                } else {
                    finalContent = apiCode;
                }
            } else if (config.content) {
                finalContent = config.content;
                type = 'symbol';
            } else if (config.text) {
                finalContent = config.text;
                type = 'symbol';
            } else {
                throw new Error('ต้องระบุ api, content หรือ text สำหรับ button content type');
            }
            button.textContent = finalContent;
        } catch (error) {
            button.textContent = 'Error';
        }

        button.addEventListener('click', async () => {
            try { this._recordEvent('click', button.dataset && (button.dataset.url || button.id)); } catch {}
            try {
                await unifiedCopyToClipboard({
                    text: finalContent,
                    api: apiCode,
                    type,
                    name: apiCode ? `${apiCode}` : ''
                });
            } catch (error) {
                window._headerV2_utils.showNotification('Copy failed', 'error');
            }
        });

        button.classList.add('fade-in');
        button.style.opacity = 0;
        requestAnimationFrame(() => { button.style.opacity = 1; });
        return button;
    },

    async createCard(cardConfig) {
        const lang = localStorage.getItem('selectedLang') || 'en';
        const card = document.createElement('div');
        card.className = 'card';
        if (cardConfig.image) {
            const img = document.createElement('img');
            img.className = 'card-image';
            img.src = cardConfig.image;
            img.loading = 'lazy';
            img.alt = cardConfig.imageAlt?.[lang] || cardConfig.imageAlt?.en || '';
            card.appendChild(img);
        }
        const contentDiv = document.createElement('div');
        contentDiv.className = 'card-content';
        const titleDiv = document.createElement('div');
        titleDiv.className = 'card-title';
        if (typeof cardConfig.title === 'object') {
            Object.entries(cardConfig.title).forEach(([langCode, text]) => {
                titleDiv.dataset[`title${langCode.toUpperCase()}`] = text;
            });
            titleDiv.textContent = cardConfig.title[lang] || cardConfig.title.en;
        } else if (cardConfig.name && typeof cardConfig.name === 'object') {
            titleDiv.textContent = cardConfig.name[lang] || cardConfig.name.en;
        } else {
            titleDiv.textContent = cardConfig.title || cardConfig.name || '';
        }
        contentDiv.appendChild(titleDiv);

        const descDiv = document.createElement('div');
        descDiv.className = 'card-description';
        if (typeof cardConfig.description === 'object') {
            Object.entries(cardConfig.description).forEach(([langCode, text]) => {
                descDiv.dataset[`desc${langCode.toUpperCase()}`] = text;
            });
            descDiv.textContent = cardConfig.description[lang] || cardConfig.description.en;
        } else if (cardConfig.name && typeof cardConfig.name === 'object') {
            descDiv.textContent = cardConfig.name[lang] || cardConfig.name.en;
        } else {
            descDiv.textContent = cardConfig.description || '';
        }
        contentDiv.appendChild(descDiv);

        card.appendChild(contentDiv);

        if (cardConfig.link) {
            card.addEventListener('click', () => {
                window.open(cardConfig.link, '_blank', 'noopener');
            });
        }
        if (cardConfig.className) {
            card.classList.add(cardConfig.className);
        }
        card.classList.add('fade-in');
        card.style.opacity = 0;
        card.style.transition = `opacity 44ms cubic-bezier(.7,0,.7,1)`;
        requestAnimationFrame(() => { card.style.opacity = 1; });
        return card;
    },

    _animateOutAndRemove(node, duration) {
        if (!node || !node.parentNode) return;
        node.classList.add('fade-out');
        setTimeout(() => {
            try { if (node.parentNode) node.parentNode.removeChild(node); } catch {}
            this._releaseToPool(node);
        }, duration + 8);
    },

    updateCardsLanguage(lang) {
        const cards = document.querySelectorAll('.card');
        for (const card of cards) {
            const titleElement = card.querySelector('.card-title');
            if (titleElement) {
                const newTitle = titleElement.dataset[`title${lang.toUpperCase()}`];
                if (newTitle) titleElement.textContent = newTitle;
            }
            const descElement = card.querySelector('.card-description');
            if (descElement) {
                const newDesc = descElement.dataset[`desc${lang.toUpperCase()}`];
                if (newDesc) descElement.textContent = newDesc;
            }
            const imgElement = card.querySelector('.card-image');
            if (imgElement) {
                const newAlt = imgElement.dataset[`alt${lang.toUpperCase()}`];
                if (newAlt) imgElement.alt = newAlt;
            }
        }
    }
};

// ---------- Part 7: ScrollManager ----------
window._headerV2_scrollManager = {
    state: {
        lastScrollY: 0,
        ticking: false,
        subNavOffsetTop: 0,
        subNavHeight: 0,
        isSubNavFixed: false
    },
    constants: {
        SUB_NAV_TOP_SPACING: 0,
        ANIMATION_DURATION: 300,
        Z_INDEX: { SUB_NAV: 999 }
    },

    createStickyStyles() {
        if (document.getElementById('sticky-styles')) return;
        const styleSheet = document.createElement('style');
        styleSheet.id = 'sticky-styles';
        styleSheet.textContent = `
        #sub-nav { position: sticky; top: ${this.constants.SUB_NAV_TOP_SPACING}px; left: 0; right: 0; z-index: ${this.constants.Z_INDEX.SUB_NAV}; transition: background ${this.constants.ANIMATION_DURATION}ms ease; }
        #sub-nav.fixed { box-shadow: 0 0 15px rgba(58, 60, 79, 0.08); background: rgba(240, 252, 255, 1); border-bottom: 1px solid rgba(19, 180, 127, 0.18); }
        #sub-nav.fixed #sub-buttons-container { padding: 5px !important; }
        `;
        document.head.appendChild(styleSheet);
    },

    handleSubNav() {
        const subNav = document.getElementById('sub-nav');
        if (!subNav) return;
        if (!this.state.subNavOffsetTop) {
            this.state.subNavOffsetTop = subNav.offsetTop;
            this.state.subNavHeight = subNav.offsetHeight;
        }
        const currentScroll = window.pageYOffset;
        const triggerPoint = this.state.subNavOffsetTop - this.constants.SUB_NAV_TOP_SPACING;
        if (currentScroll >= triggerPoint && !this.state.isSubNavFixed) {
            requestAnimationFrame(() => {
                subNav.classList.add('fixed');
                setTimeout(() => { subNav.classList.add('animate'); }, 10);
                this.state.isSubNavFixed = true;
            });
        } else if (currentScroll < triggerPoint && this.state.isSubNavFixed) {
            requestAnimationFrame(() => {
                subNav.classList.add('unfixing'); subNav.classList.add('animate');
                setTimeout(() => {
                    subNav.classList.remove('fixed', 'unfixing', 'animate');
                    this.state.isSubNavFixed = false;
                }, this.constants.ANIMATION_DURATION);
            });
        }
    },

    setupEventListeners() {
        window.addEventListener('scroll', () => {
            if (this.state.ticking) return;
            this.state.ticking = true;
            window.requestAnimationFrame(() => {
                try { this.handleSubNav(); } catch {}
                this.state.ticking = false;
            });
        }, { passive: true });

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) this.handleSubNav();
        });
    },

    setupResizeObserver() {
        let resizeTimer = null;
        try {
            const subNav = document.getElementById('sub-nav');
            if (!subNav) return;
            const resizeObserver = new ResizeObserver(entries => {
                if (resizeTimer) clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    entries.forEach(entry => {
                        if (entry.target.id === 'sub-nav') {
                            this.state.subNavHeight = entry.contentRect.height;
                            this.state.subNavOffsetTop = entry.target.offsetTop;
                            this.handleSubNav();
                        }
                    });
                }, 120);
            });
            resizeObserver.observe(subNav);
        } catch {}
    },

    setupMutationObserver() {
        try {
            const subNav = document.getElementById('sub-nav');
            if (!subNav) return;
            const parent = subNav.parentNode || document.body;
            const mutationObserver = new MutationObserver(() => {
                setTimeout(() => {
                    const s = document.getElementById('sub-nav');
                    if (s && !this.state.subNavOffsetTop) {
                        this.state.subNavOffsetTop = s.offsetTop;
                        this.state.subNavHeight = s.offsetHeight;
                        this.handleSubNav();
                    }
                }, 80);
            });
            mutationObserver.observe(parent, { childList: true });
        } catch {}
    },

    handleInitialScroll() {
        if (window.pageYOffset > 0) this.handleSubNav();
    },

    init() {
        try {
            this.createStickyStyles();
            this.setupEventListeners();
            this.setupResizeObserver();
            this.setupMutationObserver();
            this.handleInitialScroll();
        } catch (e) {
            console.error('scrollManager init error', e);
        }
    }
};

// ---------- Part 8: PerformanceOptimizer ----------
window._headerV2_performanceOptimizer = {
    setupLazyLoading() {
        if ('loading' in HTMLImageElement.prototype) {
            document.querySelectorAll('img').forEach(img => { if (!img.loading) img.loading = 'lazy'; });
        } else {
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                        }
                        observer.unobserve(img);
                    }
                });
            }, { rootMargin: '300px' });
            document.querySelectorAll('img[data-src]').forEach(img => imageObserver.observe(img));
        }
    },

    setupPrefetching() {
        if (!('requestIdleCallback' in window)) {
            setTimeout(() => this._doPrefetch(), 2500);
        } else {
            requestIdleCallback(() => this._doPrefetch(), { timeout: 3000 });
        }
    },

    _doPrefetch() {
        try {
            const prefetchLinks = new Set();
            const elements = Array.from(document.querySelectorAll('a[href], button[data-url]'));
            const MAX_PREFETCH = 4;
            let count = 0;
            for (const el of elements) {
                if (count >= MAX_PREFETCH) break;
                const url = el.href || el.dataset.url;
                if (!url || prefetchLinks.has(url)) continue;
                try {
                    const link = document.createElement('link');
                    link.rel = 'prefetch';
                    link.href = url;
                    link.as = url.endsWith('.json') ? 'fetch' : 'document';
                    document.head.appendChild(link);
                    prefetchLinks.add(url);
                    count++;
                } catch {}
            }
        } catch (e) {
            console.error('prefetch error', e);
        }
    },

    setupErrorBoundary() {
        const throttledNotify = window._headerV2_utils.debounce((msg) => {
            window._headerV2_utils.showNotification(msg, 'error');
        }, 800);

        window.addEventListener('error', event => {
            throttledNotify('เกิดข้อผิดพลาดที่ไม่คาดคิด กรุณาลองใหม่อีกครั้ง');
            console.error('Captured error', event.error || event);
        });

        window.addEventListener('unhandledrejection', event => {
            throttledNotify('เกิดข้อผิดพลาดในการเชื่อมต่อ กรุณาตรวจสอบอินเทอร์เน็ต');
            console.error('Unhandled rejection', event.reason);
        });
    },

    init() {
        try {
            this.setupLazyLoading();
            this.setupPrefetching();
            this.setupErrorBoundary();
        } catch (e) {
            console.error('performanceOptimizer init error', e);
        }
    }
};

// ---------- Part 9: NavigationManager ----------
window._headerV2_navigationManager = {
    state: {
        isNavigating: false,
        currentMainRoute: '',
        currentSubRoute: '',
        previousUrl: '',
        lastScrollPosition: 0
    },

    normalizeUrl(url) {
        if (!url) return '';
        const buttonConfig = window._headerV2_buttonManager?.buttonConfig;
        let main = '', sub = '';
        if (typeof url === 'object') {
            main = (url.type || '').toLowerCase();
            sub = (url.page || '').toLowerCase();
        } else if (url.startsWith('?')) {
            const params = new URLSearchParams(url);
            main = (params.get('type') || '').replace(/__$/, '').toLowerCase();
            sub = (params.get('page') || '').toLowerCase();
        } else if (url.includes('-')) {
            const [m, s] = url.split('-');
            main = m; sub = s || '';
        } else {
            main = url.toLowerCase();
        }
        const mainButton = buttonConfig?.mainButtons?.find(btn => btn.url === main || btn.jsonFile === main);
        const hasSub = !!(mainButton && Array.isArray(mainButton.subButtons) && mainButton.subButtons.length > 0);
        if (hasSub) {
            if (sub) return `?type=${main}__&page=${sub}`;
            return `?type=${main}__`;
        }
        return `?type=${main}`;
    },

    parseUrl() {
        const params = new URLSearchParams(window.location.search);
        const type = params.get('type');
        const page = params.get('page');
        return {
            main: type ? type.replace(/__$/, '') : '',
            sub: page || ''
        };
    },

    async validateUrl(url) {
        const { main, sub } = typeof url === 'object' ? url :
            (() => {
                if (url.startsWith('?')) {
                    const params = new URLSearchParams(url);
                    return {
                        main: (params.get('type') || '').replace(/__$/, ''),
                        sub: params.get('page') || ''
                    };
                } else if (url.includes('-')) {
                    const [m, s] = url.split('-');
                    return { main: m, sub: s || '' };
                } else {
                    return { main: url, sub: '' };
                }
            })();
        const config = window._headerV2_buttonManager?.buttonConfig;
        if (!config) return false;
        const mainButton = config.mainButtons.find(btn => btn.url === main || btn.jsonFile === main);
        if (!mainButton) return false;
        if (sub) {
            return mainButton.subButtons && mainButton.subButtons.some(subBtn => subBtn.url === sub || subBtn.jsonFile === sub);
        }
        return true;
    },

    async getDefaultRoute() {
        const config = window._headerV2_buttonManager?.buttonConfig;
        if (!config) return '';
        const defaultMainButton = config.mainButtons.find(btn => btn.isDefault);
        if (!defaultMainButton) return '';
        const mainRoute = defaultMainButton.url || defaultMainButton.jsonFile;
        if (!defaultMainButton.subButtons) return this.normalizeUrl(mainRoute);
        const defaultSubButton = defaultMainButton.subButtons.find(btn => btn.isDefault);
        if (!defaultSubButton) return this.normalizeUrl(mainRoute);
        const subRoute = defaultSubButton.url || defaultSubButton.jsonFile;
        return this.normalizeUrl({ type: mainRoute, page: subRoute });
    },

    async changeURL(url, force = false) {
        try {
            if (!url) return;
            const normalizedUrl = this.normalizeUrl(url);
            if (force || window.location.search !== normalizedUrl) {
                window.history.pushState({
                    url: normalizedUrl,
                    scrollPosition: this.state.lastScrollPosition
                }, '', normalizedUrl);
                this.state.previousUrl = normalizedUrl;
                window.dispatchEvent(new CustomEvent('urlChanged', {
                    detail: {
                        url: normalizedUrl,
                        mainRoute: this.state.currentMainRoute,
                        subRoute: this.state.currentSubRoute
                    }
                }));
            }
        } catch (error) {
            window._headerV2_utils.showNotification('เปลี่ยน URL ไม่สำเร็จ', 'error');
        }
    },

    async updateButtonStates(url) {
        const elements = window._headerV2_elements;
        const { main, sub } = url ?
            (url.startsWith('?') ? (() => {
                    const params = new URLSearchParams(url);
                    return {
                        main: (params.get('type') || '').replace(/__$/, ''),
                        sub: params.get('page') || ''
                    };
                })() :
                (url.includes('-') ? (() => {
                    const [m, s] = url.split('-');
                    return { main: m, sub: s || '' };
                })() : { main: url, sub: '' })
            ) : this.parseUrl();

        const navListEl = elements.navList;
        const subButtonsEl = elements.subButtonsContainer;
        if (navListEl) {
            const buttons = navListEl.querySelectorAll('button');
            for (let i = 0; i < buttons.length; i++) {
                const btn = buttons[i];
                btn.classList.toggle('active', btn.getAttribute('data-url') === main);
            }
        }
        if (subButtonsEl) {
            const buttons = subButtonsEl.querySelectorAll('button');
            for (let i = 0; i < buttons.length; i++) {
                const btn = buttons[i];
                btn.classList.toggle('active', btn.getAttribute('data-url') === `${main}-${sub}`);
            }
        }
        this.scrollActiveButtonsIntoView();
    },

    async navigateTo(route, options = {}) {
        if (this.state.isNavigating) return;
        try {
            this.state.isNavigating = true;
            this.state.lastScrollPosition = window.pageYOffset;
            
            let normalizedRoute = typeof route === 'object' ? this.normalizeUrl(route) : route;
            if (typeof route === 'string' && route.startsWith('?')) normalizedRoute = this.normalizeUrl(route);
            
            let isValidUrl = false;
            try { isValidUrl = await this.validateUrl(normalizedRoute); } catch {}
            if (!isValidUrl) normalizedRoute = await this.getDefaultRoute();
            
            const { main, sub } = typeof normalizedRoute === 'object' ?
                normalizedRoute :
                normalizedRoute.startsWith('?') ?
                (() => {
                    const params = new URLSearchParams(normalizedRoute);
                    return { main: (params.get('type') || '').replace(/__$/, ''), sub: params.get('page') || '' };
                })() :
                normalizedRoute.includes('-') ?
                (() => {
                    const [m, s] = normalizedRoute.split('-');
                    return { main: m, sub: s || '' };
                })() :
                { main: normalizedRoute, sub: '' };
            
            this.state.currentMainRoute = main;
            this.state.currentSubRoute = sub || '';
            const lang = localStorage.getItem('selectedLang') || 'en';
            
            if (!options.skipUrlUpdate) await this.changeURL({ type: main, page: sub });
            
            const config = window._headerV2_buttonManager?.buttonConfig;
            if (!config) throw new Error('buttonConfig not found');
            const mainButton = config.mainButtons.find(btn => btn.url === main || btn.jsonFile === main);
            if (!mainButton) throw new Error('mainButton not found');
            let subButton = null;
            if (mainButton.subButtons?.length) {
                subButton = mainButton.subButtons.find(btn => btn.url === sub || btn.jsonFile === sub);
                if (!subButton) {
                    subButton = mainButton.subButtons.find(btn => btn.isDefault) || mainButton.subButtons[0];
                    this.state.currentSubRoute = subButton.url || subButton.jsonFile;
                }
            }
            
            if (window._headerV2_elements && window._headerV2_elements.navList) {
                const mainNavBtn = window._headerV2_elements.navList.querySelector(`button[data-url="${main}"]`);
                if (mainNavBtn) {
                    window._headerV2_elements.navList.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    mainNavBtn.classList.add('active');
                    window._headerV2_buttonManager.state.currentMainButton = mainNavBtn;
                    window._headerV2_buttonManager.state.currentMainButtonUrl = main;
                }
            }
            
            const subButtonsContainer = window._headerV2_elements.subButtonsContainer;
            const hasSubButtons = mainButton.subButtons?.length > 0;
            const isPopState = !!options.isPopState;
            const needsRenderSubButtons = hasSubButtons && ((!isPopState) || (isPopState && subButtonsContainer.childNodes.length === 0));
            
            if (hasSubButtons) {
                if (needsRenderSubButtons) {
                    subButtonsContainer.innerHTML = "";
                    try {
                        await window._headerV2_buttonManager.renderSubButtons(mainButton.subButtons, main, lang);
                    } catch (e) {
                        window._headerV2_utils.showNotification('เกิดข้อผิดพลาดในการโหลดปุ่มย่อย', 'error');
                    }
                }
                subButtonsContainer.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                if (subButton) {
                    const subNavBtn = subButtonsContainer.querySelector(`button[data-url="${main}-${subButton.url || subButton.jsonFile}"]`);
                    if (subNavBtn) subNavBtn.classList.add('active');
                    window._headerV2_buttonManager.state.currentSubButton = subNavBtn;
                }
                await window._headerV2_contentManager.clearContent();
                if (subButton && subButton.jsonFile) {
                    try {
                        const subData = await window._headerV2_dataManager.fetchWithRetry(subButton.jsonFile);
                        await window._headerV2_contentManager.renderContent(subData);
                    } catch (e) {
                        window._headerV2_utils.showNotification('เกิดข้อผิดพลาดในการโหลดเนื้อหาย่อย', 'error');
                    }
                }
            } else {
                subButtonsContainer.innerHTML = "";
                subButtonsContainer.classList.remove('fade-in', 'fade-out');
                window._headerV2_buttonManager.state.currentSubButton = null;
                await window._headerV2_contentManager.clearContent();
                if (mainButton?.jsonFile) {
                    try {
                        const mainData = await window._headerV2_dataManager.fetchWithRetry(mainButton.jsonFile);
                        await window._headerV2_contentManager.renderContent(mainData);
                    } catch (e) {
                        window._headerV2_utils.showNotification('เกิดข้อผิดพลาดในการโหลดเนื้อหาหลัก', 'error');
                    }
                }
            }
            
            await this.updateButtonStates(this.normalizeUrl({ type: main, page: sub }));
            
            if (!options.maintainScroll) {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        } catch (error) {
            window._headerV2_contentLoadingManager.hide();
            window._headerV2_utils.showNotification('เกิดข้อผิดพลาดในการนำทาง', 'error');
            console.error('navigateTo error', error);
        } finally {
            window._headerV2_contentLoadingManager.hide();
            this.state.isNavigating = false;
        }
    },

    async loadMainAndSubParallel(mainButton, subButton) {
        try {
            const jobs = [];
            if (mainButton?.jsonFile) jobs.push(window._headerV2_dataManager.fetchWithRetry(mainButton.jsonFile));
            if (subButton?.jsonFile) jobs.push(window._headerV2_dataManager.fetchWithRetry(subButton.jsonFile));
            const results = await Promise.all(jobs);
            if (results.length === 2) {
                await window._headerV2_contentManager.renderContent([...results[0], ...results[1]]);
            } else if (results.length === 1) {
                await window._headerV2_contentManager.renderContent(results[0]);
            }
        } catch (error) {
            window._headerV2_utils.showNotification('โหลดเนื้อหาหลัก/ย่อยไม่สำเร็จ', 'error');
        }
    },

    scrollActiveButtonsIntoView() {
        try {
            ['nav ul', '#sub-buttons-container'].forEach(selector => {
                const container = document.querySelector(selector);
                if (!container) return;
                const activeButton = container.querySelector('button.active');
                if (!activeButton) return;
                requestAnimationFrame(() => {
                    try {
                        const containerBounds = container.getBoundingClientRect();
                        const buttonBounds = activeButton.getBoundingClientRect();
                        const scrollLeft = container.scrollLeft + (buttonBounds.left - containerBounds.left) - 20;
                        container.scrollTo({
                            left: Math.max(0, scrollLeft),
                            behavior: 'smooth'
                        });
                    } catch {}
                });
            });
        } catch {}
    }
};

// ---------- Part 10: SubNavManager ----------
window._headerV2_subNavManager = {
    ensureSubNavContainer() {
        let subNav = document.getElementById('sub-nav');
        if (!subNav) {
            subNav = document.createElement('div');
            subNav.id = 'sub-nav';
            subNav.className = 'hi';
            const header = document.querySelector('header');
            if (header && header.nextSibling) {
                header.parentNode.insertBefore(subNav, header.nextSibling);
            } else {
                document.body.insertBefore(subNav, document.body.firstChild);
            }
        }
        let hj = subNav.querySelector('.hj');
        if (!hj) {
            hj = document.createElement('div');
            hj.className = 'hj';
            subNav.appendChild(hj);
        }
        let subButtonsContainer = hj.querySelector('#sub-buttons-container');
        if (!subButtonsContainer) {
            subButtonsContainer = document.createElement('div');
            subButtonsContainer.id = 'sub-buttons-container';
            hj.appendChild(subButtonsContainer);
        }
        window._headerV2_elements.subNav = subNav;
        window._headerV2_elements.subNavInner = hj;
        window._headerV2_elements.subButtonsContainer = subButtonsContainer;
        return subButtonsContainer;
    },

    hideSubNav() {
        const subNav = document.getElementById('sub-nav');
        if (subNav) {
            subNav.style.display = 'none';
            if (window._headerV2_elements.subButtonsContainer)
                window._headerV2_elements.subButtonsContainer.innerHTML = '';
        }
    },

    showSubNav() {
        let subNav = document.getElementById('sub-nav');
        if (!subNav) {
            this.ensureSubNavContainer();
            subNav = document.getElementById('sub-nav');
        }
        if (subNav) {
            subNav.style.display = '';
        }
    },

    clearSubButtons() {
        const container = this.ensureSubNavContainer();
        container.innerHTML = '';
    }
};

// ---------- Part 11: ButtonManager ----------
window._headerV2_buttonManager = {
    buttonConfig: null,
    state: {
        buttonMap: new Map(),
        currentMainButton: null,
        currentSubButton: null,
        currentMainButtonUrl: null,
    },

    async loadConfig() {
        if (this.buttonConfig) {
            await this.renderMainButtons();
            return;
        }
        const cached = window._headerV2_dataManager.getCached('buttonConfig');
        if (cached) {
            this.buttonConfig = cached;
            await this.renderMainButtons();
            return;
        }
        const response = await window._headerV2_dataManager.fetchWithRetry(window._headerV2_dataManager.constants.BUTTONS_CONFIG_PATH);
        this.buttonConfig = response;
        window._headerV2_dataManager.setCache('buttonConfig', response);
        await this.renderMainButtons();
        await window._headerV2_navigationManager.updateButtonStates();
    },

    async renderMainButtons() {
        const lang = localStorage.getItem('selectedLang') || 'en';
        const { mainButtons } = this.buttonConfig;
        const navList = window._headerV2_elements.navList;
        navList.innerHTML = '';
        this.state.buttonMap = new Map();
        let defaultButton = null;

        const fragment = document.createDocumentFragment();

        for (const button of mainButtons) {
            const label = button[`${lang}_label`];
            if (!label) continue;
            const li = document.createElement('li');
            const mainButton = document.createElement('button');
            mainButton.textContent = label;
            mainButton.className = 'main-button';
            const buttonUrl = button.url || button.jsonFile;
            mainButton.setAttribute('data-url', buttonUrl);
            if (button.className) mainButton.classList.add(button.className);
            this.state.buttonMap.set(buttonUrl, { button: mainButton, config: button, element: mainButton });
            if (button.isDefault) defaultButton = { button: mainButton, config: button };

            mainButton.addEventListener('click', async (event) => {
                event.preventDefault();
                const siblings = navList.querySelectorAll('button');
                for (let i = 0; i < siblings.length; i++) siblings[i].classList.remove('active');
                mainButton.classList.add('active');
                this.state.currentMainButton = mainButton;
                this.state.currentMainButtonUrl = buttonUrl;

                await window._headerV2_contentManager.clearContent();

                if (button.subButtons && button.subButtons.length > 0) {
                    window._headerV2_subNavManager.showSubNav();
                    await this.renderSubButtons(button.subButtons, buttonUrl, lang);
                } else {
                    window._headerV2_subNavManager.hideSubNav();
                }

                const skipUrlUpdate = !!button.subButtons;
                if (!button.subButtons && button.url) {
                    await window._headerV2_navigationManager.navigateTo(button.url, { skipUrlUpdate });
                }
                if (button.jsonFile) {
                    try {
                        const data = await window._headerV2_dataManager.fetchWithRetry(button.jsonFile);
                        await window._headerV2_contentManager.renderContent(data);
                    } catch {
                        window._headerV2_utils.showNotification('โหลดเนื้อหาไม่สำเร็จ', 'error');
                    }
                }
                window._headerV2_navigationManager.state.currentMainRoute = buttonUrl;
            });

            li.appendChild(mainButton);
            fragment.appendChild(li);
        }

        navList.appendChild(fragment);

        let initialUrl = window.location.search;
        await this.handleInitialUrl(initialUrl, this.state.buttonMap, defaultButton);
    },

    async handleInitialUrl(url, buttonMap, defaultButton) {
        try {
            if (!url) url = window.location.search;
            if (!url || url === '?') {
                if (defaultButton) await this.triggerMainButtonClick(defaultButton.button);
                return;
            }
            let mainRoute = '', subRoute = '';
            if (url.startsWith('?')) {
                const params = new URLSearchParams(url);
                mainRoute = (params.get('type') || '').replace(/__$/, '');
                subRoute = params.get('page') || '';
            } else if (url.includes('-')) {
                [mainRoute, subRoute] = url.split('-');
            } else {
                mainRoute = url;
            }
            const mainButtonData = buttonMap.get(mainRoute);
            if (!mainButtonData) {
                if (defaultButton) await this.triggerMainButtonClick(defaultButton.button);
                return;
            }
            const { button: mainButton, config: mainConfig } = mainButtonData;
            try {
                const isValidUrl = await window._headerV2_navigationManager.validateUrl(url);
                if (!isValidUrl) throw new Error('URL ไม่ถูกต้อง');
                window._headerV2_navigationManager.state.currentMainRoute = mainRoute;
                window._headerV2_navigationManager.state.currentSubRoute = subRoute || '';
                this.state.currentMainButton = mainButton;
                await this.activateMainButton(mainButton, mainConfig);
                if (mainConfig.subButtons && mainConfig.subButtons.length > 0) {
                    if (subRoute) {
                        await this.handleInitialSubRoute(mainConfig, mainRoute, subRoute);
                    } else {
                        await this.handleDefaultSubButton(mainConfig, mainRoute);
                    }
                    window._headerV2_subNavManager.showSubNav();
                } else {
                    window._headerV2_subNavManager.hideSubNav();
                }
                window._headerV2_navigationManager.scrollActiveButtonsIntoView();
            } catch {
                if (defaultButton) await this.triggerMainButtonClick(defaultButton.button);
            }
        } catch {
            if (defaultButton) await this.triggerMainButtonClick(defaultButton.button);
        }
    },

    async activateMainButton(mainButton, mainConfig) {
        const navList = window._headerV2_elements.navList;
        navList.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
        mainButton.classList.add('active');
        this.state.currentMainButton = mainButton;
        await window._headerV2_contentManager.clearContent();
        if (mainConfig.subButtons && mainConfig.subButtons.length > 0) {
            window._headerV2_subNavManager.showSubNav();
            await this.renderSubButtons(mainConfig.subButtons, mainConfig.url || mainConfig.jsonFile, localStorage.getItem('selectedLang') || 'en');
        } else {
            window._headerV2_subNavManager.hideSubNav();
        }
        if (mainConfig.jsonFile) {
            const mainData = await window._headerV2_dataManager.fetchWithRetry(mainConfig.jsonFile);
            await window._headerV2_contentManager.renderContent(mainData);
        }
    },

    async handleInitialSubRoute(mainConfig, mainRoute, subRoute) {
        await new Promise(resolve => setTimeout(resolve, 80));
        const lang = localStorage.getItem('selectedLang') || 'en';
        if (mainConfig.subButtons && mainConfig.subButtons.length > 0) {
            window._headerV2_subNavManager.showSubNav();
            await this.renderSubButtons(mainConfig.subButtons, mainRoute, lang);
            const subButton = window._headerV2_elements.subButtonsContainer.querySelector(`button[data-url="${mainRoute}-${subRoute}"]`);
            const subButtonConfig = mainConfig.subButtons.find(btn => btn.url === subRoute || btn.jsonFile === subRoute);
            if (subButton && subButtonConfig) {
                window._headerV2_elements.subButtonsContainer.querySelectorAll('.button-sub').forEach(btn => btn.classList.remove('active'));
                subButton.classList.add('active');
                this.state.currentSubButton = subButton;
                if (subButtonConfig.jsonFile) {
                    await window._headerV2_contentManager.clearContent();
                    const subData = await window._headerV2_dataManager.fetchWithRetry(subButtonConfig.jsonFile);
                    await window._headerV2_contentManager.renderContent(subData);
                }
                this.scrollActiveSubButtonIntoView(subButton);
            }
        } else {
            window._headerV2_subNavManager.hideSubNav();
        }
    },

    async handleDefaultSubButton(mainConfig, mainRoute) {
        if (mainConfig.subButtons && mainConfig.subButtons.length > 0) {
            window._headerV2_subNavManager.showSubNav();
            const defaultSubButton = mainConfig.subButtons.find(btn => btn.isDefault);
            if (defaultSubButton) {
                const fullUrl = `${mainRoute}-${defaultSubButton.url || defaultSubButton.jsonFile}`;
                await window._headerV2_navigationManager.navigateTo(fullUrl, { skipUrlUpdate: false });
            }
        } else {
            window._headerV2_subNavManager.hideSubNav();
        }
    },

    async triggerMainButtonClick(button, options = {}) {
        if (!button) throw new Error('ไม่พบปุ่มหลักที่จะคลิก');
        const buttonUrl = button.getAttribute('data-url');
        const mainConfig = this.findMainButtonConfig(buttonUrl);
        await window._headerV2_contentManager.clearContent();
        if (mainConfig?.subButtons && mainConfig.subButtons.length > 0) {
            window._headerV2_subNavManager.showSubNav();
            await this.renderSubButtons(mainConfig.subButtons, mainConfig.url || mainConfig.jsonFile, localStorage.getItem('selectedLang') || 'en');
        } else {
            window._headerV2_subNavManager.hideSubNav();
        }
        this.state.currentMainButton = button;
        this.state.currentMainButtonUrl = buttonUrl;
        if (mainConfig?.jsonFile) {
            const data = await window._headerV2_dataManager.fetchWithRetry(mainConfig.jsonFile);
            await window._headerV2_contentManager.renderContent(data);
        }
        this.updateButtonState(button, false);
    },

    async triggerSubButtonClick(button) {
        if (!button) throw new Error('ไม่พบปุ่มย่อยที่จะคลิก');
        await window._headerV2_contentManager.clearContent();
        const buttonUrl = button.getAttribute('data-url');
        const [mainRoute, subRoute] = buttonUrl.split('-');
        const mainConfig = this.findMainButtonConfig(mainRoute);
        const subConfig = mainConfig?.subButtons?.find(btn => btn.url === subRoute || btn.jsonFile === subRoute);
        this.state.currentSubButton = button;
        if (subConfig?.jsonFile) {
            const data = await window._headerV2_dataManager.fetchWithRetry(subConfig.jsonFile);
            await window._headerV2_contentManager.renderContent(data);
        }
        this.updateButtonState(button, true);
        await window._headerV2_navigationManager.changeURL(buttonUrl);
    },

    async renderSubButtons(subButtons, mainButtonUrl, lang) {
        if (!subButtons || subButtons.length === 0) {
            window._headerV2_subNavManager.hideSubNav();
            return;
        }
        window._headerV2_subNavManager.showSubNav();
        const container = window._headerV2_subNavManager.ensureSubNavContainer();
        container.innerHTML = '';
        let defaultSubButton = null;
        const currentUrl = window.location.search;
        let activeSubUrl = '';
        if (currentUrl.startsWith('?')) {
            const params = new URLSearchParams(currentUrl);
            const main = (params.get('type') || '').replace(/__$/, '');
            const sub = params.get('page') || '';
            if (main && sub) activeSubUrl = `${main}-${sub}`;
        }

        const frag = document.createDocumentFragment();
        subButtons.forEach(button => {
            const label = button[`${lang}_label`];
            if (!label) return;
            const subButton = document.createElement('button');
            subButton.className = 'button-sub sub-button';
            if (button.className) subButton.classList.add(button.className);
            subButton.textContent = label;
            const fullUrl = button.url ?
                `${mainButtonUrl}-${button.url}` :
                `${mainButtonUrl}-${button.jsonFile}`;
            subButton.setAttribute('data-url', fullUrl);
            if (button.isDefault) defaultSubButton = subButton;

            subButton.addEventListener('click', async () => {
                this.updateButtonState(subButton, true);
                await window._headerV2_contentManager.clearContent();
                if (button.jsonFile) {
                    try {
                        const data = await window._headerV2_dataManager.fetchWithRetry(button.jsonFile);
                        await window._headerV2_contentManager.renderContent(data);
                    } catch {
                        window._headerV2_utils.showNotification('โหลดเนื้อหาย่อยไม่สำเร็จ', 'error');
                    }
                }
                await window._headerV2_navigationManager.changeURL(fullUrl);
            });
            frag.appendChild(subButton);
            if (fullUrl === activeSubUrl) this.updateButtonState(subButton, true);
        });
        container.appendChild(frag);
        const needsDefault = !activeSubUrl ||
            !container.querySelector('.button-sub.active');
        if (needsDefault && defaultSubButton) await this.triggerSubButtonClick(defaultSubButton);
        container.classList.remove('fade-out');
        container.classList.add('fade-in');
    },

    updateButtonState(button, isSubButton) {
        const buttonGroup = isSubButton ? window._headerV2_elements.subButtonsContainer : window._headerV2_elements.navList;
        if (buttonGroup) buttonGroup.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        if (isSubButton) {
            this.state.currentSubButton = button;
            this.scrollActiveSubButtonIntoView(button);
        } else {
            this.state.currentMainButton = button;
        }
    },

    findMainButtonConfig(url) {
        return this.buttonConfig?.mainButtons?.find(btn => btn.url === url || btn.jsonFile === url);
    },

    findSubButtonConfig(fullUrl) {
        const [mainRoute, subRoute] = fullUrl.split('-');
        const mainButton = this.findMainButtonConfig(mainRoute);
        return mainButton?.subButtons?.find(btn => btn.url === subRoute || btn.jsonFile === subRoute);
    },

    scrollActiveSubButtonIntoView(activeButton) {
        if (!activeButton) return;
        const container = window._headerV2_elements.subButtonsContainer;
        if (!container) return;
        const containerLeft = container.getBoundingClientRect().left;
        const buttonLeft = activeButton.getBoundingClientRect().left;
        const scrollLeft = container.scrollLeft;
        const targetScroll = scrollLeft + (buttonLeft - containerLeft) - 20;
        if (Math.abs(container.scrollLeft - targetScroll) > 1) {
            container.scrollTo({
                left: targetScroll,
                behavior: 'smooth'
            });
        }
    },

    updateButtonsLanguage(newLang) {
        try {
            const { mainButtons } = this.buttonConfig;
            const navList = window._headerV2_elements.navList;
            navList.querySelectorAll('button').forEach((button, index) => {
                const config = mainButtons[index];
                if (config && config[`${newLang}_label`]) button.textContent = config[`${newLang}_label`];
            });
            if (this.state.currentMainButton) {
                const mainConfig = this.findMainButtonConfig(
                    this.state.currentMainButton.getAttribute('data-url')
                );
                if (mainConfig?.subButtons && mainConfig.subButtons.length > 0) {
                    window._headerV2_subNavManager.showSubNav();
                    this.renderSubButtons(
                        mainConfig.subButtons,
                        mainConfig.url || mainConfig.jsonFile,
                        newLang
                    );
                } else {
                    window._headerV2_subNavManager.hideSubNav();
                }
            } else {
                window._headerV2_subNavManager.hideSubNav();
            }
        } catch {
            window._headerV2_utils.showNotification('อัพเดทภาษาของปุ่มไม่สำเร็จ', 'error');
        }
    }
};

// ---------- Part 12: Initialization ----------
async function headerV2_initializeApp() {
    const appState = {
        isInitialized: false,
        lastError: null,
        startTime: Date.now(),
        eventRegistered: false
    };
    
    function safeNotify(msg, type = 'error') {
        if (window._headerV2_utils && typeof window._headerV2_utils.showNotification === 'function') {
            window._headerV2_utils.showNotification(msg, type);
        } else {
            console.warn('Notification:', msg);
        }
    }
    
    function verifyCoreElements() {
        const elements = window._headerV2_elements;
        if (!elements) throw new Error('Missing _headerV2_elements');
        if (!elements.header) throw new Error('Missing header element');
        if (!elements.navList) throw new Error('Missing navList');
        if (!elements.subButtonsContainer) throw new Error('Missing subButtonsContainer');
        if (!elements.contentLoading) throw new Error('Missing contentLoading');
    }
    
    function verifyManagers() {
        if (!window._headerV2_scrollManager) throw new Error('Missing scrollManager');
        if (!window._headerV2_performanceOptimizer) throw new Error('Missing performanceOptimizer');
        if (!window._headerV2_buttonManager) throw new Error('Missing buttonManager');
        if (!window._headerV2_contentManager) throw new Error('Missing contentManager');
        if (!window._headerV2_navigationManager) throw new Error('Missing navigationManager');
        if (!window._headerV2_dataManager) throw new Error('Missing dataManager');
    }
    
    try {
        verifyCoreElements();
        verifyManagers();
        
        window._headerV2_performanceOptimizer.setupErrorBoundary();
        window._headerV2_scrollManager.init();
        window._headerV2_performanceOptimizer.init();
        
        if (!appState.eventRegistered) {
            window.addEventListener('online', () => {
                safeNotify('การเชื่อมต่อกลับมาแล้ว', 'success');
                if (appState.lastError) window._headerV2_buttonManager.loadConfig();
            }, { passive: true });
            
            window.addEventListener('offline', () => {
                safeNotify('ขาดการเชื่อมต่ออินเทอร์เน็ต', 'warning');
            }, { passive: true });
            
            window.addEventListener('popstate', async () => {
                try {
                    const url = window.location.search;
                    const navMgr = window._headerV2_navigationManager;
                    if (!navMgr) throw new Error('navigationManager missing');
                    if (!url || url === '?') {
                        const defaultRoute = await navMgr.getDefaultRoute();
                        await navMgr.navigateTo(defaultRoute, { skipUrlUpdate: true, isPopState: true });
                    } else {
                        await navMgr.navigateTo(url, { skipUrlUpdate: true, isPopState: true });
                    }
                } catch (e) {
                    safeNotify('เกิดข้อผิดพลาดในการนำทางย้อนกลับ', 'error');
                    console.error('popstate error', e);
                }
            }, { passive: true });
            
            window.addEventListener('languageChange', (event) => {
                const newLang = event.detail?.language || 'en';
                try {
                    if (window._headerV2_buttonManager.updateButtonsLanguage)
                        window._headerV2_buttonManager.updateButtonsLanguage(newLang);
                    if (window._headerV2_contentManager.updateCardsLanguage)
                        window._headerV2_contentManager.updateCardsLanguage(newLang);
                } catch (e) {
                    safeNotify('เกิดข้อผิดพลาดการเปลี่ยนภาษา', 'error');
                }
            }, { passive: true });
            
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    try {
                        if (window._headerV2_navigationManager.scrollActiveButtonsIntoView)
                            window._headerV2_navigationManager.scrollActiveButtonsIntoView();
                    } catch (e) {
                        safeNotify('เกิดข้อผิดพลาด resize', 'error');
                    }
                }, 150);
            }, { passive: true });
            
            appState.eventRegistered = true;
        }
        
        try {
            await window._headerV2_buttonManager.loadConfig();
        } catch (e) {
            safeNotify('โหลดข้อมูลปุ่มไม่สำเร็จ', 'error');
            throw e;
        }
        
        try {
            const navMgr = window._headerV2_navigationManager;
            const url = window.location.search;
            if (!url || url === '?') {
                const defaultRoute = await navMgr.getDefaultRoute();
                await navMgr.navigateTo(defaultRoute, { skipUrlUpdate: true });
            } else {
                await navMgr.navigateTo(url, { skipUrlUpdate: true });
            }
        } catch (e) {
            safeNotify('เกิดข้อผิดพลาดในการนำทางเริ่มต้น', 'error');
        }
        
        if (typeof window.__removeInstantLoadingOverlay === "function" && window.__instantLoadingOverlayShown) {
            window.__removeInstantLoadingOverlay();
            window.__instantLoadingOverlayShown = false;
        }
        
        appState.isInitialized = true;
    } catch (error) {
        appState.lastError = error;
        safeNotify('เกิดข้อผิดพลาดในการโหลดแอพพลิเคชัน กรุณารีเฟรชหน้าเว็บอีกครั้ง', 'error');
        try {
            window._headerV2_performanceOptimizer.setupErrorBoundary();
        } catch {}
        console.error('headerV2_initializeApp error', error);
    }
}

headerV2_initializeApp();

// ---------- Part 13: unifiedCopyToClipboard (lazy index + notification) ----------
window.unifiedCopyToClipboard = async function(copyInfo = {}) {
    const lang = localStorage.getItem('selectedLang') || 'en';
    try {
        if (!copyInfo || !copyInfo.text) throw new Error('No content to copy');
        await navigator.clipboard.writeText(copyInfo.text);

        let notificationParams = {
            text: copyInfo.text,
            name: "",
            typeId: "emoji",
            lang
        };

        const db = await window._headerV2_dataManager.loadApiDatabase();

        if (!window._headerV2_dataManager._copyIndex) {
            const textMap = new Map();
            const emojiMap = new Map();
            const apiMap = new Map();
            const symbolMap = new Map();

            function buildIndex(obj) {
                if (Array.isArray(obj)) {
                    obj.forEach(item => buildIndex(item));
                } else if (typeof obj === 'object' && obj !== null) {
                    if (obj.text) {
                        textMap.set(obj.text, obj);
                        const normalized = obj.text.trim().toLowerCase();
                        if (normalized.length === 1) emojiMap.set(normalized, obj);
                        if (normalized.length > 1) symbolMap.set(normalized, obj);
                    }
                    if (obj.api) apiMap.set(obj.api, obj);
                    if (obj.name) {
                        const nameNorm = (obj.name[lang] || obj.name.en || "").trim().toLowerCase();
                        if (nameNorm) symbolMap.set(nameNorm, obj);
                    }
                    for (const key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            buildIndex(obj[key]);
                        }
                    }
                }
            }

            try {
                buildIndex(db?.type || db);
            } catch (e) {}
            window._headerV2_dataManager._copyIndex = { textMap, emojiMap, apiMap, symbolMap };
        }

        const { textMap, emojiMap, apiMap, symbolMap } = window._headerV2_dataManager._copyIndex;

        function findTypeIdAndName(obj, code, parentTypeId) {
            if (Array.isArray(obj)) {
                for (const item of obj) {
                    const result = findTypeIdAndName(item, code, parentTypeId);
                    if (result) return result;
                }
            } else if (typeof obj === 'object' && obj !== null) {
                if (obj.api === code) {
                    return {
                        typeId: parentTypeId,
                        name: obj.name?.[lang] || obj.name?.en || obj.api || ""
                    };
                }
                let newParentTypeId = parentTypeId;
                if (obj.id && obj.category && Array.isArray(obj.category)) {
                    newParentTypeId = obj.id;
                }
                for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        const result = findTypeIdAndName(obj[key], code, newParentTypeId);
                        if (result) return result;
                    }
                }
            }
            return null;
        }

        if (copyInfo.api) {
            const apiNode = (window._headerV2_dataManager._copyIndex && window._headerV2_dataManager._copyIndex.apiMap)
                ? window._headerV2_dataManager._copyIndex.apiMap.get(copyInfo.api)
                : null;
            let typeId = "emoji";
            let name = "";
            const typeResult = findTypeIdAndName(db?.type || db, copyInfo.api, "emoji");
            if (typeResult) {
                typeId = typeResult.typeId || "emoji";
                name = typeResult.name;
            } else if (apiNode) {
                name = apiNode.name?.[lang] || apiNode.name?.en || apiNode.api;
            }
            notificationParams = {
                text: apiNode?.text || copyInfo.text,
                name: name ? `${name}` : apiNode?.api || copyInfo.api,
                typeId,
                lang
            };
        } else {
            let node = textMap.get(copyInfo.text) || emojiMap.get(copyInfo.text.trim().toLowerCase()) || null;

            if (!node) {
                const norm = copyInfo.text.trim().toLowerCase();
                node = textMap.get(norm) || emojiMap.get(norm) || symbolMap.get(norm) || null;
            }

            if (!node) {
                for (let [key, value] of textMap) {
                    if (key.trim().toLowerCase() === copyInfo.text.trim().toLowerCase()) {
                        node = value;
                        break;
                    }
                }
                if (!node) {
                    for (let [key, value] of emojiMap) {
                        if (key === copyInfo.text.trim().toLowerCase()) {
                            node = value;
                            break;
                        }
                    }
                }
            }

            if (node) {
                let typeId = "emoji";
                let name = "";
                let text = node.text || copyInfo.text;
                function getTypeFromParent(obj, targetNode, parentTypeId) {
                    if (Array.isArray(obj)) {
                        for (const item of obj) {
                            const result = getTypeFromParent(item, targetNode, parentTypeId);
                            if (result) return result;
                        }
                    } else if (typeof obj === 'object' && obj !== null) {
                        if (obj === targetNode) return parentTypeId;
                        let newParentTypeId = parentTypeId;
                        if (obj.id && obj.category && Array.isArray(obj.category)) {
                            newParentTypeId = obj.id;
                        }
                        for (const key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                const result = getTypeFromParent(obj[key], targetNode, newParentTypeId);
                                if (result) return result;
                            }
                        }
                    }
                    return null;
                }
                typeId = getTypeFromParent(db?.type || db, node, "emoji") || "emoji";
                name = node.name?.[lang] || node.name?.en || "";
                notificationParams = {
                    text,
                    name: name ? `${name}` : "",
                    typeId,
                    lang
                };
            } else {
                notificationParams = {
                    text: copyInfo.text,
                    name: copyInfo.text || "",
                    typeId: "special-characters",
                    lang
                };
            }
        }

        if (typeof window.showCopyNotification === "function") {
            window.showCopyNotification(notificationParams);
        } else {
            window._headerV2_utils.showNotification(notificationParams.text, "success", { duration: 2200 });
        }

    } catch (error) {
        window._headerV2_utils.showNotification(error.message || 'Copy failed', 'error');
    }
};