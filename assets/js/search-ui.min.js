/*
  search-ui.min.js (v12.4 - BACK BUTTON & COMPLETE SYNC)
  - Added robust error handling and fallbacks
  - Centralized event handler registration + cleanup
  - Clipboard fallback (execCommand) if navigator.clipboard unavailable
  - Safe IntersectionObserver usage and observer cleanup
  - Added window.__searchUI.destroy() for deterministic teardown
  - Guards for missing window.SearchEngine methods
  - IMPROVED: Overlay now scrolls naturally without height lock
  - IMPROVED: Search input remains sticky (sticky position) with higher z-index
  - IMPROVED: Suggestion window scrolls with overlay, not independently
  - NEW: Back button support with complete state synchronization
  - NEW: popstate handler syncs UI state when back/forward button pressed

  MODIFIED: Synced suggestion window lifecycle with overlay:
  - Removed all non-overlay paths that automatically hide/close suggestions
  - Escape on suggestion list or input now closes the overlay (which in turn removes suggestions)
  - Suggestion click no longer forcibly hides suggestions; overlay close is the single path removing suggestions
  
  NEW: Sticky input with scrollable overlay:
  - Suggestion container has overflow: visible, grows naturally with content
  - Input wrapper uses position: sticky (not fixed) at top
  - Suggestion container has z-index lower than input
  - Overlay scrolls with wrapper staying sticky on top

  NEW: Back button integration:
  - Opening overlay pushes state to history
  - Back button triggers popstate event and closes overlay
  - All close methods (backdrop, escape, back button) sync perfectly
  - Navigation bar state syncs regardless of close method
*/
(function () {
  'use strict';

  // Prevent initialize from running more than once
  if (window.__searchUI && window.__searchUI._initialized) return;

  const CONFIG = {
    DOM: {
      suggestionContainerId: 'searchSuggestions',
      suggestionBackdropId: 'searchSuggestionBackdrop',
      overlayBackdropId: 'searchOverlayBackdrop',
      overlayContainerId: 'searchOverlayContainer',
      sentinelId: 'search-render-sentinel',
      searchInputId: 'searchInput',
      searchFormId: 'searchForm',
      typeFilterId: 'typeFilter',
      categoryFilterId: 'categoryFilter',
      searchResultsId: 'searchResults',
      copyToastId: 'copyToast',
      searchInputWrapperId: 'search-input-wrapper',
      filterPanelSelector: '.search-filters-panel',
      placeholderId: 'search-wrapper-placeholder'
    },
    RENDER: {
      batchSize: 12,
      sentinelHeight: '36px',
      suggestionMax: 8,
      intersectionThreshold: 0.1,
      intersectionRootMargin: '0px',
      suggestionsFullscreenMax: 30
    },
    TIMING: {
      debounceMs: 120,
      toastDisplayMs: 1400,
      toastFadeMs: 250,
      focusDelayMs: 20,
      renderDelayMs: 40,
      transitionDelayMs: 350,
      blurDelayMs: 200,
      keyboardDetectionDelayMs: 100
    },
    STORAGE: {
      historyKey: 'searchHistory_v1',
      langKey: 'selectedLang'
    },
    DB: { path: '/assets/db/db.min.json' },
    LANG: { default: 'en', autoDetect: true },
    TEXTS: {
      th: {
        all_types: 'ทุกประเภท',
        all_categories: 'ทุกหมวดหมู่',
        not_found: 'ไม่พบข้อมูลที่ตรงหรือใกล้เคียง',
        copy: 'คัดลอก',
        copy_failed: 'คัดลอกไม่สำเร็จ',
        suggestion_label: 'คำแนะนำ',
        suggestions_for_you: 'คำแนะนำสำหรับคุณ',
        search_result_here: 'ผลลัพธ์การค้นหาจะปรากฏที่นี่',
        search_placeholder: 'ค้นหาข้อมูล...',
        type: 'ประเภท',
        category: 'หมวดหมู่',
        emoji: 'อีโมจิ',
        trending: 'ยอดนิยม',
        recent: 'ล่าสุด'
      },
      en: {
        all_types: 'All Types',
        all_categories: 'All Categories',
        not_found: 'No data found related to your keyword.',
        copy: 'Copy',
        copy_failed: 'Failed to copy',
        suggestion_label: 'Suggestions',
        suggestions_for_you: 'Suggestions for you',
        search_result_here: 'Search results will appear here',
        search_placeholder: 'Search information...',
        type: 'Type',
        category: 'Category',
        emoji: 'Emoji',
        trending: 'Trending',
        recent: 'Recent'
      }
    }
  };

  const State = {
    apiData: null,
    allKeywordsCache: [],
    currentResults: [],
    currentFilteredResults: [],
    selectedType: 'all',
    selectedCategory: 'all',
    lastCommittedSearchState: null,
    lastQuery: '',
    overlayOpen: false,
    overlayTransitioning: false,
    preOverlayState: null,
    keyboardOpen: false,
    keyboardDetectionTimeout: null,
    lastWindowInnerHeight: 0,
    searchHistoryPushed: false,
    suppressHistoryPush: false,
    ignoreNextHideSuggestions: false,
    overlayOpenedAt: null,
    originalInputParent: null,
    originalInputNextSibling: null,
    originalPlaceholder: null,
    debounceTimeout: null,
    renderObserver: null,
    currentRenderIndex: 0,
    isReadyMode: false,
    readyModeSuggestions: [],
    suggestionsLocked: false,
    _timeouts: new Set(),
    _handlersAttached: false,
    // ✅ NEW: State marker for overlay in history
    _overlayStateMarker: '__searchUI_overlay_open__'
  };

  // Keep references to handlers so they can be removed
  const Handlers = {
    resize: null,
    inputFocus: null,
    inputBlur: null,
    inputClick: null,
    inputInput: null,
    inputKeydown: null,
    formSubmit: null,
    overlayBackdropClick: null,
    suggestionClick: null,
    suggestionKeydown: null,
    documentKeydownOverlay: null,
    popstate: null,
    documentClick: null,
    copyClick: null
  };

  // -------------------------
  // Small utility helpers
  // -------------------------
  const LanguageService = {
    getLang: function() {
      try {
        return localStorage.getItem(CONFIG.STORAGE.langKey) ||
               (CONFIG.LANG.autoDetect && navigator.language?.startsWith('th') ? 'th' : CONFIG.LANG.default);
      } catch (e) { return CONFIG.LANG.default; }
    },
    setLang: function(lang) { try { localStorage.setItem(CONFIG.STORAGE.langKey, lang); } catch (e) {} },
    t: function(key) {
      const lang = this.getLang();
      return (CONFIG.TEXTS[lang]?.[key]) || CONFIG.TEXTS[CONFIG.LANG.default][key] || key;
    }
  };

  const DOMService = {
    get: (id) => document.getElementById(id),
    query: (sel) => document.querySelector(sel),
    queryAll: (sel) => document.querySelectorAll(sel),
    create: (tag, id, className, styles) => {
      const el = document.createElement(tag);
      if (id) el.id = id;
      if (className) el.className = className;
      if (styles) Object.assign(el.style, styles);
      return el;
    },
    remove: (el) => { try { if (el?.parentNode) el.parentNode.removeChild(el); } catch (e) {} },
    setStyles: (el, styles) => { if (!el) return; try { Object.assign(el.style, styles); } catch (e) {} },
    setText: (el, text) => { if (el) el.textContent = text; },
    setHTML: (el, html) => { if (el) el.innerHTML = html; },
    setAttr: (el, key, value) => { if (el) el.setAttribute(key, value); },
    getAttr: (el, key) => el?.getAttribute(key),
    addClass: (el, cls) => el?.classList?.add(cls),
    removeClass: (el, cls) => el?.classList?.remove(cls),
    hasClass: (el, cls) => el?.classList?.contains(cls),
    on: (el, ev, handler, opts) => { if (el && handler) el.addEventListener(ev, handler, opts); },
    off: (el, ev, handler) => { if (el && handler) el.removeEventListener(ev, handler); }
  };

  const StringService = {
    escapeHtml: (s) => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'),
    encodeUrl: (s) => encodeURIComponent(s),
    decodeUrl: (s) => { try { return decodeURIComponent(s); } catch (e) { return s; } }
  };

  const StorageService = {
    getHistory: function() {
      try { return JSON.parse(sessionStorage.getItem(CONFIG.STORAGE.historyKey) || '[]'); } catch (e) { return []; }
    },
    addSearchToHistory: function(state) {
      try {
        const arr = this.getHistory();
        arr.push(Object.assign({}, state, { ts: Date.now() }));
        sessionStorage.setItem(CONFIG.STORAGE.historyKey, JSON.stringify(arr));
      } catch (e) { console.error('Failed to save search history', e); }
    },
    clearHistory: function() { try { sessionStorage.removeItem(CONFIG.STORAGE.historyKey); } catch (e) {} }
  };

  // -------------------------
  // Keyboard detection
  // -------------------------
  const KeyboardService = {
    initKeyboardDetection: function() {
      try {
        State.lastWindowInnerHeight = window.innerHeight || 0;
        Handlers.resize = () => {
          clearTimeout(State.keyboardDetectionTimeout);
          State.keyboardDetectionTimeout = setTimeout(() => {
            try { this.updateKeyboardStatus(); } catch (e) {}
          }, CONFIG.TIMING.keyboardDetectionDelayMs);
        };
        DOMService.on(window, 'resize', Handlers.resize);

        const inputEl = DOMService.get(CONFIG.DOM.searchInputId);
        if (inputEl) {
          Handlers.inputFocus = () => {
            clearTimeout(State.keyboardDetectionTimeout);
            State.keyboardDetectionTimeout = setTimeout(() => { this.updateKeyboardStatus(); }, CONFIG.TIMING.keyboardDetectionDelayMs);
          };
          Handlers.inputBlur = () => {
            clearTimeout(State.keyboardDetectionTimeout);
            State.keyboardDetectionTimeout = setTimeout(() => { State.keyboardOpen = false; }, CONFIG.TIMING.keyboardDetectionDelayMs);
          };
          DOMService.on(inputEl, 'focus', Handlers.inputFocus);
          DOMService.on(inputEl, 'blur', Handlers.inputBlur);
        }
      } catch (e) { console.error('Keyboard detection init failed', e); }
    },

    updateKeyboardStatus: function() {
      try {
        const currentHeight = window.innerHeight || 0;
        const heightDiff = State.lastWindowInnerHeight - currentHeight;
        if (heightDiff > 100) State.keyboardOpen = true;
        else if (heightDiff < -100) State.keyboardOpen = false;
        State.lastWindowInnerHeight = currentHeight;
      } catch (e) {}
    },

    isKeyboardOpen: function() { return !!State.keyboardOpen; }
  };

  // -------------------------
  // URL service & History
  // -------------------------
  const URLService = {
    parseQueryString: function(qs) {
      const out = {};
      if (!qs) return out;
      qs = qs.replace(/^\?/, '');
      const parts = qs.split('&');
      for (let i = 0; i < parts.length; i++) {
        const p = parts[i]; if (!p) continue;
        const idx = p.indexOf('='); if (idx === -1) out[decodeURIComponent(p)] = '';
        else out[decodeURIComponent(p.substring(0, idx))] = decodeURIComponent(p.substring(idx + 1));
      }
      return out;
    },
    buildQueryString: function(obj) {
      const parts = [];
      for (const k in obj) {
        if (obj[k] === undefined || obj[k] === null) continue;
        parts.push(StringService.encodeUrl(k) + '=' + StringService.encodeUrl(obj[k]));
      }
      return parts.length ? ('?' + parts.join('&')) : '';
    },
    readStateFromURL: function() {
      try {
        const params = this.parseQueryString(window.location.search || '');
        return { q: params.q || '', type: params.type || 'all', category: params.category || 'all' };
      } catch (e) { return { q: '', type: 'all', category: 'all' }; }
    },
    buildUrlForState: function(state) {
      const params = {};
      if (state.q) params.q = state.q;
      if (state.type && state.type !== 'all') params.type = state.type;
      if (state.category && state.category !== 'all') params.category = state.category;
      return this.buildQueryString(params);
    },
    isStateEqual: function(a, b) {
      if (!a && !b) return true;
      if (!a || !b) return false;
      const aq = (a.q || '').trim();
      const bq = (b.q || '').trim();
      const at = (a.type || 'all'); const bt = (b.type || 'all');
      const ac = (a.category || 'all'); const bc = (b.category || 'all');
      return aq === bq && at === bt && ac === bc;
    },
    commitSearchState: function(state) {
      try {
        if (URLService.isStateEqual(state, State.lastCommittedSearchState)) return;
        const url = this.buildUrlForState(state);
        try {
          if (State.searchHistoryPushed) {
            history.replaceState(state, '', url);
            State.searchHistoryPushed = false;
          } else {
            history.pushState(state, '', url);
          }
        } catch (e) {
          try { history.replaceState(state, '', url); } catch (ee) {}
          State.searchHistoryPushed = false;
        }
        StorageService.addSearchToHistory(state);
        State.lastCommittedSearchState = { q: state.q || '', type: state.type || 'all', category: state.category || 'all' };
      } catch (e) { console.error('commitSearchState failed', e); }
    },
    syncOverlayCloseWithHistory: function() {
      if (State.searchHistoryPushed) {
        try {
          const stateToRestore = State.lastCommittedSearchState || { q: '', type: 'all', category: 'all' };
          history.replaceState(stateToRestore, '', this.buildUrlForState(stateToRestore));
        } catch (e) {}
        State.searchHistoryPushed = false;
      }
    }
  };

  // -------------------------
  // Notification & Clipboard (with fallback)
  // -------------------------
  const NotificationService = {
    showCopyToast: function(msg) {
      try {
        const toast = DOMService.create('div', null, 'copy-toast-message');
        DOMService.setText(toast, msg);
        const area = DOMService.get(CONFIG.DOM.copyToastId) || document.body;
        area.appendChild(toast);
        const t = setTimeout(() => {
          try {
            DOMService.setStyles(toast, { opacity: '0', transform: 'translateY(-10px)' });
            setTimeout(() => DOMService.remove(toast), CONFIG.TIMING.toastFadeMs);
          } catch (e) {}
        }, CONFIG.TIMING.toastDisplayMs);
        State._timeouts.add(t);
      } catch (e) { console.error('showCopyToast failed', e); }
    },
    async copyText(text) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          this.showCopyToast(LanguageService.t('copy') + ' แล้ว');
          return;
        }
        // Fallback: legacy execCommand copy
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        if (ok) this.showCopyToast(LanguageService.t('copy') + ' แล้ว');
        else this.showCopyToast(LanguageService.t('copy_failed'));
      } catch (e) {
        this.showCopyToast(LanguageService.t('copy_failed'));
      }
    }
  };

  // -------------------------
  // Highlight service
  // -------------------------
  const HighlightService = {
    highlightAllMatches: function(text, query) {
      if (!text || !query) return StringService.escapeHtml(text || '');
      try {
        const textStr = String(text).toLowerCase();
        const queryStr = String(query).toLowerCase();
        const queryChars = new Set(queryStr.split(''));
        let result = '';
        for (let i = 0; i < textStr.length; i++) {
          const char = textStr[i];
          if (queryChars.has(char)) {
            result += '<strong style="background-color:#fff3cd;font-weight:700">' + StringService.escapeHtml(String(text)[i]) + '</strong>';
          } else {
            result += StringService.escapeHtml(String(text)[i]);
          }
        }
        return result;
      } catch (e) { return StringService.escapeHtml(text); }
    }
  };

  // -------------------------
  // Rendering service (with robust observer handling)
  // -------------------------
  const RenderingService = {
    renderResultItem: function(item, lang) {
      try {
        const itemData = item.item || item;
        const itemText = itemData?.text || itemData?.name?.[lang] || itemData?.name?.['en'] || item.itemName || '';
        const itemApi = itemData?.api || '';
        const typeName = item.typeName || item.typeObj?.name?.[lang] || item.typeObj?.name?.['en'] || LanguageService.t('emoji');
        const catName = item.catName || item.category?.name?.[lang] || item.category?.name?.['en'] || '';
        let itemNames = [];
        if (item.itemName) itemNames.push(item.itemName);
        if (itemData?.name) {
          const nameLang = itemData.name[lang] || itemData.name['en'];
          if (nameLang && !itemNames.includes(nameLang)) itemNames.push(nameLang);
        }
        for (const k in (itemData || {})) {
          if (/_name$/.test(k) && itemData[k]) {
            const nameLang = itemData[k][lang] || itemData[k]['en'];
            if (nameLang && !itemNames.includes(nameLang)) itemNames.push(nameLang);
          }
        }
        const itemNamesStr = itemNames.filter(Boolean).join(' / ');
        const text = itemText || itemApi || '-';
        const copyTextVal = StringService.encodeUrl(text);

        return `<div class="result-item">
          <div class="result-content-area">
            <div class="result-text-area">
              <span class="result-text">${StringService.escapeHtml(text)}</span>
              ${itemApi ? `<span class="result-api">${StringService.escapeHtml(itemApi)}</span>` : ''}
            </div>
            ${itemNamesStr ? `<div class="result-names">${StringService.escapeHtml(itemNamesStr)}</div>` : ''}
            <div class="result-meta">
              <span class="result-meta-label">${LanguageService.t('type')}:</span>
              <span class="result-meta-value">${StringService.escapeHtml(typeName)}</span>
              ${catName ? `<span class="result-meta-label" style="margin-left:8px">${LanguageService.t('category')}:</span>
              <span class="result-meta-value">${StringService.escapeHtml(catName)}</span>` : ''}
            </div>
            <button class="result-copy-btn" data-text="${copyTextVal}" aria-label="${LanguageService.t('copy')}">${LanguageService.t('copy')}</button>
          </div>
        </div>`;
      } catch (e) { return `<div class="result-item"><div class="result-content-area">-</div></div>`; }
    },

    disconnectRenderObserver: function() {
      try {
        if (State.renderObserver) { State.renderObserver.disconnect(); State.renderObserver = null; }
      } catch (e) {}
      const old = DOMService.get(CONFIG.DOM.sentinelId);
      DOMService.remove(old);
    },

    renderNextBatch: function() {
      try {
        const container = DOMService.get(CONFIG.DOM.searchResultsId);
        if (!container) return;
        const lang = LanguageService.getLang();
        const start = State.currentRenderIndex;
        const end = Math.min(State.currentRenderIndex + CONFIG.RENDER.batchSize, State.currentFilteredResults.length);
        let fragment = '';
        for (let i = start; i < end; i++) {
          fragment += this.renderResultItem(State.currentFilteredResults[i], lang);
        }
        const sentinelEl = DOMService.get(CONFIG.DOM.sentinelId);
        if (sentinelEl) sentinelEl.insertAdjacentHTML('beforebegin', fragment);
        else container.insertAdjacentHTML('beforeend', fragment);
        State.currentRenderIndex = end;
        if (State.currentRenderIndex >= State.currentFilteredResults.length) this.disconnectRenderObserver();
        else {
          if (!DOMService.get(CONFIG.DOM.sentinelId)) {
            const s = DOMService.create('div', CONFIG.DOM.sentinelId, 'search-sentinel', {
              width: '100%', height: CONFIG.RENDER.sentinelHeight, display: 'block'
            });
            container.appendChild(s);
          }
          if (!State.renderObserver) {
            if ('IntersectionObserver' in window) {
              try {
                State.renderObserver = new IntersectionObserver((entries) => {
                  try {
                    for (let i = 0; i < entries.length; i++) {
                      if (entries[i].isIntersecting) {
                        setTimeout(() => {
                          if (State.currentRenderIndex < State.currentFilteredResults.length) this.renderNextBatch();
                        }, 50);
                      }
                    }
                  } catch (e) { console.error('renderObserver callback failed', e); }
                }, {
                  root: null,
                  rootMargin: CONFIG.RENDER.intersectionRootMargin,
                  threshold: CONFIG.RENDER.intersectionThreshold
                });
                const sEl = DOMService.get(CONFIG.DOM.sentinelId);
                if (sEl) State.renderObserver.observe(sEl);
              } catch (e) { console.error('Failed to create IntersectionObserver', e); }
            } else {
              // Fallback: simple timed progressive rendering
              const t = setInterval(() => {
                if (State.currentRenderIndex < State.currentFilteredResults.length) {
                  this.renderNextBatch();
                } else {
                  clearInterval(t);
                  State._timeouts.delete(t);
                }
              }, 200);
              State._timeouts.add(t);
            }
          }
        }
      } catch (e) { console.error('renderNextBatch failed', e); }
    },

    extractResultCategories: function(results) {
      try {
        const lang = LanguageService.getLang();
        let categories = [], seen = Object.create(null);
        for (let i = 0; i < results.length; i++) {
          const cat = results[i].category || { name: '' };
          const key = (cat.name?.[lang] || cat.name?.['en']) || '';
          const displayName = key;
          if (!seen[key]) { seen[key] = 1; categories.push({ key, displayName }); }
        }
        return categories;
      } catch (e) { return []; }
    },

    renderResults: function(results, showSuggestionsIfNoResult = false) {
      try {
        const container = DOMService.get(CONFIG.DOM.searchResultsId);
        const lang = LanguageService.getLang();
        if (!container) return;

        let filtered = (State.selectedCategory !== 'all')
          ? results.filter(res => ((res.category?.name?.[lang] || res.category?.name?.['en']) || '') === State.selectedCategory)
          : results;

        document.body.style.marginBottom = '60px';
        this.disconnectRenderObserver();
        State.currentFilteredResults = [];
        State.currentRenderIndex = 0;

        if (!filtered.length) {
          let html = `<div class="no-result">${LanguageService.t('not_found')}</div>`;
          if (showSuggestionsIfNoResult) {
            html += `<div class="suggestions-title-main">${LanguageService.t('suggestions_for_you')}</div>`;
            const sample = (State.apiData?.type?.[0]?.category?.[0]?.data) ? State.apiData.type[0].category[0].data.slice(0, 5) : [];
            html += `<div class="suggestions-block-list">`;
            for (let i = 0; i < sample.length; i++) {
              const item = sample[i];
              const recommendationObj = {
                item: item,
                typeObj: State.apiData?.type?.[0],
                category: State.apiData?.type?.[0]?.category?.[0],
                itemName: item.name?.[lang] || item.name?.['en'] || '',
                typeName: State.apiData?.type?.[0]?.name?.[lang] || State.apiData?.type?.[0]?.name?.['en'] || '',
                catName: State.apiData?.type?.[0]?.category?.[0]?.name?.[lang] || State.apiData?.type?.[0]?.category?.[0]?.name?.['en'] || ''
              };
              html += this.renderResultItem(recommendationObj, lang);
            }
            html += `</div>`;
          }
          DOMService.setHTML(container, html);
          const catFilterEl = DOMService.get(CONFIG.DOM.categoryFilterId);
          if (catFilterEl) catFilterEl.style.display = '';
          UIService.updateUILanguage();
          return;
        }

        State.currentFilteredResults = filtered;
        State.currentRenderIndex = 0;
        DOMService.setHTML(container, '');
        this.renderNextBatch();

        if (!window._copyResultTextHandlerSet) {
          Handlers.copyClick = (e) => {
            const btn = e.target.closest('.result-copy-btn');
            if (btn?.hasAttribute('data-text')) {
              e.preventDefault();
              NotificationService.copyText(StringService.decodeUrl(btn.getAttribute('data-text')));
            }
          };
          DOMService.on(container, 'click', Handlers.copyClick);
          window._copyResultTextHandlerSet = true;
        }

        UIService.updateUILanguage();
      } catch (e) { console.error('renderResults failed', e); }
    }
  };

  // -------------------------
  // Filter service
  // -------------------------
  const FilterService = {
    setupTypeFilter: function(selected = 'all') {
      try {
        const typeFilter = DOMService.get(CONFIG.DOM.typeFilterId);
        if (!typeFilter) return;
        let buf = [`<option value="all">${LanguageService.t('all_types')}</option>`];
        if (State.apiData?.type && Array.isArray(State.apiData.type)) {
          const lang = LanguageService.getLang();
          for (let i = 0; i < State.apiData.type.length; i++) {
            const label = State.apiData.type[i].name?.[lang] || State.apiData.type[i].name?.['en'] || '';
            buf.push(`<option value="${StringService.escapeHtml(label)}">${StringService.escapeHtml(label)}</option>`);
          }
        }
        DOMService.setHTML(typeFilter, buf.join(''));
        typeFilter.value = selected;
      } catch (e) { console.error('setupTypeFilter failed', e); }
    },

    setupCategoryFilter: function(categories, selected = 'all') {
      try {
        const catFilter = DOMService.get(CONFIG.DOM.categoryFilterId);
        if (!catFilter) return;
        let buf = [`<option value="all">${LanguageService.t('all_categories')}</option>`];
        for (let i = 0; i < categories.length; i++) {
          const { key, displayName } = categories[i];
          buf.push(`<option value="${StringService.escapeHtml(key)}">${StringService.escapeHtml(displayName)}</option>`);
        }
        DOMService.setHTML(catFilter, buf.join(''));
        catFilter.style.display = '';
        catFilter.value = selected;
      } catch (e) { console.error('setupCategoryFilter failed', e); }
    }
  };

  // -------------------------
  // Ready / Suggestion service
  // -------------------------
  const ReadyModeService = {
    extractSmartNames: function() {
      try {
        if (!State.apiData || !State.allKeywordsCache) return [];
        const lang = LanguageService.getLang();
        const suggestions = [];
        const seen = new Set();
        for (let i = 0; i < State.allKeywordsCache.length && suggestions.length < CONFIG.RENDER.suggestionsFullscreenMax; i++) {
          const kw = State.allKeywordsCache[i];
          if (!kw || !kw.item) continue;
          let name = '';
          if (kw.item.name && typeof kw.item.name === 'object') {
            name = kw.item.name[lang] || kw.item.name['en'] || '';
          }
          if (!name || name.length < 2) continue;
          if (name.includes('/') || name.includes('.') || name.includes(':') || /^[A-Za-z0-9_]+$/.test(name)) {
            if (!/[\u0E00-\u0E7F]/.test(name) && /^[A-Za-z0-9_\-]+$/.test(name) && name.length <= 20) {
              continue;
            }
          }
          if (seen.has(name)) continue;
          seen.add(name);
          suggestions.push({
            raw: name,
            display: name,
            highlightedHtml: StringService.escapeHtml(name),
            source: 'trending'
          });
        }
        return suggestions;
      } catch (e) { return []; }
    },

    renderReadyModeSuggestions: function() {
      try {
        if (!State.isReadyMode || !State.overlayOpen) return;
        const container = SuggestionService.ensureSuggestionContainer();
        if (!container) return;
        const suggestions = this.extractSmartNames();
        if (!suggestions?.length) {
          DOMService.setHTML(container, '');
          container.style.display = 'none';
          return;
        }
        let html = `<div class="suggestions-head" style="padding:12px 14px;font-weight:700;color:#333;font-size:0.95rem;">${LanguageService.t('trending')}</div>`;
        for (let i = 0; i < suggestions.length; i++) {
          const s = suggestions[i];
          html += `<div class="suggestion-item" role="option" tabindex="0" data-val="${StringService.encodeUrl(s.raw)}" style="padding:12px 14px;border-top:1px solid #f4f6fa;cursor:pointer;display:fle[...]
                    <div class="suggestion-body" style="flex:1;word-break:break-word">${s.highlightedHtml || StringService.escapeHtml(s.raw)}</div>
                  </div>`;
        }
        DOMService.setHTML(container, html);
        container.style.display = 'block';
        SuggestionService.createSuggestionBackdrop();
        State.readyModeSuggestions = suggestions;
      } catch (e) { console.error('renderReadyModeSuggestions failed', e); }
    }
  };

  const SuggestionService = {
    ensureSuggestionContainer: function() {
      try {
        let c = DOMService.get(CONFIG.DOM.suggestionContainerId);
        const overlay = DOMService.get(CONFIG.DOM.overlayContainerId);
        if (!overlay) return null;
        if (!c) {
          c = DOMService.create('div', CONFIG.DOM.suggestionContainerId, 'search-suggestions-fullscreen', {
            position: 'relative', zIndex: '9998', width: '100%', overflow: 'visible',
            background: '#fff', border: '1px solid #e6e9ee', boxShadow: '0 8px 30px rgba(19,23,40,0.12)', borderRadius: '16px',
            marginTop: '12px', pointerEvents: 'auto'
          });
          overlay.appendChild(c);
          Handlers.suggestionKeydown = (ev) => this.handleSuggestionKeydown(ev, c);
          Handlers.suggestionClick = (ev) => this.handleSuggestionClick(ev);
          DOMService.on(c, 'keydown', Handlers.suggestionKeydown);
          DOMService.on(c, 'click', Handlers.suggestionClick, { capture: false });
          DOMService.on(c, 'mouseenter', () => { State.suggestionsLocked = true; });
          DOMService.on(c, 'mouseleave', () => { State.suggestionsLocked = false; });
        }
        return c;
      } catch (e) { console.error('ensureSuggestionContainer failed', e); return null; }
    },

    createSuggestionBackdrop: function() {
      try {
        const overlay = DOMService.get(CONFIG.DOM.overlayContainerId);
        if (!overlay) return null;
        let bd = DOMService.get(CONFIG.DOM.suggestionBackdropId);
        if (bd) return bd;
        bd = DOMService.create('div', CONFIG.DOM.suggestionBackdropId, null, {
          position: 'absolute', left: '0', top: '0', right: '0', bottom: '0',
          zIndex: '9997', background: 'transparent', pointerEvents: 'none'
        });
        overlay.insertBefore(bd, overlay.firstChild);
        return bd;
      } catch (e) { return null; }
    },

    removeSuggestionBackdrop: function() { DOMService.remove(DOMService.get(CONFIG.DOM.suggestionBackdropId)); },

    hideSuggestions: function() {
      try {
        // keep function for explicit usage, but we no longer call hideSuggestions
        if (State.overlayOpen && State.suggestionsLocked) return;
        if (State.ignoreNextHideSuggestions) return;
        const c = DOMService.get(CONFIG.DOM.suggestionContainerId);
        if (c) c.style.display = 'none';
        this.removeSuggestionBackdrop();
        State.isReadyMode = false;
      } catch (e) {}
    },

    handleSuggestionKeydown: function(ev, container) {
      try {
        const items = Array.from(container.querySelectorAll('.suggestion-item'));
        if (!items.length) return;
        const active = document.activeElement;
        const idx = items.indexOf(active);
        if (ev.key === 'ArrowDown') {
          ev.preventDefault();
          const next = (idx === -1) ? items[0] : items[Math.min(items.length - 1, idx + 1)];
          next?.focus?.();
        } else if (ev.key === 'ArrowUp') {
          ev.preventDefault();
          const prev = (idx === -1) ? items[items.length - 1] : items[Math.max(0, idx - 1)];
          prev?.focus?.();
        } else if (ev.key === 'Enter') {
          ev.preventDefault();
          if (active?.classList?.contains('suggestion-item')) active?.click?.();
        } else if (ev.key === 'Escape') {
          ev.preventDefault();
          // Instead of only hiding suggestions, close the overlay (which will remove suggestions)
          try { OverlayService.closeSearchOverlay('escape'); } catch (e) {}
        }
      } catch (e) { console.error('handleSuggestionKeydown failed', e); }
    },

    handleSuggestionClick: function(ev) {
      try {
        const it = ev.target.closest('.suggestion-item');
        if (!it) return;
        ev.stopPropagation?.();
        ev.preventDefault?.();
        let val = it.getAttribute('data-val') || '';
        val = StringService.decodeUrl(val);
        const inputEl = DOMService.get(CONFIG.DOM.searchInputId);
        if (inputEl) inputEl.value = val;
        State.suggestionsLocked = false;
        // Do NOT hide suggestion here. Overlay lifecycle will control suggestion removal.
        SearchService.doSearch(null, false);
      } catch (e) { console.error('handleSuggestionClick failed', e); }
    },

    renderQuerySuggestions: function(query) {
      try {
        if (State.overlayTransitioning) return;
        const container = this.ensureSuggestionContainer();
        if (!container) return;
        if (!query?.trim()) {
          State.isReadyMode = true;
          State.lastQuery = '';
          ReadyModeService.renderReadyModeSuggestions();
          return;
        }
        State.lastQuery = query;
        State.isReadyMode = false;

        // Guard SearchEngine presence
        const suggestions = (window.SearchEngine && typeof window.SearchEngine.querySuggestions === 'function')
          ? window.SearchEngine.querySuggestions(query, CONFIG.RENDER.suggestionsFullscreenMax)
          : [];

        if (!suggestions?.length) {
          State.isReadyMode = true;
          ReadyModeService.renderReadyModeSuggestions();
          return;
        }

        let html = `<div class="suggestions-head" style="padding:12px 14px;font-weight:700;color:#333;font-size:0.95rem;">${LanguageService.t('suggestion_label')}</div>`;
        for (let i = 0; i < suggestions.length; i++) {
          const s = suggestions[i];
          const highlighted = HighlightService.highlightAllMatches(s.raw, query);
          html += `<div class="suggestion-item" role="option" tabindex="0" data-val="${StringService.encodeUrl(s.raw)}" style="padding:12px 14px;border-top:1px solid #f4f6fa;cursor:pointer;display:fle[...]
                    <div class="suggestion-body" style="flex:1;word-break:break-word">${highlighted}</div>
                  </div>`;
        }
        DOMService.setHTML(container, html);
        container.style.display = 'block';
        this.createSuggestionBackdrop();

        const inputEl = DOMService.get(CONFIG.DOM.searchInputId);
        if (inputEl) {
          inputEl.onkeydown = (e) => {
            if (e.key === 'ArrowDown') {
              e.preventDefault();
              const first = container.querySelector('.suggestion-item');
              first?.focus?.();
            } else if (e.key === 'Escape') {
              // Close overlay (which will remove suggestions)
              try { OverlayService.closeSearchOverlay('escape'); } catch (err) {}
            }
          };
        }
      } catch (e) { console.error('renderQuerySuggestions failed', e); }
    }
  };

  // -------------------------
  // Overlay service
  // -------------------------
  const OverlayService = {
    createOverlayBackdrop: function() {
      try {
        let backdrop = DOMService.get(CONFIG.DOM.overlayBackdropId);
        if (backdrop) return backdrop;
        backdrop = DOMService.create('div', CONFIG.DOM.overlayBackdropId, 'search-overlay-backdrop', {
          position: 'fixed', left: '0', top: '0', width: '100%', height: '100%',
          background: 'rgba(12,14,18,0.48)', zIndex: '9997', backdropFilter: 'blur(4px)',
          pointerEvents: 'auto', cursor: 'default'
        });

        Handlers.overlayBackdropClick = (e) => {
          try {
            if (e.target === backdrop) {
              e.preventDefault?.();
              e.stopPropagation?.();
              if (KeyboardService.isKeyboardOpen()) { return; }
              const inputEl = DOMService.get(CONFIG.DOM.searchInputId);
              const currentValue = (inputEl?.value || '').trim();
              const lastQ = (State.preOverlayState?.q || '').trim();
              if (currentValue !== lastQ && currentValue.length > 0) {
                SearchService.doSearch(null, false, { keepOverlay: false });
              } else {
                OverlayService.closeSearchOverlay('backdrop');
              }
            }
          } catch (err) { console.error('overlay backdrop click handler failed', err); }
        };

        DOMService.on(backdrop, 'click', Handlers.overlayBackdropClick);
        document.body.appendChild(backdrop);
        return backdrop;
      } catch (e) { console.error('createOverlayBackdrop failed', e); return null; }
    },

    openSearchOverlay: function() {
      try {
        if (State.overlayOpen || State.overlayTransitioning) return;
        const wrapper = DOMService.query('.search-input-wrapper');
        if (!wrapper) return;

        State.overlayTransitioning = true;
        State.originalInputParent = wrapper.parentNode;
        State.originalInputNextSibling = wrapper.nextSibling;

        const placeholder = DOMService.create('div', CONFIG.DOM.placeholderId, null, {
          width: wrapper.offsetWidth + 'px',
          height: wrapper.offsetHeight + 'px',
          visibility: 'hidden',
          display: 'block'
        });
        State.originalPlaceholder = placeholder;
        State.originalInputParent.insertBefore(placeholder, State.originalInputNextSibling);

        const inputEl = DOMService.get(CONFIG.DOM.searchInputId);
        State.preOverlayState = {
          q: inputEl?.value || '',
          type: State.selectedType || 'all',
          category: State.selectedCategory || 'all'
        };

        State.overlayOpenedAt = Date.now();
        this.createOverlayBackdrop();

        let overlay = DOMService.get(CONFIG.DOM.overlayContainerId);
        if (!overlay) {
          overlay = DOMService.create('div', CONFIG.DOM.overlayContainerId, 'search-overlay search-overlay-open', {
            position: 'fixed', left: '0', top: '0', width: '100%', height: '100%',
            zIndex: '9998', display: 'flex', flexDirection: 'column',
            alignItems: 'center', justifyContent: 'flex-start', padding: '24px 16px 16px',
            overflow: 'auto', pointerEvents: 'auto'
          });
          document.body.appendChild(overlay);
        } else {
          DOMService.setHTML(overlay, '');
        }

        DOMService.addClass(wrapper, 'overlay-elevated');
        DOMService.setStyles(wrapper, { position: 'sticky', top: '0', left: '0', width: '100%', maxWidth: '720px', zIndex: '9999', pointerEvents: 'auto' });
        overlay.appendChild(wrapper);
        SuggestionService.ensureSuggestionContainer();

        if (inputEl) {
          setTimeout(() => { try { inputEl.focus(); inputEl.select?.(); } catch (e) {} }, CONFIG.TIMING.focusDelayMs);
        }

        document.documentElement.style.overflow = 'hidden';
        document.body.style.overflow = 'hidden';

        Handlers.documentKeydownOverlay = OverlayService.overlayEscHandler;
        DOMService.on(document, 'keydown', Handlers.documentKeydownOverlay);

        State.overlayOpen = true;
        State.isReadyMode = true;
        State.lastQuery = '';
        ReadyModeService.renderReadyModeSuggestions();

        // ✅ เรียกคำสั่งซ่อนแถบนำทาง
        OverlayService._dispatchNavCommand('hide', 'search-overlay-opened');

        // ✅ Push state to history with marker
        try {
          const overlayState = Object.assign({}, State.preOverlayState || {}, { [State._overlayStateMarker]: true });
          history.pushState(overlayState, '', window.location.href);
          State.searchHistoryPushed = true;
        } catch (e) { console.error('Failed to push overlay state to history', e); }

        State.overlayTransitioning = false;
      } catch (e) { console.error('openSearchOverlay failed', e); State.overlayTransitioning = false; }
    },

    overlayEscHandler: function(e) {
      try {
        if (e.key === 'Escape') {
          if (State.preOverlayState) {
            const inp = DOMService.get(CONFIG.DOM.searchInputId);
            if (inp) inp.value = State.preOverlayState.q || '';
            State.selectedType = State.preOverlayState.type || 'all';
            State.selectedCategory = State.preOverlayState.category || 'all';
          }
          OverlayService.closeSearchOverlay('escape');
        }
      } catch (e) { console.error('overlayEscHandler failed', e); }
    },

    closeSearchOverlay: function(closeSource = 'manual') {
      try {
        if (!State.overlayOpen) return;
        State.overlayTransitioning = true;

        // ✅ Sync history based on close source
        if (closeSource === 'popstate') {
          // Popstate already handled - just close without modifying history
        } else {
          URLService.syncOverlayCloseWithHistory();
        }

        const wrapper = DOMService.query('.search-input-wrapper');
        if (wrapper) {
          DOMService.removeClass(wrapper, 'overlay-elevated');
          DOMService.setStyles(wrapper, { position: '', top: '', left: '', width: '', maxWidth: '', zIndex: '', pointerEvents: '' });
          if (State.originalInputParent) {
            if (State.originalInputNextSibling) State.originalInputParent.insertBefore(wrapper, State.originalInputNextSibling);
            else State.originalInputParent.appendChild(wrapper);
          }
        }

        if (State.originalPlaceholder) { DOMService.remove(State.originalPlaceholder); State.originalPlaceholder = null; }
        const sc = DOMService.get(CONFIG.DOM.suggestionContainerId); DOMService.remove(sc);
        SuggestionService.removeSuggestionBackdrop();
        const overlay = DOMService.get(CONFIG.DOM.overlayContainerId); DOMService.remove(overlay);
        const backdrop = DOMService.get(CONFIG.DOM.overlayBackdropId); DOMService.remove(backdrop);

        document.documentElement.style.overflow = '';
        document.body.style.overflow = '';

        DOMService.off(document, 'keydown', Handlers.documentKeydownOverlay);
        Handlers.documentKeydownOverlay = null;

        State.overlayOpen = false;
        State.isReadyMode = false;
        State.suggestionsLocked = false;
        State.lastQuery = '';
        State.overlayOpenedAt = null;

        // ✅ เรียกคำสั่งแสดงแถบนำทาง
        OverlayService._dispatchNavCommand('show', 'search-overlay-closed');

        // clear any timeouts created during overlay
        State._timeouts.forEach(t => { try { clearTimeout(t); clearInterval(t); } catch (e) {} });
        State._timeouts.clear();

        setTimeout(() => { State.overlayTransitioning = false; }, CONFIG.TIMING.transitionDelayMs);
      } catch (e) { console.error('closeSearchOverlay failed', e); State.overlayTransitioning = false; }
    },

    // ✅ Helper method ส่งคำสั่งไปยังแถบนำทาง
    _dispatchNavCommand: function(command, reason) {
      try {
        const event = new CustomEvent('modernNavCommand', {
          detail: { command, reason }
        });
        window.dispatchEvent(event);
      } catch (e) { console.error('Failed to dispatch nav command:', e); }
    }
  };

  // -------------------------
  // Search service
  // -------------------------
  const SearchService = {
    doSearch: function(e, preventPush, options) {
      try {
        if (e) e.preventDefault?.();
        options = options || {};
        const qEl = DOMService.get(CONFIG.DOM.searchInputId);
        const q = qEl?.value || '';

        const typeFilterEl = DOMService.get(CONFIG.DOM.typeFilterId);
        State.selectedType = typeFilterEl?.value || State.selectedType;
        State.selectedCategory = 'all';

        // NOTE: suggestions are now controlled by overlay lifecycle.
        // Removed automatic hiding of suggestions here so suggestion window only closes when overlay closes.

        if (!q.trim()) {
          document.body.style.marginBottom = '';
          const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${LanguageService.t('search_result_here')}</div>`;
          const sr = DOMService.get(CONFIG.DOM.searchResultsId);
          if (sr) DOMService.setHTML(sr, placeholderHtml);
          FilterService.setupCategoryFilter([], 'all');
          UIService.updateUILanguage();
          const stateCleared = { q: '', type: 'all', category: 'all' };
          if (!preventPush && !State.suppressHistoryPush && !URLService.isStateEqual(stateCleared, State.lastCommittedSearchState)) URLService.commitSearchState(stateCleared);
          if (State.overlayOpen && !options.keepOverlay) OverlayService.closeSearchOverlay('manual');
          return;
        }

        // Guard SearchEngine
        let out = { results: [], keywords: [] };
        try {
          if (window.SearchEngine && typeof window.SearchEngine.search === 'function') out = window.SearchEngine.search(q, State.selectedType) || out;
        } catch (e) { console.error('SearchEngine.search failed', e); }

        State.currentResults = out.results || [];
        State.allKeywordsCache = out.keywords || [];

        const filterCategories = RenderingService.extractResultCategories(State.currentResults);
        FilterService.setupCategoryFilter(filterCategories, 'all');

        const stateObj = { q: q, type: State.selectedType || 'all', category: 'all' };
        const willCommit = (!preventPush && !State.suppressHistoryPush && !URLService.isStateEqual(stateObj, State.lastCommittedSearchState));
        if (willCommit) {
          URLService.commitSearchState(stateObj);
          State.searchHistoryPushed = true;
        }

        RenderingService.renderResults(State.currentResults, State.currentResults.length === 0);
        if (State.overlayOpen && !options.keepOverlay) OverlayService.closeSearchOverlay('manual');
      } catch (e) { console.error('doSearch failed', e); }
    }
  };

  // -------------------------
  // UI service
  // -------------------------
  const UIService = {
    setupAutoSearchInput: function() {
      try {
        const input = DOMService.get(CONFIG.DOM.searchInputId);
        if (!input) return;
        DOMService.setAttr(input, 'enterkeyhint', 'search');

        Handlers.inputInput = () => {
          if (State.overlayTransitioning) return;
          clearTimeout(State.debounceTimeout);
          State.debounceTimeout = setTimeout(() => { SuggestionService.renderQuerySuggestions(input.value); }, CONFIG.TIMING.debounceMs);
        };
        input.addEventListener('input', Handlers.inputInput);

        Handlers.inputKeydown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            // Do not hide suggestions directly — overlay lifecycle will remove them.
            SearchService.doSearch();
            UIService.closeMobileKeyboard();
          } else if (e.key === 'ArrowDown') {
            const container = DOMService.get(CONFIG.DOM.suggestionContainerId);
            if (container) {
              const first = container.querySelector('.suggestion-item');
              first?.focus?.();
            }
          } else if (e.key === 'Backspace') {
            clearTimeout(State.debounceTimeout);
            State.debounceTimeout = setTimeout(() => { SuggestionService.renderQuerySuggestions(input.value); }, CONFIG.TIMING.debounceMs / 2);
          }
        };
        input.addEventListener('keydown', Handlers.inputKeydown);

        // Keep blur handler but do NOT hide suggestions here; suggestions close only with overlay close.
        Handlers.inputBlur = () => {
          // Intentionally left blank to avoid hiding suggestions on blur.
        };
        input.addEventListener('blur', Handlers.inputBlur);

        Handlers.inputFocus = () => { if (!State.overlayTransitioning) OverlayService.openSearchOverlay(); };
        input.addEventListener('focus', Handlers.inputFocus);

        Handlers.inputClick = () => { if (!State.overlayTransitioning) OverlayService.openSearchOverlay(); };
        input.addEventListener('click', Handlers.inputClick);
      } catch (e) { console.error('setupAutoSearchInput failed', e); }
    },

    setupMobileSelectEnter: function() {
      try {
        [CONFIG.DOM.typeFilterId, CONFIG.DOM.categoryFilterId].forEach(id => {
          const el = DOMService.get(id);
          if (!el) return;
          const onChange = () => {
            if (id === CONFIG.DOM.typeFilterId) this.onTypeChange();
            else this.onCategoryChange();
          };
          el.onchange = onChange;
          el.onkeyup = (e) => { if (e.key === 'Enter') onChange(); };
        });
      } catch (e) { console.error('setupMobileSelectEnter failed', e); }
    },

    onTypeChange: function() {
      try { State.selectedType = DOMService.get(CONFIG.DOM.typeFilterId)?.value; SearchService.doSearch(); } catch (e) {}
    },

    onCategoryChange: function() {
      try { State.selectedCategory = DOMService.get(CONFIG.DOM.categoryFilterId)?.value; RenderingService.renderResults(State.currentResults, false); this.updateUILanguage(); } catch (e) {}
    },

    closeMobileKeyboard: function() {
      try {
        const input = DOMService.get(CONFIG.DOM.searchInputId);
        if (input && document.activeElement === input) input.blur();
      } catch (e) {}
    },

    updateUILanguage: function() {
      try {
        const input = DOMService.get(CONFIG.DOM.searchInputId);
        const placeholder = LanguageService.t('search_placeholder');
        if (input && input.placeholder !== placeholder) input.placeholder = placeholder;
        const filterGroupLabels = DOMService.queryAll('.search-filters-panel .filter-group-label');
        if (filterGroupLabels.length > 0 && filterGroupLabels[0].textContent !== LanguageService.t('type')) filterGroupLabels[0].textContent = LanguageService.t('type');
        if (filterGroupLabels.length > 1 && filterGroupLabels[1].textContent !== LanguageService.t('category')) filterGroupLabels[1].textContent = LanguageService.t('category');
      } catch (e) {}
    }
  };

  // -------------------------
  // Initialization & boot
  // -------------------------
  function initializeSearchEngine() {
    try {
      KeyboardService.initKeyboardDetection();

      // Load DB with graceful fallback
      fetch(CONFIG.DB.path)
        .then(res => res.json().catch(() => ({})))
        .then(data => {
          State.apiData = data || {};
          const initFn = (window.SearchEngine && typeof window.SearchEngine.init === 'function') ? window.SearchEngine.init : async () => Promise.resolve();
          return initFn(State.apiData, {}).catch(err => { console.error('SearchEngine.init failed', err); });
        })
        .then(() => {
          try {
            State.allKeywordsCache = (window.SearchEngine && typeof window.SearchEngine.generateAllKeywords === 'function') ? window.SearchEngine.generateAllKeywords() : [];
          } catch (e) { State.allKeywordsCache = []; }
          FilterService.setupTypeFilter('all');
          UIService.setupMobileSelectEnter();
          UIService.setupAutoSearchInput();
          FilterService.setupCategoryFilter([], 'all');
          document.body.style.marginBottom = '';
          const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${LanguageService.t('search_result_here')}</div>`;
          const sr = DOMService.get(CONFIG.DOM.searchResultsId);
          if (sr) DOMService.setHTML(sr, placeholderHtml);
          UIService.updateUILanguage();

          try {
            const hs = window.history?.state;
            if (hs && typeof hs === 'object' && (hs.q !== undefined)) {
              State.lastCommittedSearchState = { q: hs.q || '', type: hs.type || 'all', category: hs.category || 'all' };
            } else {
              const arr = StorageService.getHistory();
              if (arr?.length) {
                const last = arr[arr.length - 1];
                State.lastCommittedSearchState = { q: last.q || '', type: last.type || 'all', category: last.category || 'all' };
              } else State.lastCommittedSearchState = null;
            }
          } catch (e) { State.lastCommittedSearchState = null; }

          const initial = URLService.readStateFromURL();
          if (initial?.q) {
            try {
              State.suppressHistoryPush = true;
              const input = DOMService.get(CONFIG.DOM.searchInputId);
              if (input) input.value = initial.q;
              State.selectedType = initial.type || 'all';
              State.selectedCategory = initial.category || 'all';
              FilterService.setupTypeFilter(State.selectedType);
              SearchService.doSearch(null, true);
              try { history.replaceState({ q: initial.q, type: State.selectedType, category: State.selectedCategory }, '', URLService.buildUrlForState(initial)); } catch (e) {}
              State.lastCommittedSearchState = { q: initial.q || '', type: State.selectedType || 'all', category: State.selectedCategory || 'all' };
            } finally { State.suppressHistoryPush = false; }
          } else {
            try { history.replaceState({ q: '', type: 'all', category: 'all' }, '', window.location.pathname); } catch (e) {}
            State.lastCommittedSearchState = { q: '', type: 'all', category: 'all' };
          }
        })
        .catch(err => {
          console.error('Failed to load api database', err);
          State.apiData = State.apiData || {};
        });

      const formEl = DOMService.get(CONFIG.DOM.searchFormId);
      if (formEl) {
        Handlers.formSubmit = (e) => { e.preventDefault(); SearchService.doSearch(); UIService.closeMobileKeyboard(); };
        DOMService.on(formEl, 'submit', Handlers.formSubmit);
      }

      const inputEl = DOMService.get(CONFIG.DOM.searchInputId);
      if (inputEl) {
        const kdown = (e) => { if (e.key === 'Enter') { e.preventDefault(); SearchService.doSearch(); UIService.closeMobileKeyboard(); } };
        Handlers.inputKeydown = kdown;
        DOMService.on(inputEl, 'keydown', kdown);
      }

      // ✅ popstate handling - triggered by back/forward button
      Handlers.popstate = function(e) {
        try {
          const state = e.state || {};
          const isOverlayState = state[State._overlayStateMarker];
          
          // ✅ If we're trying to go back from overlay state, close overlay
          if (isOverlayState && State.overlayOpen) {
            // Close overlay and sync everything
            OverlayService.closeSearchOverlay('popstate');
            return;
          }
          
          // ✅ If overlay is open but we're popping to non-overlay state, close it
          if (!isOverlayState && State.overlayOpen) {
            if (State.preOverlayState) {
              const inp = DOMService.get(CONFIG.DOM.searchInputId);
              if (inp) inp.value = State.preOverlayState.q || '';
              State.selectedType = State.preOverlayState.type || 'all';
              State.selectedCategory = State.preOverlayState.category || 'all';
            }
            OverlayService.closeSearchOverlay('popstate');
            return;
          }
          
          // ✅ Handle search state updates (non-overlay navigation)
          const st = (e.state && typeof e.state === 'object' && !isOverlayState) ? e.state : URLService.readStateFromURL();
          if (st?.q !== undefined) restoreUIState(st);
        } catch (e) { console.error('popstate handler failed', e); }
      };
      DOMService.on(window, 'popstate', Handlers.popstate);

      // NOTE: removed global document click handler that hid suggestions outside overlay.
      // Suggestion list lifecycle is now tied to overlay only.
      State._handlersAttached = true;
    } catch (e) { console.error('initializeSearchEngine failed', e); }
  }

  function restoreUIState(st) {
    try {
      State.suppressHistoryPush = true;
      const input = DOMService.get(CONFIG.DOM.searchInputId);
      if (input) input.value = st.q || '';
      State.selectedType = st.type || 'all';
      State.selectedCategory = st.category || 'all';
      FilterService.setupTypeFilter(State.selectedType);
      SearchService.doSearch(null, true);
    } finally { State.suppressHistoryPush = false; }
  }

  // -------------------------
  // Teardown / destroy function for stability
  // -------------------------
  function destroy() {
    try {
      // Close overlay, disconnect observers and clear timeouts
      OverlayService.closeSearchOverlay && OverlayService.closeSearchOverlay('manual');

      // Remove registered DOM handlers
      try {
        if (Handlers.resize) DOMService.off(window, 'resize', Handlers.resize);
        if (Handlers.popstate) DOMService.off(window, 'popstate', Handlers.popstate);
        if (Handlers.documentClick) DOMService.off(document, 'click', Handlers.documentClick);
        if (Handlers.formSubmit) DOMService.off(DOMService.get(CONFIG.DOM.searchFormId), 'submit', Handlers.formSubmit);
        if (Handlers.copyClick) DOMService.off(DOMService.get(CONFIG.DOM.searchResultsId), 'click', Handlers.copyClick);
        // input handlers
        const input = DOMService.get(CONFIG.DOM.searchInputId);
        if (input) {
          if (Handlers.inputInput) input.removeEventListener('input', Handlers.inputInput);
          if (Handlers.inputKeydown) input.removeEventListener('keydown', Handlers.inputKeydown);
          if (Handlers.inputBlur) input.removeEventListener('blur', Handlers.inputBlur);
          if (Handlers.inputFocus) input.removeEventListener('focus', Handlers.inputFocus);
          if (Handlers.inputClick) input.removeEventListener('click', Handlers.inputClick);
        }
        // suggestion handlers
        const sugg = DOMService.get(CONFIG.DOM.suggestionContainerId);
        if (sugg) {
          if (Handlers.suggestionKeydown) sugg.removeEventListener('keydown', Handlers.suggestionKeydown);
          if (Handlers.suggestionClick) sugg.removeEventListener('click', Handlers.suggestionClick);
        }
        // overlay backdrop
        const backdrop = DOMService.get(CONFIG.DOM.overlayBackdropId);
        if (backdrop && Handlers.overlayBackdropClick) backdrop.removeEventListener('click', Handlers.overlayBackdropClick);
        if (Handlers.documentKeydownOverlay) DOMService.off(document, 'keydown', Handlers.documentKeydownOverlay);
      } catch (e) {}

      // Disconnect render observer
      try { if (State.renderObserver) { State.renderObserver.disconnect(); State.renderObserver = null; } } catch (e) {}

      // clear timeouts/intervals
      State._timeouts.forEach(t => { try { clearTimeout(t); clearInterval(t); } catch (e) {} });
      State._timeouts.clear();

      // remove generated DOM
      try {
        DOMService.remove(DOMService.get(CONFIG.DOM.suggestionContainerId));
        DOMService.remove(DOMService.get(CONFIG.DOM.suggestionBackdropId));
        DOMService.remove(DOMService.get(CONFIG.DOM.overlayBackdropId));
        DOMService.remove(DOMService.get(CONFIG.DOM.overlayContainerId));
        DOMService.remove(DOMService.get(CONFIG.DOM.sentinelId));
      } catch (e) {}

      // reset state
      State.apiData = null;
      State.allKeywordsCache = [];
      State.currentResults = [];
      State.currentFilteredResults = [];
      State.lastCommittedSearchState = null;
      State._handlersAttached = false;

      // prevent double destroy
      if (window.__searchUI) window.__searchUI._initialized = false;
    } catch (e) { console.error('destroy failed', e); }
  }

  // Expose API and initialize
  window.__searchUI = window.__searchUI || {};
  Object.assign(window.__searchUI, {
    init: initializeSearchEngine,
    destroy,
    getConfig: () => CONFIG,
    getState: () => State,
    getServices: () => ({
      Language: LanguageService,
      DOM: DOMService,
      String: StringService,
      Storage: StorageService,
      URL: URLService,
      Notification: NotificationService,
      Rendering: RenderingService,
      Filter: FilterService,
      Suggestion: SuggestionService,
      ReadyMode: ReadyModeService,
      Highlight: HighlightService,
      Overlay: OverlayService,
      Search: SearchService,
      UI: UIService,
      Keyboard: KeyboardService
    }),
    getLastCommittedSearchState: () => State.lastCommittedSearchState,
    getSessionHistory: () => StorageService.getHistory(),
    querySuggestions: (q) => (window.SearchEngine && typeof window.SearchEngine.querySuggestions === 'function') ? window.SearchEngine.querySuggestions(q, CONFIG.RENDER.suggestionMax) : [],
    isKeyboardOpen: () => KeyboardService.isKeyboardOpen()
  });

  window.__searchUI._initialized = true;

  // initialize immediately
  initializeSearchEngine();

  // auto-destroy on unload to minimize leaks
  try {
    window.addEventListener('beforeunload', function cleanupBeforeUnload() {
      try { destroy(); } catch (e) {}
    }, { passive: true });
  } catch (e) {}

})();