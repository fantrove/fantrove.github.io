/* search-ui.min.js
   UI layer that depends on window.SearchEngine (the core engine above).
   Contains DOM wiring, overlay/history behavior, rendering, copy-to-clipboard flash, etc.
   This file recreates the original UX but calls SearchEngine.querySuggestions/search for processing.
*/
(function(){
  // minimal i18n texts (kept as in original, trimmed)
  const LANG_TEXTS = {
    th: { all_types: "ทุกประเภท", all_categories: "ทุกหมวดหมู่", not_found: "ไม่พบข้อมูลที่ตรงหรือใกล้เคียง", copy: "คัดลอก", suggestion_label: "คำแนะนำ", suggestions_for_you: "คำแนะนำสำหรับคุณ", emoji: "Emoji", type: "ประเภท", category: "หมวดหมู่", search_placeholder: "ค้นหาข้อมูล...", search_result_here: "ผลลัพธ์การค้นหาจะแสดงที่นี่", copy_failed: "คัดลอกไม่สำเร็จ" },
    en: { all_types: "All Types", all_categories: "All Categories", not_found: "No data found related to your keyword.", copy: "Copy", suggestion_label: "Suggestions", suggestions_for_you: "Suggestions For You", emoji: "Emoji", type: "Type", category: "Category", search_placeholder: "Search...", search_result_here: "Search results will appear here", copy_failed: "Copy failed" }
  };
  const getLang = () => localStorage.getItem('selectedLang') || (navigator.language && navigator.language.startsWith('th') ? 'th' : 'en');
  const t = k => { const l = getLang(); return (LANG_TEXTS[l] && LANG_TEXTS[l][k]) || LANG_TEXTS.en[k] || k; };

  // DOM ids (kept same as original to minimize HTML change)
  const suggestionContainerId = 'searchSuggestions';
  const suggestionBackdropId = 'searchSuggestionBackdrop';
  const overlayBackdropId = 'searchOverlayBackdrop';
  const overlayContainerId = 'searchOverlayContainer';
  const sentinelId = 'search-render-sentinel';
  const SEARCH_HISTORY_KEY = 'searchHistory_v1';

  // state
  let apiData = null;
  let allKeywordsCache = [];
  let currentResults = [];
  let selectedType = 'all';
  let selectedCategory = 'all';
  let debounceTimeout = null;
  let renderObserver = null;
  let renderBatchSize = 12;
  let currentRenderIndex = 0;
  let currentFilteredResults = [];
  let overlayOpen = false;
  let originalInputParent = null;
  let originalInputNextSibling = null;
  let preOverlayState = null;
  let overlayHistoryPushed = false;
  let lastCommittedState = null;
  let suppressHistoryPush = false;
  let ignoreNextHideSuggestions = false;
  const suggestionMax = 8;

  // ---------- small helpers ----------
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function setBodyMarginForSearch(active) { document.body.style.marginBottom = active ? "60px" : ""; }

  // ---------- rendering results ----------
  function renderResultItemHTML(res, lang) {
    let itemNames = [];
    if (res.item && res.item.name) itemNames.push(res.item.name[lang] || res.item.name['en'] || '');
    for (const k in (res.item||{})) if (/_name$/.test(k) && res.item[k]) itemNames.push(res.item[k][lang] || res.item[k]['en'] || '');
    itemNames = itemNames.filter(Boolean).join(' / ');
    let typeDisplay = (res.typeObj && (res.typeObj.name && (res.typeObj.name[lang] || res.typeObj.name['en']))) || t('emoji');
    const catDisplay = (res.category && (res.category.name && (res.category.name[lang] || res.category.name['en']))) || '';
    const text = res.item && res.item.text ? res.item.text : '-';
    const api = res.item && res.item.api ? res.item.api : '';
    const copyTextVal = encodeURIComponent(res.item && res.item.text ? res.item.text : (res.itemName || api || ''));
    return `<div class="result-item">
      <div class="result-content-area">
        <div class="result-text-area">
          <span class="result-text">${escapeHtml(text)}</span>
          ${api ? `<span class="result-api">${escapeHtml(api)}</span>` : ''}
        </div>
        <div class="result-names">${escapeHtml(itemNames)}</div>
        <div class="result-meta">
          <span class="result-meta-label">${t('type')}:</span><span class="result-meta-value">${escapeHtml(typeDisplay)}</span>
          <span class="result-meta-label" style="margin-left:8px">${t('category')}:</span><span class="result-meta-value">${escapeHtml(catDisplay)}</span>
        </div>
        <button class="result-copy-btn" data-text="${copyTextVal}" aria-label="${t('copy')}">${t('copy')}</button>
      </div>
    </div>`;
  }

  function disconnectRenderObserver() {
    if (renderObserver) { try{ renderObserver.disconnect(); }catch(e){} renderObserver = null; }
    const old = document.getElementById(sentinelId);
    if (old && old.parentNode) old.parentNode.removeChild(old);
  }

  function renderNextBatch() {
    const container = document.getElementById('searchResults');
    if (!container) return;
    const lang = getLang();
    const start = currentRenderIndex;
    const end = Math.min(currentRenderIndex + renderBatchSize, currentFilteredResults.length);
    let fragment = '';
    for (let i=start;i<end;i++) fragment += renderResultItemHTML(currentFilteredResults[i], lang);
    const sentinelEl = document.getElementById(sentinelId);
    if (sentinelEl) sentinelEl.insertAdjacentHTML('beforebegin', fragment);
    else container.insertAdjacentHTML('beforeend', fragment);
    currentRenderIndex = end;
    if (currentRenderIndex >= currentFilteredResults.length) disconnectRenderObserver();
    else {
      if (!document.getElementById(sentinelId)) {
        const s = document.createElement('div'); s.id = sentinelId; s.className='search-sentinel'; s.style.cssText='width:100%;height:36px;display:block;';
        container.appendChild(s);
      }
      if (!renderObserver) {
        renderObserver = new IntersectionObserver((entries)=>{
          for (let i=0;i<entries.length;i++) if (entries[i].isIntersecting) setTimeout(()=>{ if (currentRenderIndex < currentFilteredResults.length) renderNextBatch(); }, 50);
        }, { root:null, rootMargin:'0px', threshold:0.1 });
        const sEl = document.getElementById(sentinelId);
        if (sEl) renderObserver.observe(sEl);
      }
    }
  }

  function extractResultCategories(results) {
    const lang = getLang();
    let categories = [], seen = Object.create(null);
    for (let i=0;i<results.length;i++) {
      const cat = results[i].category || { name: '' }, key = (cat.name && (cat.name[lang] || cat.name['en'])) || '';
      const displayName = key;
      if (!seen[key]) { seen[key]=1; categories.push({ key, displayName }); }
    }
    return categories;
  }

  function setupTypeFilter(selected='all') {
    const typeFilter = document.getElementById('typeFilter');
    if (!typeFilter) return;
    let buf = [`<option value="all">${t('all_types')}</option>`];
    if (apiData && Array.isArray(apiData.type)) {
      const lang = getLang();
      for (let i=0;i<apiData.type.length;i++) {
        let label = apiData.type[i].name && (apiData.type[i].name[lang] || apiData.type[i].name['en']) || '';
        buf.push(`<option value="${escapeHtml(label)}">${escapeHtml(label)}</option>`);
      }
    }
    typeFilter.innerHTML = buf.join('');
    typeFilter.value = selected;
  }
  function setupCategoryFilter(categories, selected='all') {
    const catFilter = document.getElementById('categoryFilter');
    if (!catFilter) return;
    let buf = [`<option value="all">${t('all_categories')}</option>`];
    for (let i=0;i<categories.length;i++){
      const { key, displayName } = categories[i];
      buf.push(`<option value="${escapeHtml(key)}">${escapeHtml(displayName)}</option>`);
    }
    catFilter.innerHTML = buf.join('');
    catFilter.style.display = '';
    catFilter.value = selected;
  }

  function showCopyToast(msg) {
    const toast = document.createElement('div');
    toast.className = 'copy-toast-message';
    toast.textContent = msg;
    const area = document.getElementById('copyToast') || document.body;
    area.appendChild(toast);
    setTimeout(()=>{ toast.style.opacity='0'; toast.style.transform='translateY(-10px)'; setTimeout(()=>toast.remove(),250); }, 1400);
  }
  async function copyText(text) {
    try { await navigator.clipboard.writeText(text); showCopyToast(t('copy') + ' แล้ว'); } catch { showCopyToast(t('copy_failed')); }
  }

  // ---------- suggestion container helpers ----------
  function ensureSuggestionContainer() {
    let c = document.getElementById(suggestionContainerId);
    const overlay = document.getElementById(overlayContainerId);
    if (!overlay) return null;
    if (!c) {
      c = document.createElement('div');
      c.id = suggestionContainerId;
      c.className = 'search-suggestions';
      c.style.cssText = 'position:relative; z-index:10001; max-height:320px; overflow:auto; background:#fff; border:1px solid #e6e9ee; box-shadow:0 8px 30px rgba(19,23,40,0.12); border-radius:10px; margin-top:10px; width:100%;';
      overlay.appendChild(c);
      c.addEventListener('keydown', function(ev) {
        const items = Array.from(c.querySelectorAll('.suggestion-item'));
        if (!items.length) return;
        const active = document.activeElement;
        const idx = items.indexOf(active);
        if (ev.key === 'ArrowDown') { ev.preventDefault(); const next = (idx === -1) ? items[0] : items[Math.min(items.length-1, idx+1)]; next && next.focus && next.focus(); }
        else if (ev.key === 'ArrowUp') { ev.preventDefault(); const prev = (idx === -1) ? items[items.length-1] : items[Math.max(0, idx-1)]; prev && prev.focus && prev.focus(); }
        else if (ev.key === 'Enter') { ev.preventDefault(); if (active && active.classList && active.classList.contains('suggestion-item')) active.click && active.click(); }
        else if (ev.key === 'Escape') { ev.preventDefault(); hideSuggestions(); }
      });
      c.addEventListener('click', function(ev) {
        const it = ev.target.closest('.suggestion-item');
        if (!it) return;
        ev && ev.stopPropagation && ev.stopPropagation();
        ev && ev.preventDefault && ev.preventDefault();
        let val = it.getAttribute('data-val') || '';
        try { val = decodeURIComponent(val); } catch (e) {}
        const inputEl = document.getElementById('searchInput');
        if (inputEl) inputEl.value = val;
        hideSuggestions();
        doSearch(null, false);
      });
    }
    return c;
  }
  function createSuggestionBackdrop() {
    const overlay = document.getElementById(overlayContainerId);
    if (!overlay) return null;
    let bd = document.getElementById(suggestionBackdropId);
    if (bd) return bd;
    bd = document.createElement('div');
    bd.id = suggestionBackdropId;
    bd.style.cssText = 'position:absolute;left:0;top:0;right:0;bottom:0;z-index:10000;background:transparent;pointer-events:auto;';
    bd.addEventListener('pointerdown', function(ev) {
      const sugg = document.getElementById(suggestionContainerId);
      if (sugg && sugg.contains(ev.target)) return;
      ignoreNextHideSuggestions = true;
      setTimeout(()=>{ ignoreNextHideSuggestions = false; }, 300);
      handleBackdropClickAction();
    }, { passive: true });
    overlay.insertBefore(bd, overlay.firstChild);
    return bd;
  }
  function removeSuggestionBackdrop() {
    const bd = document.getElementById(suggestionBackdropId);
    if (bd && bd.parentNode) bd.parentNode.removeChild(bd);
  }
  function hideSuggestions() {
    if (ignoreNextHideSuggestions) return;
    const c = document.getElementById(suggestionContainerId);
    if (c) c.style.display = 'none';
    removeSuggestionBackdrop();
  }

  // ---------- suggestion rendering using SearchEngine ----------
  function renderQuerySuggestions(query) {
    if (!overlayOpen) openSearchOverlay();
    const container = ensureSuggestionContainer();
    if (!container) return;
    if (!query || !query.trim()) { container.innerHTML = ''; container.style.display = 'none'; removeSuggestionBackdrop(); return; }

    const suggestions = window.SearchEngine.querySuggestions(query, suggestionMax);
    if (!suggestions || !suggestions.length) { container.innerHTML = ''; container.style.display = 'none'; removeSuggestionBackdrop(); return; }

    let html = `<div class="suggestions-head" style="padding:8px 10px;font-weight:600;color:#333;">${t('suggestion_label')}</div>`;
    for (let i=0;i<suggestions.length;i++){
      const s = suggestions[i];
      html += `<div class="suggestion-item" role="option" tabindex="0" data-val="${encodeURIComponent(s.raw)}" style="padding:8px 10px;border-top:1px solid #f4f6fa;cursor:pointer;display:flex;align-items:center;gap:10px;">` +
              `<div class="suggestion-body" style="flex:1">${s.highlightedHtml || escapeHtml(s.raw)}</div>` +
              `<div class="suggestion-source" style="color:#8b95a6;font-size:12px">${escapeHtml(s.source || '')}</div>` +
              `</div>`;
    }

    container.innerHTML = html;
    container.style.display = 'block';
    createSuggestionBackdrop();
    const inputEl = document.getElementById('searchInput');
    if (inputEl) {
      inputEl.onkeydown = function(e) {
        if (e.key === 'ArrowDown') { e.preventDefault(); const first = container.querySelector('.suggestion-item'); if (first) first.focus && first.focus(); }
        else if (e.key === 'Escape') hideSuggestions();
      };
    }
  }

  // ---------- overlay/history/backdrop logic ----------
  function openSearchOverlay() {
    if (overlayOpen) return;
    const wrapper = document.querySelector('.search-input-wrapper');
    if (!wrapper) return;
    originalInputParent = wrapper.parentNode;
    originalInputNextSibling = wrapper.nextSibling;
    const inputEl = document.getElementById('searchInput');
    preOverlayState = { q: inputEl ? (inputEl.value || '') : '', type: selectedType || 'all', category: selectedCategory || 'all' };

    // backdrop
    let backdrop = document.getElementById(overlayBackdropId);
    if (!backdrop) {
      backdrop = document.createElement('div');
      backdrop.id = overlayBackdropId;
      backdrop.className = 'search-overlay-backdrop';
      backdrop.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(12,14,18,0.48);z-index:9998;backdrop-filter:blur(4px);pointer-events:auto;';
      backdrop.onclick = function(ev) {
        ignoreNextHideSuggestions = true;
        setTimeout(()=>{ ignoreNextHideSuggestions = false; }, 300);
        handleBackdropClickAction();
      };
      document.body.appendChild(backdrop);
    }
    let overlay = document.getElementById(overlayContainerId);
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = overlayContainerId;
      overlay.className = 'search-overlay search-overlay-open';
      overlay.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:24px 16px 16px;pointer-events:auto;';
      document.body.appendChild(overlay);
    } else {
      overlay.innerHTML = '';
    }

    wrapper.classList.add('overlay-elevated');
    wrapper.style.width = '100%';
    wrapper.style.maxWidth = '720px';
    wrapper.style.marginTop = '6px';
    wrapper.style.pointerEvents = 'auto';
    overlay.appendChild(wrapper);

    ensureSuggestionContainer();

    if (inputEl) setTimeout(() => { try { inputEl.focus(); inputEl.select && inputEl.select(); } catch (e) {} }, 20);

    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';

    try {
      history.pushState({ __overlay: true, __overlay_from: lastCommittedState || null }, '', window.location.href);
      overlayHistoryPushed = true;
    } catch (e) { overlayHistoryPushed = false; }

    document.addEventListener('keydown', overlayEscHandler);
    overlayOpen = true;

    const q = inputEl ? (inputEl.value || '').trim() : '';
    if (q) {
      const candidateState = { q: q, type: selectedType || 'all', category: selectedCategory || 'all' };
      const shouldPush = !isStateEqual(candidateState, lastCommittedState);
      setTimeout(()=>{ doSearch(null, !shouldPush, { keepOverlay:true }); }, 40);
    }
  }

  function overlayEscHandler(e){
    if (e.key === 'Escape') {
      if (preOverlayState) {
        const inp = document.getElementById('searchInput');
        if (inp) inp.value = preOverlayState.q || '';
        selectedType = preOverlayState.type || 'all';
        selectedCategory = preOverlayState.category || 'all';
      }
      closeSearchOverlay();
    }
  }

  function removeTransientOverlayEntry() {
    if (!overlayHistoryPushed) return;
    try {
      const stateToRestore = lastCommittedState || { q: '', type: 'all', category: 'all' };
      history.replaceState(stateToRestore, '', buildUrlForState(stateToRestore));
    } catch (e) {}
    overlayHistoryPushed = false;
  }

  function handleBackdropClickAction() {
    const inp = document.getElementById('searchInput');
    const curr = inp ? (inp.value || '') : '';
    if (!curr || !curr.trim()) {
      removeTransientOverlayEntry();
      closeSearchOverlay();
      return;
    }
    if (preOverlayState && typeof preOverlayState.q !== 'undefined' && curr === (preOverlayState.q || '')) {
      hideSuggestions();
      doSearch(null, true);
      try { inp && inp.blur(); } catch (e) {}
      closeSearchOverlay();
      return;
    }
    hideSuggestions();
    doSearch(null, false);
    try { inp && inp.blur(); } catch (e) {}
  }

  function closeSearchOverlay() {
    if (!overlayOpen) return;
    removeTransientOverlayEntry();
    const wrapper = document.querySelector('.search-input-wrapper');
    if (!wrapper) return;
    wrapper.classList.remove('overlay-elevated');
    wrapper.style.width = '';
    wrapper.style.maxWidth = '';
    wrapper.style.marginTop = '';
    wrapper.style.pointerEvents = '';
    if (originalInputParent) {
      if (originalInputNextSibling) originalInputParent.insertBefore(wrapper, originalInputNextSibling);
      else originalInputParent.appendChild(wrapper);
    }
    const sc = document.getElementById(suggestionContainerId);
    if (sc && sc.parentNode) sc.parentNode.removeChild(sc);
    removeSuggestionBackdrop();
    const overlay = document.getElementById(overlayContainerId);
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
    const backdrop = document.getElementById(overlayBackdropId);
    if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);
    document.documentElement.style.overflow = '';
    document.body.style.overflow = '';
    document.removeEventListener('keydown', overlayEscHandler);
    overlayOpen = false;
  }

  // ---------- URL/state helpers ----------
  function parseQueryString(qs) {
    const out = {};
    if (!qs) return out;
    qs = qs.replace(/^\?/, '');
    const parts = qs.split('&');
    for (let i=0;i<parts.length;i++) {
      const p = parts[i]; if (!p) continue;
      const idx = p.indexOf('=');
      if (idx === -1) { out[decodeURIComponent(p)] = ''; }
      else { out[decodeURIComponent(p.substring(0,idx))] = decodeURIComponent(p.substring(idx+1)); }
    }
    return out;
  }
  function buildQueryString(obj) {
    const parts = [];
    for (const k in obj) {
      if (obj[k] === undefined || obj[k] === null) continue;
      parts.push(encodeURIComponent(k)+'='+encodeURIComponent(obj[k]));
    }
    return parts.length ? ('?'+parts.join('&')) : '';
  }
  function readStateFromURL() {
    const params = parseQueryString(window.location.search || '');
    return { q: params.q || '', type: params.type || 'all', category: params.category || 'all' };
  }
  function buildUrlForState(state) {
    const params = {};
    if (state.q) params.q = state.q;
    if (state.type && state.type !== 'all') params.type = state.type;
    if (state.category && state.category !== 'all') params.category = state.category;
    return buildQueryString(params);
  }
  function isStateEqual(a,b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    const aq = (a.q||'').trim();
    const bq = (b.q||'').trim();
    const at = (a.type||'all');
    const bt = (b.type||'all');
    const ac = (a.category||'all');
    const bc = (b.category||'all');
    return aq===bq && at===bt && ac===bc;
  }

  function commitSearchState(state) {
    try {
      if (isStateEqual(state, lastCommittedState)) return;
    } catch (e) {}
    const url = buildUrlForState(state);
    try {
      if (overlayHistoryPushed) {
        history.replaceState(state, '', url);
        overlayHistoryPushed = false;
      } else {
        history.pushState(state, '', url);
      }
    } catch (e) {
      try { history.replaceState(state, '', url); } catch (ee) {}
      overlayHistoryPushed = false;
    }
    try {
      const raw = sessionStorage.getItem(SEARCH_HISTORY_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      arr.push(Object.assign({}, state, { ts: Date.now() }));
      sessionStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(arr));
    } catch (e) {}
    lastCommittedState = { q: state.q || '', type: state.type || 'all', category: state.category || 'all' };
  }

  // ---------- main search & render flow ----------
  function renderResults(results, showSuggestionsIfNoResult=false) {
    const container = document.getElementById('searchResults');
    const lang = getLang();
    if (!container) return;
    let filtered = (selectedCategory !== 'all') ? results.filter(res => ((res.category && (res.category.name && (res.category.name[lang] || res.category.name['en']))) || '') === selectedCategory) : results.slice();
    setBodyMarginForSearch(true);
    disconnectRenderObserver();
    currentFilteredResults = [];
    currentRenderIndex = 0;
    if (!filtered.length) {
      let html = `<div class="no-result">${t('not_found')}</div>`;
      if (showSuggestionsIfNoResult) {
        html += `<div class="suggestions-title-main">${t('suggestions_for_you')}</div>`;
        // fallback: show a few random items from DB if available
        const sample = (apiData && Array.isArray(apiData.type) && apiData.type.length && apiData.type[0].category && apiData.type[0].category[0] && apiData.type[0].category[0].data) ? apiData.type[0].category[0].data.slice(0,4) : [];
        html += `<div class="suggestions-block-list">${sample.map(it=>`<div class="result-item"><div class="result-content-area"><div class="result-text-area"><span class="result-text">${escapeHtml(it.text||'-')}</span></div></div></div>`).join('')}</div>`;
      }
      container.innerHTML = html;
      const catFilterEl = document.getElementById('categoryFilter');
      if (catFilterEl) catFilterEl.style.display = '';
      updateUILanguage();
      return;
    }
    currentFilteredResults = filtered;
    currentRenderIndex = 0;
    container.innerHTML = '';
    renderNextBatch();
    if (!window._copyResultTextHandlerSet) {
      container.addEventListener('click', function(e){
        const btn = e.target.closest('.result-copy-btn');
        if (btn && btn.hasAttribute('data-text')) { e.preventDefault(); copyText(decodeURIComponent(btn.getAttribute('data-text'))); }
      });
      window._copyResultTextHandlerSet = true;
    }
    updateUILanguage();
  }

  function doSearch(e, preventPush, options) {
    if (e) e.preventDefault();
    options = options || {};
    const qEl = document.getElementById('searchInput');
    const q = qEl ? qEl.value : '';
    const typeFilterEl = document.getElementById('typeFilter');
    selectedType = typeFilterEl ? typeFilterEl.value : selectedType;
    selectedCategory = 'all';
    hideSuggestions();

    if (!q.trim()) {
      setBodyMarginForSearch(false);
      const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
      const sr = document.getElementById('searchResults');
      if (sr) sr.innerHTML = placeholderHtml;
      setupCategoryFilter([], 'all');
      updateUILanguage();
      const stateCleared = { q: '', type: 'all', category: 'all' };
      if (!preventPush && !suppressHistoryPush && !isStateEqual(stateCleared, lastCommittedState)) commitSearchState(stateCleared);
      if (overlayOpen && !options.keepOverlay) closeSearchOverlay();
      return;
    }

    const out = window.SearchEngine.search(q, selectedType);
    currentResults = out.results || [];
    allKeywordsCache = out.keywords || [];
    const filterCategories = extractResultCategories(currentResults);
    setupCategoryFilter(filterCategories, 'all');

    const stateObj = { q: q, type: selectedType || 'all', category: 'all' };
    const willCommit = (!preventPush && !suppressHistoryPush && !isStateEqual(stateObj, lastCommittedState));
    if (willCommit) commitSearchState(stateObj);

    renderResults(currentResults, currentResults.length === 0);
    if (overlayOpen && !options.keepOverlay) closeSearchOverlay();
  }

  // ---------- wiring input/form and keyboard ----------
  function setupAutoSearchInput() {
    const input = document.getElementById('searchInput');
    if (!input) return;
    input.setAttribute('enterkeyhint','search');
    input.oninput = function(){ clearTimeout(debounceTimeout); debounceTimeout = setTimeout(()=>{ renderQuerySuggestions(this.value); }, 120); };
    input.onkeydown = function(e){
      if (e.key === 'Enter') { e.preventDefault(); hideSuggestions(); doSearch(); closeMobileKeyboard(); }
      else if (e.key === 'ArrowDown') { const container = document.getElementById(suggestionContainerId); if (container) { const first = container.querySelector('.suggestion-item'); if (first) first.focus && first.focus(); } }
    };
    input.addEventListener('blur', function(){ if (ignoreNextHideSuggestions) return; setTimeout(hideSuggestions, 200); });
    input.addEventListener('focus', function(){ openSearchOverlay(); });
    input.addEventListener('click', function(){ openSearchOverlay(); });
  }
  function setupMobileSelectEnter() {
    ['typeFilter','categoryFilter'].forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      el.onchange = () => (id==='typeFilter' ? onTypeChange() : onCategoryChange());
      el.onkeyup = function(e){ if (e.key === 'Enter') (id==='typeFilter' ? onTypeChange() : onCategoryChange()); };
    });
  }
  function onTypeChange(){ selectedType = document.getElementById('typeFilter').value; doSearch(); }
  function onCategoryChange(){ selectedCategory = document.getElementById('categoryFilter').value; renderResults(currentResults,false); updateUILanguage(); }
  function closeMobileKeyboard(){ const input = document.getElementById('searchInput'); if (input && document.activeElement === input) input.blur(); }
  function updateUILanguage() {
    const input = document.getElementById('searchInput');
    if (input && input.placeholder !== t('search_placeholder')) input.placeholder = t('search_placeholder');
    const filterGroupLabels = document.querySelectorAll('.search-filters-panel .filter-group-label');
    if (filterGroupLabels.length>0 && filterGroupLabels[0].textContent !== t('type')) filterGroupLabels[0].textContent = t('type');
    if (filterGroupLabels.length>1 && filterGroupLabels[1].textContent !== t('category')) filterGroupLabels[1].textContent = t('category');
  }

  // ---------- popstate and document-level handlers ----------
  window.addEventListener('popstate', function(e){
    const state = e.state || {};
    if (overlayOpen && !state.__overlay) {
      if (preOverlayState) {
        const inp = document.getElementById('searchInput');
        if (inp) inp.value = preOverlayState.q || '';
        selectedType = preOverlayState.type || 'all';
        selectedCategory = preOverlayState.category || 'all';
      }
      const wrapper = document.querySelector('.search-input-wrapper');
      if (wrapper && originalInputParent) {
        wrapper.classList.remove('overlay-elevated');
        wrapper.style.width = ''; wrapper.style.maxWidth=''; wrapper.style.marginTop='';
        if (originalInputNextSibling) originalInputParent.insertBefore(wrapper, originalInputNextSibling);
        else originalInputParent.appendChild(wrapper);
      }
      const sc = document.getElementById(suggestionContainerId);
      if (sc && sc.parentNode) sc.parentNode.removeChild(sc);
      removeSuggestionBackdrop();
      const overlay = document.getElementById(overlayContainerId);
      if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
      const backdrop = document.getElementById(overlayBackdropId);
      if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);
      document.documentElement.style.overflow=''; document.body.style.overflow='';
      document.removeEventListener('keydown', overlayEscHandler);
      overlayOpen = false; overlayHistoryPushed = false; preOverlayState = null;
      return;
    }
    const st = (e.state && typeof e.state === 'object') ? e.state : readStateFromURL();
    if (st && st.q !== undefined) restoreUIState(st);
  });

  document.addEventListener('click', function(ev) {
    const container = document.getElementById(suggestionContainerId);
    const input = document.getElementById('searchInput');
    if (!container) return;
    if (overlayOpen) return;
    if (ev.target === input || container.contains(ev.target)) return;
    hideSuggestions();
  }, false);

  document.addEventListener('pointerdown', function(ev) {
    if (!overlayOpen) return;
    if (ev.target.closest('#' + overlayContainerId)) return;
    ignoreNextHideSuggestions = true;
    setTimeout(()=>{ ignoreNextHideSuggestions = false; }, 300);
    handleBackdropClickAction();
  }, true);

  // ---------- history / restore ----------
  function restoreUIState(st) {
    try {
      suppressHistoryPush = true;
      const input = document.getElementById('searchInput');
      if (input) input.value = st.q || '';
      selectedType = st.type || 'all';
      selectedCategory = st.category || 'all';
      setupTypeFilter(selectedType);
      doSearch(null, true);
    } finally {
      suppressHistoryPush = false;
    }
  }

  // ---------- init: load DB then wire UI ----------
  function init() {
    fetch('/assets/db/db.min.json').then(res=>res.json()).then(data=>{
      apiData = data;
      window.SearchEngine.init(apiData);
      allKeywordsCache = window.SearchEngine.generateAllKeywords();
      setupTypeFilter('all');
      setupMobileSelectEnter();
      setupAutoSearchInput();
      setupCategoryFilter([], 'all');
      setBodyMarginForSearch(false);
      const placeholderHtml = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
      const sr = document.getElementById('searchResults');
      if (sr) sr.innerHTML = placeholderHtml;
      updateUILanguage();

      // restore lastCommittedState
      try {
        const hs = window.history && window.history.state;
        if (hs && typeof hs === 'object' && (hs.q !== undefined)) {
          lastCommittedState = { q: hs.q || '', type: hs.type || 'all', category: hs.category || 'all' };
        } else {
          const raw = sessionStorage.getItem(SEARCH_HISTORY_KEY);
          const arr = raw ? JSON.parse(raw) : [];
          if (arr && arr.length) {
            const last = arr[arr.length - 1];
            lastCommittedState = { q: last.q || '', type: last.type || 'all', category: last.category || 'all' };
          } else lastCommittedState = null;
        }
      } catch (e) { lastCommittedState = null; }

      // initial URL restore
      const initial = readStateFromURL();
      if (initial && initial.q) {
        try {
          suppressHistoryPush = true;
          const input = document.getElementById('searchInput');
          if (input) input.value = initial.q;
          selectedType = initial.type || 'all';
          selectedCategory = initial.category || 'all';
          setupTypeFilter(selectedType);
          doSearch(null, true);
          try { history.replaceState({ q: initial.q, type: selectedType, category: selectedCategory }, '', buildUrlForState(initial)); } catch (e) {}
          lastCommittedState = { q: initial.q || '', type: selectedType || 'all', category: selectedCategory || 'all' };
        } finally { suppressHistoryPush = false; }
      } else {
        try { history.replaceState({ q: '', type: 'all', category: 'all' }, '', window.location.pathname); } catch (e) {}
        lastCommittedState = { q: '', type: 'all', category: 'all' };
      }
    }).catch(err => console.error('Failed to load api database', err));

    // form wiring
    const formEl = document.getElementById('searchForm');
    if (formEl) formEl.addEventListener('submit', e => { e.preventDefault(); doSearch(); closeMobileKeyboard(); });
    const inputEl = document.getElementById('searchInput');
    if (inputEl) inputEl.addEventListener('keydown', function(e){ if (e.key === 'Enter') { e.preventDefault(); doSearch(); closeMobileKeyboard(); } });
  }

  // expose a tiny debug API (similar to original)
  window.__searchUI = {
    init: init,
    getLastCommittedState: () => lastCommittedState,
    getSessionHistory: () => { try { return JSON.parse(sessionStorage.getItem(SEARCH_HISTORY_KEY) || '[]'); } catch(e){return[];} },
    querySuggestions: (q) => window.SearchEngine.querySuggestions(q, suggestionMax)
  };

  // start
  init();

})();