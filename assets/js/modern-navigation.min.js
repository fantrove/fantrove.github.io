/**
 * ModernNavigation (improved)
 * - Mobile: bottom fixed nav with hide-on-scroll behavior
 * - Tablet+Desktop: left rail inserted into layout and sticky (locked) at top
 * - Robust event handling, debounce, CSS var sync, safe mount/unmount
 * - Preserves labels, active state, go_url, language support
 */
class ModernNavigation {
  constructor(config = {}) {
    this.cssPath = config.cssPath || '/assets/css/modern-styles.min.css';
    this.configPath = config.configPath || '/assets/json/buttons.min.json';
    this.activeClass = config.activeClass || 'active-1';
    this.navItemSelector = config.navItemSelector || '.nav-item';
    this.defaultButtonClass = config.defaultButtonClass || 'default-button';

    // left rail sizes (strings with units)
    this.leftRailWidth = config.leftRailWidth || '88px';
    this.leftRailCollapsedWidth = config.leftRailCollapsedWidth || '72px';

    this.defaultLang = 'en';
    this.currentLang = localStorage.getItem('selectedLang') || this.defaultLang;

    this._initialized = false;
    this._config = null;
    this._navEl = null;

    // state
    this._isTouching = false;
    this._navVisible = true;
    this._lastScrollY = window.scrollY;
    this._rafId = null;
    this.SHOW_THRESHOLD = 40;

    // saved original localStorage.setItem for restoration
    this._originalSetItem = localStorage.setItem.bind(localStorage);

    // bound handlers to enable removal and avoid duplicates
    this._resizeHandler = this._debounce(this._applyScreenBehavior.bind(this), 120);
    this._orientationHandler = this._applyScreenBehavior.bind(this);
    this._scrollHandler = this._onScrollForActiveState.bind(this);
    this._storageHandler = this._onStorageEvent.bind(this);
    this._onUltraScrollNavBound = this._onUltraScrollNav.bind(this);
    this._onTouchStartBound = this._onTouchStart.bind(this);
    this._onTouchEndBound = this._onTouchEnd.bind(this);
  }

  /* public init */
  async init() {
    if (this._initialized) return;
    try {
      ModernNavigation._preconnect(this.configPath);
      await this._loadCSS();
      this._config = await this._fetchConfig();
      const fragment = this._createNavigationItemsFragment();
      this._injectNavigation(fragment);
      this._navEl = document.querySelector('.bottom-nav');
      if (!this._navEl) throw new Error('navigation element not created');

      // initial GPU hint
      this._navEl.style.willChange = 'transform';

      this._bindBaseListeners();
      this._updateActiveState(); // initial active
      this._applyScreenBehavior(); // mount/unmount according to screen
      this._initialized = true;
    } catch (err) {
      this._cleanup();
      console.error('ModernNavigation init error:', err);
      throw err;
    }
  }

  /* --- static helpers --- */
  static _preconnect(configPath){
    try {
      const url = new URL(configPath, location.origin);
      if (!document.querySelector(`link[rel="preconnect"][href="${url.origin}"]`)){
        const l = document.createElement('link');
        l.rel = 'preconnect';
        l.href = url.origin;
        document.head.appendChild(l);
      }
    } catch (_){}
  }

  /* --- CSS / config loading --- */
  async _loadCSS(){
    if (document.querySelector(`link[href="${this.cssPath}"]`)) return;
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = this.cssPath;
    document.head.appendChild(link);
    await new Promise(resolve => { link.onload = resolve; link.onerror = resolve; });
  }

  async _fetchConfig(){
    try {
      const res = await fetch(this.configPath, { cache: 'no-store', credentials: 'same-origin' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      // fallback to empty navigation
      return { navigation: [] };
    }
  }

  /* --- build nav DOM --- */
  _createNavigationItemsFragment(){
    const fragment = document.createDocumentFragment();
    const config = this._config?.navigation || [];
    const lang = this.currentLang || this.defaultLang;
    for (let i = 0; i < config.length; i++){
      const item = config[i];
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = `nav-item ${item.customClass || this.defaultButtonClass}`;
      if (item.url) btn.dataset.link = item.url;
      if (item.go_url) btn.dataset.goUrl = item.go_url;
      if (item.icon){
        const tmp = document.createElement('span');
        tmp.innerHTML = item.icon;
        while (tmp.firstChild) btn.appendChild(tmp.firstChild);
      }
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = item[`${lang}_label`] || item.en_label || 'Missing Label';
      btn.appendChild(label);
      fragment.appendChild(btn);
    }
    return fragment;
  }

  _injectNavigation(fragment){
    if (document.querySelector('.bottom-nav')) return;
    const nav = document.createElement('div');
    nav.className = 'bottom-nav';
    nav.appendChild(fragment);
    // Insert as first child for deterministic mounting
    document.body.insertBefore(nav, document.body.firstChild);
  }

  /* --- listeners / lifecycle --- */
  _bindBaseListeners(){
    if (!this._navEl) return;
    // click delegated to nav element
    this._navEl.addEventListener('click', e => this._onNavClick(e), { passive: true });

    // active state ref updates on scroll (rAF)
    window.addEventListener('scroll', this._scrollHandler, { passive: true });

    // storage listener for language changes
    window.addEventListener('storage', this._storageHandler);
    // override localStorage.setItem to catch same-window changes
    const self = this;
    localStorage.setItem = function(key, value){
      self._originalSetItem(key, value);
      if (key === 'selectedLang') self._onSelectedLangChange(value);
    };
    // languageChange custom event also supported by _updateLabels
    window.addEventListener('languageChange', (e) => {
      if (e?.detail?.language) this._updateLabels(e.detail.language);
    });
  }

  _unbindBaseListeners(){
    if (!this._navEl) return;
    // (click listener was anonymous closure to preserve passive:true) - nothing to remove here safely
    window.removeEventListener('scroll', this._scrollHandler, { passive: true });
    window.removeEventListener('storage', this._storageHandler, { passive: true });
    window.removeEventListener('languageChange', () => {}); // no-op - we left a named add above that used inline handler, safe to keep
    // restore localStorage.setItem
    try { localStorage.setItem = this._originalSetItem; } catch(e) {}
  }

  /* --- click handling --- */
  _onNavClick(event){
    const item = event.target.closest(this.navItemSelector);
    if (!item) return;
    if (event.type !== 'click' || event.button !== 0) return;
    const targetLink = item.dataset.link;
    const goLink = item.dataset.goUrl;
    const destination = goLink || targetLink;
    if (!destination) return;
    // if already active, no-op
    if (item.classList.contains(this.activeClass)) return;
    // simple nav assignment (preserve legacy behavior)
    if (window.location.pathname.endsWith(targetLink)) return;
    window.location.assign(destination);
  }

  /* --- active state updates (rAF-friendly) --- */
  _onScrollForActiveState(){
    if (this._rafId == null){
      this._rafId = window.requestAnimationFrame(() => {
        this._updateActiveState();
        this._rafId = null;
      });
    }
  }

  _updateActiveState(){
    if (!this._navEl) return;
    const path = window.location.pathname;
    const items = this._navEl.querySelectorAll(this.navItemSelector);
    for (let i = 0; i < items.length; i++){
      const it = items[i];
      const navLink = it.dataset.link || '';
      if (navLink === '/' || navLink === '/index.html'){
        it.classList.toggle(this.activeClass, path === '/' || path.endsWith('/index.html'));
      } else {
        const normalized = navLink.endsWith('/') ? navLink : `${navLink}/`;
        it.classList.toggle(this.activeClass, path.startsWith(normalized));
      }
    }
  }

  /* --- language / label updates --- */
  _onSelectedLangChange(val){
    this.currentLang = val || this.defaultLang;
    this._updateLabels(this.currentLang);
  }

  _updateLabels(lang){
    if (!this._navEl || !this._config?.navigation) return;
    const items = this._navEl.querySelectorAll(this.navItemSelector);
    for (let i = 0; i < items.length; i++){
      const it = items[i];
      const link = it.dataset.link;
      const cfg = this._config.navigation.find(n => n.url === link);
      if (cfg){
        const label = it.querySelector('.label');
        if (label) label.textContent = cfg[`${lang}_label`] || cfg.en_label || 'Missing Label';
      }
    }
  }

  _onStorageEvent(e){
    if (e.key === 'selectedLang') this._onSelectedLangChange(e.newValue);
  }

  /* --- screen behavior: mount/unmount left-rail and mobile scroll sync --- */
  _isMobileScreen(){
    return window.innerWidth < 768;
  }

  _applyScreenBehavior(){
    const isMobile = this._isMobileScreen();

    // keep nav class in sync (CSS can also read it)
    if (this._navEl) this._navEl.classList.toggle('vertical', !isMobile);

    if (isMobile){
      // mobile: ensure unmounted and enable scroll sync
      this._unmountLeftRailIfMounted();
      this._enableScrollNavSync();
    } else {
      // tablet/desktop: mount left-rail and disable mobile scroll sync
      this._mountLeftRailIfNeeded();
      this._disableScrollNavSync();
    }
  }

_mountLeftRailIfNeeded() {
  if (!this._navEl) return;
  if (document.body.classList.contains('has-left-rail')) return;
  
  const nav = this._navEl;
  const siteMain = document.createElement('div');
  siteMain.className = 'site-main';
  
  // ย้าย children ทั้งหมดของ body ยกเว้น nav ไปใน site-main
  const nodes = Array.from(document.body.childNodes);
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node === nav) continue;
    siteMain.appendChild(node);
  }
  document.body.appendChild(siteMain);
  document.body.classList.add('has-left-rail');
  
  // sync CSS vars
  document.documentElement.style.setProperty('--left-rail-width', this.leftRailWidth);
  document.documentElement.style.setProperty('--left-rail-collapsed-width', this.leftRailCollapsedWidth);
  
  // ตั้งค่า nav ให้ sticky
  nav.style.position = 'sticky';
  nav.style.top = '0';
  nav.style.left = '0';
  nav.style.transform = 'none';
  nav.style.zIndex = ''; // natural stacking
  
  // ✅ ฟังก์ชันตั้งความสูง dynamic ให้เต็ม viewport จริง
  const setNavHeight = () => {
    const viewportHeight = window.innerHeight;
    nav.style.height = viewportHeight + 'px';
  };
  
  // ✅ ใช้ ResizeObserver เพื่อความแม่นยำเมื่อ viewport เปลี่ยนเพราะ UI ของ browser
  const resizeObserver = new ResizeObserver(setNavHeight);
  
  // ตั้งค่าเริ่มต้น
  setNavHeight();
  
  // อัปเดตเมื่อ resize, orientation change, หรือ viewport layout เปลี่ยน
  window.addEventListener('resize', setNavHeight);
  window.addEventListener('orientationchange', setNavHeight);
  
  // สังเกตการเปลี่ยนขนาด viewport จริง
  resizeObserver.observe(document.documentElement);
}

  _unmountLeftRailIfMounted(){
    if (!this._navEl) return;
    if (!document.body.classList.contains('has-left-rail')) return;
    const nav = this._navEl;
    const siteMain = document.querySelector('.site-main');
    if (siteMain){
      const children = Array.from(siteMain.childNodes);
      // insert before siteMain to preserve approximate order (nav is first)
      for (let i = 0; i < children.length; i++){
        document.body.insertBefore(children[i], siteMain);
      }
      // remove siteMain
      if (siteMain.parentNode) siteMain.parentNode.removeChild(siteMain);
    }
    document.body.classList.remove('has-left-rail');
    // remove CSS vars
    document.documentElement.style.removeProperty('--left-rail-width');
    document.documentElement.style.removeProperty('--left-rail-collapsed-width');

    // restore nav to mobile defaults
    nav.style.position = '';
    nav.style.top = '';
    nav.style.height = '';
    nav.style.left = '';
    nav.style.transform = '';
    nav.style.zIndex = '16000';
  }

  /* --- mobile scroll sync (hide-on-scroll) --- */
  _enableScrollNavSync(){
    if (this._navScrollSyncEnabled) return;
    // bind handlers
    window.addEventListener('scroll', this._onUltraScrollNavBound, { passive: true });
    window.addEventListener('touchstart', this._onTouchStartBound, { passive: true });
    window.addEventListener('touchend', this._onTouchEndBound, { passive: true });
    // ensure nav visible
    if (this._navEl){
      this._navEl.style.transition = 'transform 0.22s cubic-bezier(0.33,1,0.68,1)';
      this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      this._navVisible = true;
    }
    this._navScrollSyncEnabled = true;
  }

  _disableScrollNavSync(){
    if (!this._navScrollSyncEnabled) return;
    window.removeEventListener('scroll', this._onUltraScrollNavBound, { passive: true });
    window.removeEventListener('touchstart', this._onTouchStartBound, { passive: true });
    window.removeEventListener('touchend', this._onTouchEndBound, { passive: true });
    // ensure visible
    if (this._navEl){
      this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      this._navVisible = true;
    }
    this._navScrollSyncEnabled = false;
  }

  _onTouchStart(){
    this._isTouching = true;
    this._lastScrollY = window.scrollY;
  }
  _onTouchEnd(){
    this._isTouching = false;
  }

  _onUltraScrollNav(){
    if (!this._navEl) return;
    const y = window.scrollY;
    const delta = y - this._lastScrollY;
    this._lastScrollY = y;
    if (y <= this.SHOW_THRESHOLD){
      if (!this._navVisible) this._showNav();
      return;
    }
    if (this._isTouching){
      if (delta > 15 && this._navVisible) this._hideNav();
      else if (delta < -10 && !this._navVisible) this._showNav();
    }
  }

  _hideNav(){
    if (!this._navEl) return;
    this._navEl.style.transform = 'translateZ(0) translateY(100%)';
    this._navVisible = false;
  }
  _showNav(){
    if (!this._navEl) return;
    this._navEl.style.transform = 'translateZ(0) translateY(0%)';
    this._navVisible = true;
  }

  /* --- utilities --- */
  _debounce(fn, wait = 100){
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), wait);
    };
  }

  /* cleanup / destroy */
  _cleanup(){
    try {
      // remove event listeners we explicitly added
      window.removeEventListener('resize', this._resizeHandler, { passive: true });
      window.removeEventListener('orientationchange', this._orientationHandler, { passive: true });
      window.removeEventListener('scroll', this._scrollHandler, { passive: true });
      window.removeEventListener('storage', this._storageHandler, { passive: true });
      // remove mobile-sync if active
      this._disableScrollNavSync();
      // restore localStorage.setItem
      try { localStorage.setItem = this._originalSetItem; } catch(e){}
    } catch(e){
      // swallow errors during cleanup
    }
    this._initialized = false;
    this._navEl = null;
  }

  destroy(){
    this._cleanup();
  }
}

/* bootstrap */
(function(){
  const nav = new ModernNavigation({
    cssPath: '/assets/css/modern-styles.min.css',
    configPath: '/assets/json/template/template.min.json',
    defaultButtonClass: 'default-button',
    leftRailWidth: '88px',
    leftRailCollapsedWidth: '72px'
  });
  queueMicrotask(() => {
    nav.init().catch(e => console.error('ModernNavigation init failed:', e));
  });
})();