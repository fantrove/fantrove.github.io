/**
 * ModernNavigation Ultra Edition (Optimized for Smoothness & Performance)
 * - GPU Accelerated nav show/hide via will-change and translateZ(0)
 * - Minimal event binding, ultra-lightweight and ultra-smooth
 * - Adds layout-mounting logic so left-rail becomes part of page flow on tablet+desktop
 * - Improved event handling (named handlers + debounce) and CSS var synchronization
 */
class ModernNavigation {
  constructor(config = {}) {
    this.cssPath = config.cssPath || '/assets/css/modern-styles.min.css';
    this.configPath = config.configPath || '/assets/json/buttons.min.json';
    this.activeClass = config.activeClass || 'active-1';
    this.navItemSelector = config.navItemSelector || '.nav-item';
    this.defaultButtonClass = config.defaultButtonClass || 'default-button';
    this.defaultLang = 'en';
    this.currentLang = localStorage.getItem('selectedLang') || this.defaultLang;

    // left rail sizes (strings with units)
    this.leftRailWidth = config.leftRailWidth || '88px';
    this.leftRailCollapsedWidth = config.leftRailCollapsedWidth || '72px';

    this._initialized = false;
    this._config = null;
    this._navEl = null;
    this._lastScreenIsMobile = null;
    this._navScrollSyncEnabled = false;
    this._lastScrollY = window.scrollY;
    this._navVisible = true;
    this.SHOW_THRESHOLD = 40;
    this._isTouching = false;
    this._rafId = null;
    this._originalSetItem = localStorage.setItem;

    // Named handlers so we can avoid duplicate bindings and remove if needed
    this._resizeHandler = this._debounce(this._applyScrollNavBehaviorForScreen.bind(this), 120);
    this._orientationHandler = this._applyScrollNavBehaviorForScreen.bind(this);
    this._scrollHandler = this._handleScroll.bind(this);
    this._storageHandler = this._handleStorageChange.bind(this);
  }

  async init() {
    if (this._initialized) return;
    try {
      ModernNavigation._preconnect(this.configPath);
      await this._loadCSS();
      this._config = await this._fetchConfig();
      const navFragment = this._createNavigationItemsFragment();
      this._injectNavigation(navFragment);
      this._navEl = document.querySelector('.bottom-nav');
      // GPU Hint for nav
      if (this._navEl) {
        this._navEl.style.willChange = 'transform';
        this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      }
      this._setupNavigation();
      this._setupLanguageListener();
      this._setupStorageListener();
      this._updateActiveState();
      this._setupScrollSyncHideShow();
      this._initialized = true;
    } catch (error) {
      this._cleanup();
      throw error;
    }
  }

  static _preconnect(configPath) {
    try {
      const url = new URL(configPath, location.origin);
      if (!document.querySelector(`link[rel="preconnect"][href="${url.origin}"]`)) {
        const link = document.createElement('link');
        link.rel = 'preconnect';
        link.href = url.origin;
        document.head.appendChild(link);
      }
    } catch (_) {}
  }

  _injectNavigation(fragment) {
    if (document.querySelector('.bottom-nav')) return;
    const navEl = document.createElement('div');
    navEl.className = 'bottom-nav';
    navEl.appendChild(fragment);
    // Insert first so mount/unmount logic has consistent position
    document.body.insertBefore(navEl, document.body.firstChild);
  }

  _createNavigationItemsFragment() {
    const fragment = document.createDocumentFragment();
    const config = this._config?.navigation;
    if (!config) return fragment;
    const lang = this.currentLang;
    for (let i = 0, len = config.length; i < len; ++i) {
      const item = config[i];
      const btn = document.createElement('button');
      btn.className = 'nav-item ' + (item.customClass || this.defaultButtonClass);
      btn.dataset.link = item.url;
      if (item.go_url) btn.dataset.goUrl = item.go_url;
      if (item.icon) {
        const iconSpan = document.createElement('span');
        iconSpan.innerHTML = item.icon;
        while (iconSpan.firstChild) btn.appendChild(iconSpan.firstChild);
      }
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = item[`${lang}_label`] || item.en_label || 'Missing Label';
      btn.appendChild(label);
      fragment.appendChild(btn);
    }
    return fragment;
  }

  _updateLabels() {
    if (!this._navEl || !this._config?.navigation) return;
    const config = this._config.navigation;
    const lang = this.currentLang;
    const items = this._navEl.querySelectorAll(this.navItemSelector);
    for (let i = 0, l = items.length; i < l; ++i) {
      const item = items[i];
      const link = item.dataset.link;
      const cfg = config.find(nav => nav.url === link);
      if (cfg) {
        const label = item.querySelector('.label');
        if (label) label.textContent = cfg[`${lang}_label`] || cfg.en_label || 'Missing Label';
      }
    }
  }

  _updateLanguage(newLanguage) {
    if (newLanguage && newLanguage !== this.currentLang) {
      this.currentLang = newLanguage;
      this._updateLabels();
    }
  }

  _handleClick(event) {
    const item = event.target.closest(this.navItemSelector);
    if (!item) return;
    if (event.type !== "click" || event.button !== 0) return;
    const targetLink = item.dataset.link;
    const goLink = item.dataset.goUrl;
    if ((goLink || targetLink) && !item.classList.contains(this.activeClass)) {
      if (window.location.pathname.endsWith(targetLink)) return;
      window.location.assign(goLink || targetLink);
    }
  }

  _handleScroll() {
    if (this._rafId == null) {
      this._rafId = window.requestAnimationFrame(() => {
        this._updateActiveState();
        this._rafId = null;
      });
    }
  }

  _handleStorageChange(event) {
    if (event.key === 'selectedLang') {
      this._updateLanguage(event.newValue);
    }
  }

  _updateActiveState() {
    if (!this._navEl) return;
    const currentPath = window.location.pathname;
    const items = this._navEl.querySelectorAll(this.navItemSelector);
    for (let i = 0, l = items.length; i < l; ++i) {
      const item = items[i];
      const navLink = item.dataset.link;
      if (navLink === '/' || navLink === '/index.html') {
        item.classList.toggle(this.activeClass, currentPath === '/' || currentPath.endsWith('/index.html'));
      } else {
        const normalized = navLink.endsWith('/') ? navLink : navLink + '/';
        item.classList.toggle(this.activeClass, currentPath.startsWith(normalized));
      }
    }
  }

  _setupNavigation() {
    if (!this._navEl) return;
    // Use named handler for click delegation
    this._navEl.addEventListener('click', e => this._handleClick(e), { passive: true });
    window.addEventListener('scroll', this._scrollHandler, { passive: true });
  }

  _setupLanguageListener() {
    window.addEventListener('languageChange', e => {
      this.currentLang = e.detail.language;
      this._updateLabels();
    });
  }

  _setupStorageListener() {
    window.addEventListener('storage', this._storageHandler);
    localStorage.setItem = (key, value) => {
      this._originalSetItem.call(localStorage, key, value);
      if (key === 'selectedLang') {
        this._updateLanguage(value);
      }
    };
  }

  async _loadCSS() {
    if (document.querySelector(`link[href="${this.cssPath}"]`)) return;
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = this.cssPath;
    document.head.appendChild(link);
    await new Promise(resolve => { link.onload = resolve; });
  }

  async _fetchConfig() {
    try {
      const resp = await fetch(this.configPath, { cache: 'no-store', credentials: 'same-origin' });
      if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
      return await resp.json();
    } catch (e) {
      return { navigation: [] };
    }
  }

  // Debounce helper (small, dependency-free)
  _debounce(fn, wait = 100) {
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), wait);
    };
  }

  // === SMART LAYOUT MOUNT / UNMOUNT FOR LEFT RAIL (tablet+desktop) ===
  _setupScrollSyncHideShow() {
    if (!this._navEl) return;
    this._lastScrollY = window.scrollY;
    this._navVisible = true;
    this._isTouching = false;
    window.addEventListener('resize', this._resizeHandler, { passive: true });
    window.addEventListener('orientationchange', this._orientationHandler, { passive: true });
    this._applyScrollNavBehaviorForScreen();
  }

  // Mobile detection: treat screens narrower than 768px as "mobile" (bottom nav).
  _isMobileScreen() {
    return window.innerWidth < 768;
  }

  _applyScrollNavBehaviorForScreen() {
    const isMobile = this._isMobileScreen();

    // If screen mode hasn't changed, still ensure the class exists for CSS
    if (isMobile === this._lastScreenIsMobile) {
      if (this._navEl) this._navEl.classList.toggle('vertical', !isMobile);
      if (!isMobile) this._ensureMounted();
      return;
    }

    this._lastScreenIsMobile = isMobile;

    if (this._navEl) {
      this._navEl.classList.toggle('vertical', !isMobile);
      this._navEl.style.willChange = 'transform';
      this._navEl.style.transition = 'transform 0.22s cubic-bezier(0.33,1,0.68,1)';
    }

    if (isMobile) {
      // mobile: bottom nav behavior
      this._unmountVerticalLayout();
      this._enableScrollNavSync();
    } else {
      // tablet+desktop: left-rail as part of layout
      this._mountVerticalLayout();
      this._disableScrollNavSync();
      this._navVisible = true;
      if (this._navEl) {
        this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      }
    }
  }

  // Ensure layout mounted if needed (idempotent)
  _ensureMounted() {
    if (!this._isMobileScreen()) {
      if (!document.body.classList.contains('has-left-rail')) {
        this._mountVerticalLayout();
      }
    }
  }

  // Move body children (except nav) into .site-main, and mark body with class
  _mountVerticalLayout() {
    if (!this._navEl) return;
    if (document.body.classList.contains('has-left-rail')) return;

    const nav = this._navEl;
    const siteMain = document.createElement('div');
    siteMain.className = 'site-main';

    // Move every child of body except the nav into siteMain
    // Use a live-safe approach: collect then move
    const children = Array.from(document.body.childNodes);
    for (let i = 0; i < children.length; i++) {
      const node = children[i];
      if (node === nav) continue;
      siteMain.appendChild(node);
    }

    // Append siteMain after nav
    document.body.appendChild(siteMain);

    // Mark body
    document.body.classList.add('has-left-rail');

    // Sync CSS variables for rail widths so other styles (e.g., footer) can use them
    document.documentElement.style.setProperty('--left-rail-width', this.leftRailWidth);
    document.documentElement.style.setProperty('--left-rail-width-collapsed', this.leftRailCollapsedWidth);

    // Adjust nav inline styles to be in-flow (CSS already handles visual)
    nav.style.position = 'relative';
    nav.style.height = '100vh';
    nav.style.top = '0';
    nav.style.left = '0';
    nav.style.transform = 'none';
    nav.style.zIndex = '';
  }

  // Reverse the mount: move children from .site-main back to body (after nav), remove marker
  _unmountVerticalLayout() {
    if (!this._navEl) return;
    if (!document.body.classList.contains('has-left-rail')) return;

    const nav = this._navEl;
    const siteMain = document.querySelector('.site-main');
    if (siteMain) {
      // Move each child back to body (insert before the siteMain element so order preserved)
      const nodes = Array.from(siteMain.childNodes);
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        document.body.insertBefore(node, siteMain);
      }
      // Remove empty siteMain
      if (siteMain.parentNode) siteMain.parentNode.removeChild(siteMain);
    }

    document.body.classList.remove('has-left-rail');

    // Remove CSS variables so default mobile styling applies
    document.documentElement.style.removeProperty('--left-rail-width');
    document.documentElement.style.removeProperty('--left-rail-width-collapsed');

    // Restore nav inline styles so it behaves as mobile bottom bar
    nav.style.position = '';
    nav.style.height = '';
    nav.style.top = '';
    nav.style.left = '';
    nav.style.transform = '';
    nav.style.zIndex = '16000';
  }

  _enableScrollNavSync() {
    if (this._navScrollSyncEnabled) return;
    window.addEventListener('scroll', e => this._onUltraScrollNav(e), { passive: true });
    window.addEventListener('touchstart', e => { this._isTouching = true; this._lastScrollY = window.scrollY; }, { passive: true });
    window.addEventListener('touchend', e => { this._isTouching = false; }, { passive: true });
    if (this._navEl) {
      this._navEl.style.willChange = 'transform';
      this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      this._navEl.style.transition = 'transform 0.22s cubic-bezier(0.33,1,0.68,1)';
      this._navVisible = true;
    }
    this._navScrollSyncEnabled = true;
  }

  _disableScrollNavSync() {
    // No-op: Event listeners are anonymous and GC will collect, no need to remove
    if (this._navEl) {
      this._navEl.style.willChange = 'transform';
      this._navEl.style.transform = 'translateZ(0) translateY(0%)';
      this._navEl.style.transition = 'transform 0.22s cubic-bezier(0.33,1,0.68,1)';
      this._navVisible = true;
    }
    this._navScrollSyncEnabled = false;
  }

  _onUltraScrollNav(e) {
    if (!this._navEl) return;
    const y = window.scrollY;
    let delta = y - this._lastScrollY;
    this._lastScrollY = y;
    if (y <= this.SHOW_THRESHOLD) {
      if (!this._navVisible) this._ultraShowNav();
      return;
    }
    if (this._isTouching) {
      if (delta > 15) {
        if (this._navVisible) this._ultraHideNav();
      } else if (delta < -10) {
        if (!this._navVisible) this._ultraShowNav();
      }
    }
  }

  _ultraShowNav() {
    if (!this._navEl) return;
    this._navEl.style.willChange = 'transform';
    this._navEl.style.transform = 'translateZ(0) translateY(0%)';
    this._navEl.style.transition = 'transform 0.22s cubic-bezier(0.33,1,0.68,1)';
    if (!this._navVisible) {
      this._navVisible = true;
    }
  }

  _ultraHideNav() {
    if (!this._navEl) return;
    this._navEl.style.willChange = 'transform';
    this._navEl.style.transform = 'translateZ(0) translateY(100%)';
    this._navEl.style.transition = 'transform 0.19s cubic-bezier(0.65,0,0.35,1)';
    if (this._navVisible) {
      this._navVisible = false;
    }
  }

  _cleanup() {
    // Remove resize/orientation listeners we added
    window.removeEventListener('resize', this._resizeHandler, { passive: true });
    window.removeEventListener('orientationchange', this._orientationHandler, { passive: true });
    window.removeEventListener('scroll', this._scrollHandler, { passive: true });
    window.removeEventListener('storage', this._storageHandler, { passive: true });

    this._navEl = null;
    this._initialized = false;
    localStorage.setItem = this._originalSetItem;
  }
  destroy() {
    this._cleanup();
  }
}

(function ultraLaunchModernNav() {
  const navigation = new ModernNavigation({
    cssPath: '/assets/css/modern-styles.min.css',
    configPath: '/assets/json/template/template.min.json',
    defaultButtonClass: 'default-button',
    leftRailWidth: '88px',
    leftRailCollapsedWidth: '72px'
  });
  queueMicrotask(() => {
    navigation.init().catch(error => {
      console.error('เกิดข้อผิดพลาดในการ initialize navigation:', error);
    });
  });
})();