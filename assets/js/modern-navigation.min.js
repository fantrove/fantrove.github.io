/**
 * ModernNavigation Ultra Edition + Optimized Scroll Sync Hide/Show (Mobile Only, 2025-07-27)
 * - Blazing fast, ultra-lightweight, imperceptible nav rendering.
 * - Bottom nav scroll sync works ONLY on mobile devices/small screens.
 * - On large screens, nav stays fixed and does not sync with scroll.
 * - At scrollTop <= SHOW_THRESHOLD (default 40px from top), nav always shows smoothly.
 * - All original navigation logic preserved.
 */
class ModernNavigation {
 constructor(config = {}) {
  this.cssPath = config.cssPath || '/assets/css/modern-styles.min.css';
  this.configPath = config.configPath || '/assets/json/buttons.min.json';
  this.activeClass = config.activeClass || 'active-1';
  this.navItemSelector = config.navItemSelector || '.nav-item';
  this.defaultButtonClass = config.defaultButtonClass || 'default-button';
  this.defaultLang = 'en';
  this.currentLang = localStorage.getItem('selectedLang') || this.defaultLang;
  this.navigationCache = new Map();

  this._boundClickHandler = this._handleClick.bind(this);
  this._boundPointerUpHandler = this._handlePointerUp.bind(this);
  this._boundScrollHandler = this._handleScroll.bind(this);
  this._boundLangChangeHandler = this._handleLanguageChange.bind(this);
  this._boundStorageHandler = this._handleStorageChange.bind(this);
  this._originalSetItem = localStorage.setItem;

  this._initialized = false;
  this._eventsBound = false;
  this._config = null;
  this._scrollTimeout = null;

  // For smart scroll sync nav
  this._navShowTranslate = 0;
  this._navHideTranslate = 100;
  this._navMinShow = 0;
  this._navMaxHide = 100;
  this._lastScrollY = window.scrollY;
  this._velocity = 0;
  this._currentTranslate = 0;
  this._rafNav = null;
  this._touching = false;
  this._navEl = null;
  this._lastScreenIsMobile = false;
  this._settleTimeout = null;

  // Customizable threshold from top (px)
  this.SHOW_THRESHOLD = 40;
 }

 async init() {
  if (this._initialized) return;
  try {
   ModernNavigation._preconnect(this.configPath);
   await this._loadCSS();
   this._config = await this._loadConfig();
   const navFragment = this._createNavigationItemsFragment();
   this._injectNavigation(navFragment);
   queueMicrotask(() => {
    this._setupNavigation();
    this._setupLanguageListener();
    this._setupStorageListener();
    this._updateActiveState();
    this._setupScrollSyncHideShow();
    this._initialized = true;
   });
  } catch (error) {
   this._cleanup();
   throw error;
  }
 }

 static _preconnect(configPath) {
  try {
   const url = new URL(configPath, location.origin);
   if (!document.querySelector(`link[rel="preconnect"][href="${url.origin}"]`)) {
    const link = document.createElement('link');
    link.rel = 'preconnect';
    link.href = url.origin;
    document.head.appendChild(link);
   }
  } catch (_) {}
 }

 _injectNavigation(fragment) {
  if (document.querySelector('.bottom-nav')) return;
  const navEl = document.createElement('div');
  navEl.className = 'bottom-nav';
  navEl.appendChild(fragment);
  document.body.insertBefore(navEl, document.body.firstChild);
 }

 _createNavigationItemsFragment() {
  const fragment = document.createDocumentFragment();
  const config = this._config?.navigation;
  if (!config) return fragment;
  const lang = this.currentLang;
  let i = 0, len = config.length;
  while (i < len) {
   const item = config[i++];
   const btn = document.createElement('button');
   btn.className = 'nav-item ' + (item.customClass || this.defaultButtonClass);
   btn.dataset.link = item.url;
   if (item.icon) {
    const iconSpan = document.createElement('span');
    iconSpan.innerHTML = item.icon;
    while (iconSpan.firstChild) btn.appendChild(iconSpan.firstChild);
   }
   const label = document.createElement('div');
   label.className = 'label';
   label.textContent = item[`${lang}_label`] || item.en_label || 'Missing Label';
   btn.appendChild(label);
   fragment.appendChild(btn);
  }
  return fragment;
 }

 _updateLabels() {
  const nav = document.querySelector('.bottom-nav');
  if (!nav || !this._config?.navigation) return;
  const config = this._config.navigation;
  const lang = this.currentLang;
  const items = nav.querySelectorAll(this.navItemSelector);
  let i = 0, l = items.length;
  while (i < l) {
   const item = items[i++];
   const link = item.dataset.link;
   const cfg = config.find(nav => nav.url === link);
   if (cfg) {
    const label = item.querySelector('.label');
    if (label) label.textContent = cfg[`${lang}_label`] || cfg.en_label || 'Missing Label';
   }
  }
 }

 _updateLanguage(newLanguage) {
  if (newLanguage && newLanguage !== this.currentLang) {
   this.currentLang = newLanguage;
   this._updateLabels();
  }
 }

 _handleClick(event) {
  const item = event.target.closest(this.navItemSelector);
  if (!item) return;
  if (event.type !== "click" || event.button !== 0) return;
  const targetLink = item.dataset.link;
  if (targetLink && !item.classList.contains(this.activeClass)) {
   if (window.location.pathname.endsWith(targetLink)) return;
   window.location.assign(targetLink);
  }
 }

 _handlePointerUp(event) {
  // Only for wave effect, not navigation
 }

 _handleScroll() {
  if (!this._scrollTimeout) {
   this._scrollTimeout = window.requestAnimationFrame(() => {
    this._updateActiveState();
    this._scrollTimeout = null;
   });
  }
 }

 _handleStorageChange(event) {
  if (event.key === 'selectedLang') {
   this._updateLanguage(event.newValue);
  }
 }

 _updateActiveState() {
  const currentPath = window.location.pathname;
  const nav = document.querySelector('.bottom-nav');
  if (!nav) return;
  const items = nav.querySelectorAll(this.navItemSelector);
  let i = 0, l = items.length;
  while (i < l) {
   const item = items[i++];
   const navLink = item.dataset.link;
   if (navLink === '/' || navLink === '/index.html') {
    item.classList.toggle(this.activeClass, currentPath === '/' || currentPath.endsWith('/index.html'));
   } else {
    const normalized = navLink.endsWith('/') ? navLink : navLink + '/';
    item.classList.toggle(this.activeClass, currentPath.startsWith(normalized));
   }
  }
 }

 _handleLanguageChange(event) {
  this.currentLang = event.detail.language;
  this._updateLabels();
 }

 _setupNavigation() {
  if (this._eventsBound) return;
  const nav = document.querySelector('.bottom-nav');
  if (nav) {
   nav.addEventListener('click', this._boundClickHandler, { passive: true });
   nav.addEventListener('pointerup', this._boundPointerUpHandler, { passive: true });
  }
  window.addEventListener('scroll', this._boundScrollHandler, { passive: true });
  this._eventsBound = true;
 }

 _setupLanguageListener() {
  window.addEventListener('languageChange', this._boundLangChangeHandler);
 }

 _setupStorageListener() {
  window.addEventListener('storage', this._boundStorageHandler);
  localStorage.setItem = (key, value) => {
   this._originalSetItem.call(localStorage, key, value);
   if (key === 'selectedLang') {
    this._updateLanguage(value);
   }
  };
 }

 async _loadCSS() {
  if (document.querySelector(`link[href="${this.cssPath}"]`)) return;
  if (!document.querySelector(`link[rel="preload"][href="${this.cssPath}"]`)) {
   const preload = document.createElement('link');
   preload.rel = 'preload';
   preload.as = 'style';
   preload.href = this.cssPath;
   document.head.appendChild(preload);
  }
  await new Promise((resolve, reject) => {
   const link = document.createElement('link');
   link.rel = 'stylesheet';
   link.href = this.cssPath;
   link.media = 'all';
   link.onload = () => resolve();
   link.onerror = reject;
   document.head.appendChild(link);
  });
 }

 async _loadConfig() {
  if ('caches' in window) {
   try {
    const cache = await caches.open('modern-nav-config');
    let response = await cache.match(this.configPath);
    if (!response) {
     response = await fetch(this.configPath, { cache: 'reload', credentials: 'same-origin' });
     if (response.ok) await cache.put(this.configPath, response.clone());
    }
    if (response && response.ok) {
     return await response.json();
    }
   } catch (e) { }
  }
  const cached = this.navigationCache.get('config');
  if (cached && Date.now() - cached.timestamp < 300000) {
   return cached.data;
  }
  const fetchPromise = fetch(this.configPath, { cache: 'force-cache', credentials: 'same-origin' })
   .then(resp => {
    if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
    return resp.json();
   });
  const timeoutPromise = new Promise((_, rej) => setTimeout(() => rej(new Error('Fetch timeout')), 7));
  let result;
  try {
   result = await Promise.race([fetchPromise, timeoutPromise]);
  } catch (e) {
   result = await fetchPromise;
  }
  this.navigationCache.set('config', { data: result, timestamp: Date.now() });
  return result;
 }

 // === OPTIMIZED SMART SCROLL SYNC HIDE/SHOW Bottom Navigation (Mobile Only) ===
 _setupScrollSyncHideShow() {
  this._navEl = document.querySelector('.bottom-nav');
  if (!this._navEl) return;
  this._lastScrollY = window.scrollY;
  this._currentTranslate = 0;
  this._velocity = 0;
  this._touching = false;
  if (this._settleTimeout) clearTimeout(this._settleTimeout);
  window.addEventListener('resize', this._onResizeScreenForNav, {passive:true});
  window.addEventListener('orientationchange', this._onResizeScreenForNav, {passive:true});
  this._applyScrollNavBehaviorForScreen();
 }

 _onResizeScreenForNav = () => {
  this._applyScrollNavBehaviorForScreen();
 }

 _isMobileScreen() {
  return window.innerWidth < 768 || window.matchMedia('(pointer:coarse) and (max-width:900px)').matches;
 }

 _applyScrollNavBehaviorForScreen() {
  const isMobile = this._isMobileScreen();
  if (isMobile === this._lastScreenIsMobile) return;
  this._lastScreenIsMobile = isMobile;
  if (isMobile) {
   this._enableScrollNavSync();
  } else {
   this._disableScrollNavSync();
  }
 }

 _enableScrollNavSync() {
  if (this._navScrollSyncEnabled) return;
  window.addEventListener('scroll', this._onScrollSyncNav, {passive:true});
  window.addEventListener('touchstart', this._onTouchStartNav, {passive:true});
  window.addEventListener('touchend', this._onTouchEndNav, {passive:true});
  window.addEventListener('touchcancel', this._onTouchEndNav, {passive:true});
  if (this._navEl) {
   this._navEl.style.transition = '';
   this._navEl.style.transform = 'translateY(0%)';
   this._currentTranslate = 0;
  }
  this._navScrollSyncEnabled = true;
 }
 _disableScrollNavSync() {
  window.removeEventListener('scroll', this._onScrollSyncNav);
  window.removeEventListener('touchstart', this._onTouchStartNav);
  window.removeEventListener('touchend', this._onTouchEndNav);
  window.removeEventListener('touchcancel', this._onTouchEndNav);
  if (this._navEl) {
   this._navEl.style.transition = '';
   this._navEl.style.transform = 'translateY(0%)';
   this._currentTranslate = 0;
  }
  if (this._settleTimeout) clearTimeout(this._settleTimeout);
  this._navScrollSyncEnabled = false;
 }

 _onScrollSyncNav = () => {
  if (!this._rafNav) {
   this._rafNav = requestAnimationFrame(this._updateNavPositionOnScroll);
  }
 }

 _onTouchStartNav = () => {
  this._touching = true;
  if (this._settleTimeout) clearTimeout(this._settleTimeout);
 }
 _onTouchEndNav = () => {
  this._touching = false;
  if (this._settleTimeout) clearTimeout(this._settleTimeout);
  this._settleTimeout = setTimeout(()=>this._settleNavAfterScroll(), 96);
 }

 _updateNavPositionOnScroll = () => {
  if (!this._navScrollSyncEnabled) return;
  const nav = this._navEl;
  if (!nav) return;
  const y = window.scrollY;

  // Always show nav when near top threshold (SHOW_THRESHOLD px)
  if (y <= this.SHOW_THRESHOLD) {
   if (this._currentTranslate !== 0) {
    nav.style.transition = 'transform 0.32s cubic-bezier(0.4,0,0.2,1)';
    nav.style.transform = 'translateY(0%)';
    this._currentTranslate = 0;
   }
   this._lastScrollY = y;
   this._rafNav = null;
   return;
  }

  let deltaY = y - this._lastScrollY;
  this._lastScrollY = y;
  if (deltaY > 32) deltaY = 32;
  if (deltaY < -32) deltaY = -32;
  let nextTranslate = this._currentTranslate + deltaY * 0.82;
  nextTranslate = Math.max(this._navMinShow, Math.min(this._navMaxHide, nextTranslate));
  this._currentTranslate = nextTranslate;
  nav.style.transition = 'none';
  nav.style.transform = `translateY(${nextTranslate}%)`;
  if (this._settleTimeout) clearTimeout(this._settleTimeout);
  if (!this._touching) {
   this._settleTimeout = setTimeout(()=>this._settleNavAfterScroll(), 128);
  }
  this._rafNav = null;
 }

 _settleNavAfterScroll() {
  if (!this._navScrollSyncEnabled) return;
  const nav = this._navEl;
  if (!nav) return;
  // Always show nav if near top
  if (window.scrollY <= this.SHOW_THRESHOLD) {
   nav.style.transition = 'transform 0.32s cubic-bezier(0.4,0,0.2,1)';
   nav.style.transform = 'translateY(0%)';
   this._currentTranslate = 0;
   return;
  }
  const threshold = 44;
  let to = (this._currentTranslate > threshold) ? this._navMaxHide : this._navMinShow;
  nav.style.transition = 'transform 0.32s cubic-bezier(0.4,0,0.2,1)';
  nav.style.transform = `translateY(${to}%)`;
  this._currentTranslate = to;
 }

 _cleanup() {
  if (this._eventsBound) {
   const nav = document.querySelector('.bottom-nav');
   if (nav) {
    nav.removeEventListener('click', this._boundClickHandler, { passive: true });
    nav.removeEventListener('pointerup', this._boundPointerUpHandler, { passive: true });
   }
   window.removeEventListener('scroll', this._boundScrollHandler);
   window.removeEventListener('languageChange', this._boundLangChangeHandler);
   window.removeEventListener('storage', this._boundStorageHandler);
   localStorage.setItem = this._originalSetItem;
   if (this._scrollTimeout) {
    window.cancelAnimationFrame(this._scrollTimeout);
    this._scrollTimeout = null;
   }
   this._eventsBound = false;
  }
  window.removeEventListener('resize', this._onResizeScreenForNav);
  window.removeEventListener('orientationchange', this._onResizeScreenForNav);
  this._disableScrollNavSync();
  if (this._settleTimeout) clearTimeout(this._settleTimeout);
 }

 destroy() {
  this._cleanup();
  this._initialized = false;
 }
}

(function ultraLaunchModernNav() {
 const navigation = new ModernNavigation({
  cssPath: '/assets/css/modern-styles.min.css',
  configPath: '/assets/json/template/template.min.json',
  defaultButtonClass: 'default-button'
 });
 queueMicrotask(() => {
  navigation.init().catch(error => {
   console.error('เกิดข้อผิดพลาดในการ initialize navigation:', error);
  });
 }) ;
})();