/**
 * ModernNavigation Ultra Edition + ULTRA-ADVANCED Scroll Sync Hide/Show (Mobile Only, 2025-07-28)
 * - Uses intent prediction and velocity for bottom nav.
 * - Nav show/hide triggers IMMEDIATELY while finger is dragging/scrolling, not only after touchend.
 * - Minimal event binding, ultra-lightweight and responsive.
 * - All navigation, multi-language, and active state logic preserved.
 * - No per-pixel or per-frame nav updates!
 */
class ModernNavigation {
 constructor(config = {}) {
  this.cssPath = config.cssPath || '/assets/css/modern-styles.min.css';
  this.configPath = config.configPath || '/assets/json/buttons.min.json';
  this.activeClass = config.activeClass || 'active-1';
  this.navItemSelector = config.navItemSelector || '.nav-item';
  this.defaultButtonClass = config.defaultButtonClass || 'default-button';
  this.defaultLang = 'en';
  this.currentLang = localStorage.getItem('selectedLang') || this.defaultLang;
  this.navigationCache = new Map();

  this._boundClickHandler = this._handleClick.bind(this);
  this._boundPointerUpHandler = this._handlePointerUp.bind(this);
  this._boundScrollHandler = this._handleScroll.bind(this);
  this._boundLangChangeHandler = this._handleLanguageChange.bind(this);
  this._boundStorageHandler = this._handleStorageChange.bind(this);
  this._originalSetItem = localStorage.setItem;

  this._initialized = false;
  this._eventsBound = false;
  this._config = null;
  this._scrollTimeout = null;

  // For nav sync
  this._navEl = null;
  this._lastScreenIsMobile = false;
  this._navScrollSyncEnabled = false;

  // Advanced state
  this._lastScrollY = window.scrollY;
  this._navVisible = true;
  this.SHOW_THRESHOLD = 40;

  // Touch state
  this._isTouching = false;
 }

 async init() {
  if (this._initialized) return;
  try {
   ModernNavigation._preconnect(this.configPath);
   await this._loadCSS();
   this._config = await this._loadConfig();
   const navFragment = this._createNavigationItemsFragment();
   this._injectNavigation(navFragment);
   queueMicrotask(() => {
    this._setupNavigation();
    this._setupLanguageListener();
    this._setupStorageListener();
    this._updateActiveState();
    this._setupScrollSyncHideShow();
    this._initialized = true;
   });
  } catch (error) {
   this._cleanup();
   throw error;
  }
 }

 static _preconnect(configPath) {
  try {
   const url = new URL(configPath, location.origin);
   if (!document.querySelector(`link[rel="preconnect"][href="${url.origin}"]`)) {
    const link = document.createElement('link');
    link.rel = 'preconnect';
    link.href = url.origin;
    document.head.appendChild(link);
   }
  } catch (_) {}
 }

 _injectNavigation(fragment) {
  if (document.querySelector('.bottom-nav')) return;
  const navEl = document.createElement('div');
  navEl.className = 'bottom-nav';
  navEl.appendChild(fragment);
  document.body.insertBefore(navEl, document.body.firstChild);
 }

 _createNavigationItemsFragment() {
  const fragment = document.createDocumentFragment();
  const config = this._config?.navigation;
  if (!config) return fragment;
  const lang = this.currentLang;
  let i = 0, len = config.length;
  while (i < len) {
   const item = config[i++];
   const btn = document.createElement('button');
   btn.className = 'nav-item ' + (item.customClass || this.defaultButtonClass);
   btn.dataset.link = item.url;
   if (item.icon) {
    const iconSpan = document.createElement('span');
    iconSpan.innerHTML = item.icon;
    while (iconSpan.firstChild) btn.appendChild(iconSpan.firstChild);
   }
   const label = document.createElement('div');
   label.className = 'label';
   label.textContent = item[`${lang}_label`] || item.en_label || 'Missing Label';
   btn.appendChild(label);
   fragment.appendChild(btn);
  }
  return fragment;
 }

 _updateLabels() {
  const nav = document.querySelector('.bottom-nav');
  if (!nav || !this._config?.navigation) return;
  const config = this._config.navigation;
  const lang = this.currentLang;
  const items = nav.querySelectorAll(this.navItemSelector);
  let i = 0, l = items.length;
  while (i < l) {
   const item = items[i++];
   const link = item.dataset.link;
   const cfg = config.find(nav => nav.url === link);
   if (cfg) {
    const label = item.querySelector('.label');
    if (label) label.textContent = cfg[`${lang}_label`] || cfg.en_label || 'Missing Label';
   }
  }
 }

 _updateLanguage(newLanguage) {
  if (newLanguage && newLanguage !== this.currentLang) {
   this.currentLang = newLanguage;
   this._updateLabels();
  }
 }

 _handleClick(event) {
  const item = event.target.closest(this.navItemSelector);
  if (!item) return;
  if (event.type !== "click" || event.button !== 0) return;
  const targetLink = item.dataset.link;
  if (targetLink && !item.classList.contains(this.activeClass)) {
   if (window.location.pathname.endsWith(targetLink)) return;
   window.location.assign(targetLink);
  }
 }

 _handlePointerUp(event) {}

 _handleScroll() {
  if (!this._scrollTimeout) {
   this._scrollTimeout = window.requestAnimationFrame(() => {
    this._updateActiveState();
    this._scrollTimeout = null;
   });
  }
 }

 _handleStorageChange(event) {
  if (event.key === 'selectedLang') {
   this._updateLanguage(event.newValue);
  }
 }

 _updateActiveState() {
  const currentPath = window.location.pathname;
  const nav = document.querySelector('.bottom-nav');
  if (!nav) return;
  const items = nav.querySelectorAll(this.navItemSelector);
  let i = 0, l = items.length;
  while (i < l) {
   const item = items[i++];
   const navLink = item.dataset.link;
   if (navLink === '/' || navLink === '/index.html') {
    item.classList.toggle(this.activeClass, currentPath === '/' || currentPath.endsWith('/index.html'));
   } else {
    const normalized = navLink.endsWith('/') ? navLink : navLink + '/';
    item.classList.toggle(this.activeClass, currentPath.startsWith(normalized));
   }
  }
 }

 _handleLanguageChange(event) {
  this.currentLang = event.detail.language;
  this._updateLabels();
 }

 _setupNavigation() {
  if (this._eventsBound) return;
  const nav = document.querySelector('.bottom-nav');
  if (nav) {
   nav.addEventListener('click', this._boundClickHandler, { passive: true });
   nav.addEventListener('pointerup', this._boundPointerUpHandler, { passive: true });
  }
  window.addEventListener('scroll', this._boundScrollHandler, { passive: true });
  this._eventsBound = true;
 }

 _setupLanguageListener() {
  window.addEventListener('languageChange', this._boundLangChangeHandler);
 }

 _setupStorageListener() {
  window.addEventListener('storage', this._boundStorageHandler);
  localStorage.setItem = (key, value) => {
   this._originalSetItem.call(localStorage, key, value);
   if (key === 'selectedLang') {
    this._updateLanguage(value);
   }
  };
 }

 async _loadCSS() {
  if (document.querySelector(`link[href="${this.cssPath}"]`)) return;
  if (!document.querySelector(`link[rel="preload"][href="${this.cssPath}"]`)) {
   const preload = document.createElement('link');
   preload.rel = 'preload';
   preload.as = 'style';
   preload.href = this.cssPath;
   document.head.appendChild(preload);
  }
  await new Promise((resolve, reject) => {
   const link = document.createElement('link');
   link.rel = 'stylesheet';
   link.href = this.cssPath;
   link.media = 'all';
   link.onload = () => resolve();
   link.onerror = reject;
   document.head.appendChild(link);
  });
 }

 // ปรับปรุงฟังก์ชันนี้: ตรวจสอบการอัพเดทไฟล์ config ทุกครั้งที่เข้าเว็บ
 async _loadConfig() {
  if ('caches' in window) {
   try {
    const cache = await caches.open('modern-nav-config');
    let cachedResponse = await cache.match(this.configPath);

    // ดึง header ล่าสุดจากเซิร์ฟเวอร์เพื่อเช็ค ETag/Last-Modified
    let serverETag = null, serverLastModified = null;
    try {
     let headResp = await fetch(this.configPath, { method: 'HEAD', credentials: 'same-origin' });
     serverETag = headResp.headers.get('ETag');
     serverLastModified = headResp.headers.get('Last-Modified');
    } catch(e) {}

    let updateNeeded = true;
    if (cachedResponse) {
     let cachedETag = cachedResponse.headers.get('ETag');
     let cachedLastModified = cachedResponse.headers.get('Last-Modified');
     if ((serverETag && cachedETag === serverETag) ||
         (serverLastModified && cachedLastModified === serverLastModified)) {
      updateNeeded = false;
     }
    }
    let response;
    if (updateNeeded) {
     response = await fetch(this.configPath, { cache: 'reload', credentials: 'same-origin' });
     if (response.ok) await cache.put(this.configPath, response.clone());
    } else {
     response = cachedResponse;
    }
    if (response && response.ok) {
     return await response.json();
    }
   } catch (e) { }
  }
  // fallback: ดึงไฟล์ใหม่เสมอ
  const fetchPromise = fetch(this.configPath, { cache: 'no-store', credentials: 'same-origin' })
   .then(resp => {
    if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
    return resp.json();
   });
  const timeoutPromise = new Promise((_, rej) => setTimeout(() => rej(new Error('Fetch timeout')), 7));
  let result;
  try {
   result = await Promise.race([fetchPromise, timeoutPromise]);
  } catch (e) {
   result = await fetchPromise;
  }
  return result;
 }

 // === ULTRA-ADVANCED SMART SCROLL SYNC HIDE/SHOW Bottom Navigation (Mobile Only) ===
 _setupScrollSyncHideShow() {
  this._navEl = document.querySelector('.bottom-nav');
  if (!this._navEl) return;
  this._lastScrollY = window.scrollY;
  this._navVisible = true;
  this._isTouching = false;
  window.addEventListener('resize', this._onResizeScreenForNav, {passive:true});
  window.addEventListener('orientationchange', this._onResizeScreenForNav, {passive:true});
  this._applyScrollNavBehaviorForScreen();
 }

 _onResizeScreenForNav = () => {
  this._applyScrollNavBehaviorForScreen();
 }

 _isMobileScreen() {
  return window.innerWidth < 768 || window.matchMedia('(pointer:coarse) and (max-width:900px)').matches;
 }

 _applyScrollNavBehaviorForScreen() {
  const isMobile = this._isMobileScreen();
  if (isMobile === this._lastScreenIsMobile) return;
  this._lastScreenIsMobile = isMobile;
  if (isMobile) {
   this._enableScrollNavSync();
  } else {
   this._disableScrollNavSync();
  }
 }

 _enableScrollNavSync() {
  if (this._navScrollSyncEnabled) return;
  this._ultraScrollHandler = this._onUltraScrollNav.bind(this);
  this._touchStartHandler = this._onUltraTouchStart.bind(this);
  this._touchMoveHandler = this._onUltraTouchMove.bind(this);
  this._touchEndHandler = this._onUltraTouchEnd.bind(this);

  window.addEventListener('scroll', this._ultraScrollHandler, {passive:true});
  window.addEventListener('touchstart', this._touchStartHandler, {passive:true});
  window.addEventListener('touchmove', this._touchMoveHandler, {passive:true});
  window.addEventListener('touchend', this._touchEndHandler, {passive:true});
  window.addEventListener('touchcancel', this._touchEndHandler, {passive:true});

  if (this._navEl) {
   this._navEl.style.transition = '';
   this._navEl.style.transform = 'translateY(0%)';
   this._navVisible = true;
  }
  this._navScrollSyncEnabled = true;
 }

 _disableScrollNavSync() {
  window.removeEventListener('scroll', this._ultraScrollHandler);
  window.removeEventListener('touchstart', this._touchStartHandler);
  window.removeEventListener('touchmove', this._touchMoveHandler);
  window.removeEventListener('touchend', this._touchEndHandler);
  window.removeEventListener('touchcancel', this._touchEndHandler);
  if (this._navEl) {
   this._navEl.style.transition = '';
   this._navEl.style.transform = 'translateY(0%)';
   this._navVisible = true;
  }
  this._navScrollSyncEnabled = false;
 }

 _onUltraTouchStart(e) {
  this._isTouching = true;
  this._lastScrollY = window.scrollY;
 }
 _onUltraTouchEnd(e) {
  this._isTouching = false;
 }

 _onUltraTouchMove(e) {
  // No-op, but could be extended for more fine gesture detection
 }

 _onUltraScrollNav(e) {
  // Always use latest scrollY for delta comparison
  const nav = this._navEl;
  if (!nav) return;
  const y = window.scrollY;
  let delta = y - this._lastScrollY;
  this._lastScrollY = y;

  // Always show nav near top
  if (y <= this.SHOW_THRESHOLD) {
   if (!this._navVisible) this._ultraShowNav();
   return;
  }

  // IMMEDIATE: If user is touching and scrolls down/up, hide/show nav instantly
  if (this._isTouching) {
   if (delta > 15) { // Scroll down
    if (this._navVisible) this._ultraHideNav();
   } else if (delta < -10) { // Scroll up
    if (!this._navVisible) this._ultraShowNav();
   }
  }
  // Optionally: when not touching, nav stays in last state until next touch/scroll
 }

 _ultraShowNav() {
  if (!this._navEl) return;
  this._navEl.style.transition = 'transform 0.32s cubic-bezier(0.4,0,0.2,1)';
  this._navEl.style.transform = 'translateY(0%)';
  this._navVisible = true;
 }

 _ultraHideNav() {
  if (!this._navEl) return;
  this._navEl.style.transition = 'transform 0.32s cubic-bezier(0.4,0,0.2,1)';
  this._navEl.style.transform = 'translateY(100%)';
  this._navVisible = false;
 }

 _cleanup() {
  if (this._eventsBound) {
   const nav = document.querySelector('.bottom-nav');
   if (nav) {
    nav.removeEventListener('click', this._boundClickHandler, { passive: true });
    nav.removeEventListener('pointerup', this._boundPointerUpHandler, { passive: true });
   }
   window.removeEventListener('scroll', this._boundScrollHandler);
   window.removeEventListener('languageChange', this._boundLangChangeHandler);
   window.removeEventListener('storage', this._boundStorageHandler);
   localStorage.setItem = this._originalSetItem;
   if (this._scrollTimeout) {
    window.cancelAnimationFrame(this._scrollTimeout);
    this._scrollTimeout = null;
   }
   this._eventsBound = false;
  }
  window.removeEventListener('resize', this._onResizeScreenForNav);
  window.removeEventListener('orientationchange', this._onResizeScreenForNav);
  this._disableScrollNavSync();
 }

 destroy() {
  this._cleanup();
  this._initialized = false;
 }
}

(function ultraLaunchModernNav() {
 const navigation = new ModernNavigation({
  cssPath: '/assets/css/modern-styles.min.css',
  configPath: '/assets/json/template/template.min.json',
  defaultButtonClass: 'default-button'
 });
 queueMicrotask(() => {
  navigation.init().catch(error => {
   console.error('เกิดข้อผิดพลาดในการ initialize navigation:', error);
  });
 }) ;
})();
